<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>(: Smile Composer — stable memos, focused edit, unified preview)</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { --tab: 32px; --soft-bg: #fafafa; --hover-bg: #f6f6f6; --select-bg: #f2f2f2; --rule: rgba(0,0,0,0.08); --sidebar-w: 360px; }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif; background: #fff; color: #111; padding: 24px; margin: 0; }
    .layout { display: grid; grid-template-columns: 1fr var(--sidebar-w); gap: 16px; align-items: start; }
    .left-column { display: grid; grid-template-rows: auto auto; gap: 12px; }
    .panel { background: #fff; padding: 16px; box-shadow: 0 1px 0 0 var(--rule); border-radius: 10px; }

    .sc-title { font-size: inherit; font-weight: 400; margin-bottom: 8px; }
    .sc-title strong em { font-style: italic; }

    .line { user-select: none; padding: 8px 10px; border-radius: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; cursor: pointer; transition: background-color 0.12s ease, opacity 0.12s ease; touch-action: none; position: relative; }
    .line:hover { background-color: var(--hover-bg); }
    .line.sel { font-weight: 600; background-color: var(--select-bg); }
    .left-span { flex: 1 1 auto; min-width: 0; display: inline-flex; align-items: center; gap: 10px; }

    .hover-settings {
      position: absolute; left: 6px; top: 50%; transform: translateY(-50%);
      font-size: 12px; padding: 2px 6px; background: #fff; border: 1px solid var(--rule); border-radius: 8px;
      opacity: 0; pointer-events: none;
    }
    .line:hover .hover-settings { opacity: 1; pointer-events: auto; }
    .hover-settings:hover { background: var(--hover-bg); }

    .indent-block { margin-top: 8px; }
    .prompt-preview { white-space: pre-wrap; font-size: 13px; color: #222; }

    .underline-input, .underline-textarea {
      width: 100%; background: transparent; border: none; border-bottom: 1px solid #ccc; border-radius: 0;
      padding: 6px 2px 6px 0; font: inherit; outline: none; resize: vertical; min-height: 34px;
    }
    .underline-textarea { min-height: 80px; }

    .actions-text { font-size: inherit; color: #222; display: inline-flex; gap: 6px; flex-wrap: wrap; align-items: center; }
    .action-chip { padding: 4px 8px; border-radius: 8px; display: inline-flex; align-items: center; border: 1px solid var(--rule); background: #fff; cursor: pointer; }
    .action-chip:hover { background: var(--hover-bg); }
    .action-chip.focus { font-weight: 800; background: var(--select-bg); }

    .action-bar-inline { display: block; margin-top: 8px; }
    .action-row { display: inline-flex; align-items: center; gap: 10px; width: 100%; }
    .action-spacer { flex: 1 1 auto; }
    .action-back { font-size: 12px; color: #444; cursor: pointer; user-select: none; }
    .action-back:hover { text-decoration: underline; }
    .action-hint { font-size: 12px; color: #666; }

    .rightbar { position: sticky; top: 16px; height: calc(100vh - 32px); overflow: auto; background: #fff; box-shadow: 0 1px 0 0 var(--rule); border-radius: 10px; padding: 12px; }
    .rightbar textarea { width: 100%; height: calc(100vh - 56px); border: none; outline: none; resize: none; background: transparent; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; line-height: 1.5; }

    .add-bar .dock { border-radius: 12px; padding: 8px; background: #fff; box-shadow: 0 1px 0 0 var(--rule); }
    .omni-input { border: none; outline: none; background: transparent; font: inherit; padding: 8px 2px; width: 100%; }
    .omni-list { max-height: 320px; overflow: auto; display: grid; gap: 6px; margin-top: 6px; }
    .omni-item { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; background: var(--soft-bg); border-radius: 12px; cursor: pointer; }
    .omni-item:hover { background-color: var(--hover-bg); }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; background: #eee; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div class="error">Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useCallback, useMemo } = React;
    const TAB = 32;

    const INITIAL_DB = {
      'expert-maker': { name: 'Expert Maker', type: 'agent', input: 'Question', output: 'Answer', modules: ['meta-info', 'jargon-cot', 'identify-mistakes'] },
      'meta-info': { name: 'Meta-Information MegaBrick', type: 'mod', items: ['smile-info', 'llm-info', 'user-info'] },
      'jargon-cot': { name: 'Jargon CoT', type: 'mod', items: ['emoji-section', 'bold-words', 'top-bottom'] },
      'identify-mistakes': { name: 'Identify Mistakes and Rewrite', type: 'mod', items: ['emoji-section', 'bold-words', 'negative-rewrite'] },

      'smile-info': { name: 'Information About (: Smile', type: 'instr', text: 'Explain Smile syntax: (: flexible, [: rigid, [= literal.' },
      'llm-info': { name: 'Information About LLMs', type: 'instr', text: 'Meta-knowledge about how LLMs process instructions.' },
      'user-info': { name: 'Information About User', type: 'instr', text: 'Contextualize user needs and goals.' },

      'emoji-section': { name: 'Emoji section name', type: 'instr', text: 'Use two emoticons for section names.' },
      'bold-words': { name: 'Bold for important words', type: 'instr', text: 'Use **bold** for attention retention over long contexts.' },
      'top-bottom': { name: 'Maximize adherence through top+bottom replication', type: 'instr', text: 'Replicate critical instructions at beginning and end.' },

      'negative-rewrite': { name: 'Identify negatives and rewrite to positive', type: 'instr', text: 'Find negatives like “not” and rewrite as positive articulations.' }
    };

    class DataStore {
      constructor() { this.data = this.loadFromStorage(); this.db = { ...INITIAL_DB }; this.version = 0; }
      loadFromStorage() { try { const stored = localStorage.getItem('smileData'); return stored ? JSON.parse(stored) : {}; } catch(e){ return {}; } }
      saveToStorage(data) { try { localStorage.setItem('smileData', JSON.stringify(data)); } catch(e){} }
      get(key, def) { return key in this.data ? this.data[key] : def; }
      set(key, value) { this.data = { ...this.data, [key]: value }; this.version++; this.saveToStorage(this.data); return this.data; }
      reset() { this.data = {}; localStorage.removeItem('smileData'); this.db = { ...INITIAL_DB }; this.version++; return this.data; }
      getDbItem(id) { return this.db[id] || null; }
      addCustomDbItem(id, item) { this.db[id] = item; this.version++; }
      getAllDb() { return this.db; }
      getVersion() { return this.version; }
    }

    const moveInList = (arr, fromPos, toPos) => {
      if (fromPos === toPos || fromPos < 0 || toPos < 0 || fromPos >= arr.length) return arr;
      const newArr = [...arr];
      const [item] = newArr.splice(fromPos, 1);
      const insertPos = Math.min(toPos, newArr.length);
      newArr.splice(insertPos, 0, item);
      return newArr;
    };

    const displayNameFor = (store, dbItem, id) =>
      store.get(`nn-${id}`, store.get(`n-${dbItem.name}`, dbItem.name));

    const useInstrUi = () => {
      const [state, setState] = useState({ rowKey: null, stage: 0 });
      return {
        isFor: (rowKey) => state.rowKey === rowKey && state.stage > 0,
        stage: () => state.stage,
        openStage1: (rowKey) => setState({ rowKey, stage: 1 }),
        toStage2: () => setState(s => (s.rowKey ? { rowKey: s.rowKey, stage: 2 } : s)),
        backToStage1: () => setState(s => (s.rowKey ? { rowKey: s.rowKey, stage: 1 } : s)),
        closeAll: () => setState({ rowKey: null, stage: 0 }),
        rowKey: () => state.rowKey
      };
    };

    class RowBuilder {
      constructor(store, path) { this.store = store; this.path = path; this.rows = []; }
      build() {
        this.addAgent();
        if (this.isAtModule()) this.addModuleContent(); else this.addAgentModules();
        return this.rows;
      }
      addAgent() {
        const agent = this.getAgent(); if (!agent) return;
        this.rows.push({ key: `agent:${this.path[0]}`, type: 'agent', depth: 1, label: this.store.get(`n-${agent.name}`, agent.name) });
      }
      addModuleContent() {
        const module = this.getCurrentModule(); if (!module) return;
        const moduleDBKey = this.path[this.path.length - 1];
        this.rows.push({ key: `module:${moduleDBKey}`, type: 'module', depth: 2, label: this.store.get(`n-${module.name}`, module.name), moduleId: moduleDBKey });
        const items = this.store.get(`items-${module.name}`, module.items || []);
        items.forEach((id, i) => {
          const ins = this.store.getDbItem(id); if (!ins) return;
          this.rows.push({
            key: `ins:${id}`, type: 'instr', depth: 3,
            label: displayNameFor(this.store, ins, id),
            isOutput: i === items.length - 1,
            nameKey: `n-${ins.name}`, nameOverrideKey: `nn-${id}`,
            textKey: `t-${ins.name}`, defaultText: ins.text || '',
            metaKey: `meta-${id}`, structKey: `struct-${id}`,
            promptKey: `t-${ins.name}`, dbId: id, pos: i, canReorder: true
          });
        });
      }
      addAgentModules() {
        const agent = this.getAgent(); if (!agent) return;
        const modules = this.store.get(`mods-${agent.name}`, agent.modules || []);
        modules.forEach((mid, i) => {
          const mod = this.store.getDbItem(mid); if (!mod) return;
          this.rows.push({
            key: `mod:${mid}:${i}`, type: 'module-item', depth: 2,
            label: displayNameFor(this.store, mod, mid),
            isOutput: i === modules.length - 1,
            nameKey: `n-${mod.name}`, nameOverrideKey: `nn-${mid}`,
            metaKey: `meta-${mid}`, structKey: `struct-${mid}`,
            moduleId: mid, pos: i, canReorder: true
          });
        });
      }
      isAtModule() { return this.path.length >= 2; }
      getAgent() { return this.store.getDbItem(this.path[0]); }
      getCurrentModule() { const last = this.path[this.path.length - 1]; return this.store.getDbItem(last); }
    }

    function StructureDots5({ id, value, onChange }) {
      const opts = [
        { v: 'heavy', label: 'Heavy' },
        { v: 'heavy-mid', label: '●' },
        { v: 'medium', label: 'Medium' },
        { v: 'medium-light', label: '●' },
        { v: 'light', label: 'Light' }
      ];
      return (
        <div className="seg" role="radiogroup" aria-label="Structure">
          <span className="label">Structure</span>
          {opts.map((o) => (
            <label key={o.v} title={o.label}>
              <input type="radio" name={`struct-${id}`} value={o.v} checked={value === o.v} onChange={(e) => onChange(e.target.value)} />
              <span className="opt">
                {o.label === '●' ? <span className="dot" aria-hidden="true"></span> : <span style={{ fontSize: 12 }}>{o.label}</span>}
              </span>
            </label>
          ))}
        </div>
      );
    }

    function ActionBar({ actions, focus, onFocus, onExecute, onBack, pad }) {
      return (
        <div className="action-bar-inline" style={{ paddingLeft: pad }}>
          <div className="action-row" onClick={(e)=>e.stopPropagation()}>
            <span className="action-back" onClick={(e)=>{ e.stopPropagation(); onBack && onBack(); }} title="Exit">← Back</span>
            <span className="actions-text">
              {actions.map((a) => {
                const label = a === 'settings' ? '→ Settings' : (a[0].toUpperCase()+a.slice(1));
                const display = a === 'move' ? '↑ ↓ To Move' : label;
                return (
                  <button
                    type="button"
                    key={a}
                    className={`action-chip ${focus === a ? 'focus' : ''}`}
                    onMouseEnter={(e) => { e.stopPropagation(); onFocus && onFocus(a); }}
                    onClick={(e) => { e.stopPropagation(); onExecute && onExecute(a); }}
                    title={label}
                  >
                    {display}
                  </button>
                );
              })}
            </span>
            <span className="action-spacer"></span>
            <span className="action-hint">Esc Cancel</span>
          </div>
        </div>
      );
    }

    function InstructionInlineEditor({
      store, row, onTextChange, getNameOverride, setNameOverride,
      getMeta, setMeta, getStruct, setStruct, stage=2
    }) {
      const pad = ((row.depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          <textarea
            className="underline-textarea"
            data-tarea={row.key}
            value={store.get(row.promptKey, row.defaultText || '')}
            onChange={(e) => onTextChange(row.promptKey, e.target.value)}
            placeholder="Instruction…"
          />
          {stage === 2 && (
            <>
              <input
                type="text"
                className="underline-input"
                value={getNameOverride(row.nameOverrideKey, '')}
                onChange={(e) => setNameOverride(row.nameOverrideKey, e.target.value)}
                placeholder="Name…"
              />
              <textarea
                className="underline-textarea"
                value={getMeta(row.metaKey) || ''}
                onChange={(e) => setMeta(row.metaKey, e.target.value)}
                placeholder="Meta information…"
              />
              <StructureDots5
                id={row.dbId}
                value={getStruct(row.structKey) || 'heavy'}
                onChange={(v) => setStruct(row.structKey, v)}
              />
            </>
          )}
        </div>
      );
    }

    function InstructionPreviewLine({ store, row }) {
      const text = store.get(row.promptKey, row.defaultText || '') || '';
      const first = text.split(/\r?\n/)[0];
      const pad = ((row.depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          <div className="prompt-preview">{first || '—'}</div>
        </div>
      );
    }

    function ModulePreview({ store, moduleId, depth }) {
      const mod = store.getDbItem(moduleId);
      if (!mod) return null;
      const items = store.get(`items-${mod.name}`, mod.items || []);
      const pad = ((depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          {items.length === 0 ? <div className="prompt-preview">Empty module</div> :
            items.map((iid, idx) => {
              const ins = store.getDbItem(iid); if (!ins) return null;
              const isLast = idx === items.length - 1;
              return (
                <div key={iid} className="prompt-preview">
                  {isLast ? <strong>OUTPUT: </strong> : null}{displayNameFor(store, ins, iid)}
                </div>
              );
            })}
        </div>
      );
    }

    function RightSidebar({ value, onChange }) {
      return (
        <div className="rightbar">
          <textarea value={value} onChange={onChange}></textarea>
        </div>
      );
    }

    function App() {
      const storeRef = useRef(new DataStore());
      const store = storeRef.current;

      const [storeVersion, setStoreVersion] = useState(store.getVersion());
      const [path, setPath] = useState(() => {
        const hash = window.location.hash.slice(1);
        if (hash) { const parts = hash.split('/').filter(Boolean); if (parts.length > 0) return parts; }
        return ['expert-maker'];
      });

      const [idx, setIdx] = useState(0);
      const [navHistory, setNavHistory] = useState({});
      const [reorderState, setReorderState] = useState(null);
      const rowsRef = useRef([]);
      const [actionFocus, setActionFocus] = useState(null);
      const instrUi = useInstrUi();

      // Omni state + return-to capture
      const [omniActive, setOmniActive] = useState(false);
      const [omniQuery, setOmniQuery] = useState('');
      const [omniFocus, setOmniFocus] = useState(false);
      const [omniHover, setOmniHover] = useState(false);
      const omniInputRef = useRef(null);
      const lastIdxBeforeOmniRef = useRef(null);
      const lastKeyBeforeOmniRef = useRef(null);

      const rows = useMemo(() => {
        const builder = new RowBuilder(store, path);
        const built = builder.build();
        rowsRef.current = built;
        return built;
      }, [store, path, storeVersion]);

      const atModule = path.length >= 2;
      const agent = store.getDbItem(path[0]) || store.getDbItem('expert-maker');
      const module = atModule ? store.getDbItem(path[path.length - 1]) : null;

      const updateData = useCallback((key, value) => { store.set(key, value); setStoreVersion(store.getVersion()); }, [store]);

      // First paint in agent view selects first module item
      const didInitRef = useRef(false);
      useEffect(() => {
        if (didInitRef.current) return;
        if (path.length === 1) {
          const firstModIdx = rowsRef.current.findIndex(r => r.type === 'module-item');
          if (firstModIdx >= 0) setIdx(firstModIdx);
        }
        didInitRef.current = true;
      }, [path]);

      const agentModules = useMemo(() => agent ? (store.get(`mods-${agent.name}`, agent.modules || [])) : [], [store, agent]);

      const ensureModuleForAgent = useCallback(() => {
        if (agentModules.length > 0) return agentModules[agentModules.length - 1];
        const id = 'mod-' + Date.now();
        store.addCustomDbItem(id, { name: 'General', type: 'mod', items: [] });
        const key = `mods-${agent.name}`;
        const arr = store.get(key, agent.modules || []);
        updateData(key, [...arr, id]);
        return id;
      }, [agent, agentModules, store, updateData]);

      const addInstructionToModule = useCallback((moduleId, instrId, insertPos = null) => {
        const m = store.getDbItem(moduleId); if (!m) return;
        const key = `items-${m.name}`;
        const arr = store.get(key, m.items || []);
        const pos = (insertPos !== null && insertPos >= 0 && insertPos <= arr.length) ? insertPos : arr.length;
        const newArr = [...arr]; newArr.splice(pos, 0, instrId);
        updateData(key, newArr);
      }, [store, updateData]);

      const duplicateInstruction = useCallback((dbId, insertAtPos = null) => {
        if (!module) return;
        const m = module;
        const item = store.getDbItem(dbId); if (!item) return;
        const arr = store.get(`items-${m.name}`, m.items || []);
        const newId = 'custom-' + Date.now();
        const baseName = displayNameFor(store, item, dbId);
        const baseText = store.get(`t-${item.name}`, item.text || '');
        store.addCustomDbItem(newId, { name: baseName + ' (copy)', type: 'instr', text: baseText });
        const newArr = [...arr];
        const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
        newArr.splice(at, 0, newId); updateData(`items-${m.name}`, newArr);
        updateData(`nn-${newId}`, baseName + ' (copy)'); updateData(`t-${newId}`, baseText);
      }, [store, updateData, module]);

      const removeInstructionAtPos = useCallback((pos) => {
        if (!module) return;
        const arr = store.get(`items-${module.name}`, module.items || []);
        updateData(`items-${module.name}`, arr.filter((_, i) => i !== pos));
      }, [module, store, updateData]);

      const getActionList = (row) => {
        if (row.type === 'instr') return ['settings','move','duplicate','delete'];
        if (row.type === 'module-item') return ['move','settings','duplicate','delete'];
        return [];
      };

      // MOVE — persistent; Esc / Left / Right revert to original
      const startMove = useCallback((row) => {
        if (!module) return;
        const arrKey = `items-${module.name}`;
        const arr = store.get(arrKey, module.items || []);
        setReorderState({
          rowKey: row.key,
          itemId: row.dbId,
          arrKey,
          originalOrder: [...arr],
          originalPos: row.pos,
          currentPos: row.pos
        });
      }, [store, module]);

      const moveItemInReorderMode = useCallback((direction) => {
        if (!reorderState) return;
        const arr = store.get(reorderState.arrKey, []);
        const delta = direction === 'up' ? -1 : 1;
        const keepTo = reorderState.currentPos + delta;
        if (keepTo < 0 || keepTo >= arr.length) return;
        const newArr = moveInList(arr, reorderState.currentPos, keepTo);
        updateData(reorderState.arrKey, newArr);
        setReorderState(prev => ({ ...prev, currentPos: keepTo }));
        setActionFocus(prev => prev ? { ...prev, rowKey: `ins:${reorderState.itemId}`, action: 'move' } : prev);
      }, [reorderState, store, updateData]);

      const cancelReorder = useCallback(() => {
        if (!reorderState) return;
        const { arrKey, originalOrder, itemId, originalPos } = reorderState;
        updateData(arrKey, originalOrder);
        setReorderState(null);
        setTimeout(() => {
          const targetIdx = rowsRef.current.findIndex(r =>
            (r.type === 'instr') && (r.dbId === itemId) && r.pos === originalPos
          );
          if (targetIdx >= 0) setIdx(targetIdx);
        }, 0);
      }, [reorderState, updateData]);

      // Right sidebar prompt — SINGLE declaration
      const computedPromptText = useMemo(() => {
        if (!agent) return '';
        const mods = store.get(`mods-${agent.name}`, agent.modules || []);
        const lines = [];
        mods.forEach(mid => {
          const m = store.getDbItem(mid); if (!m) return;
          lines.push(`Module: ${displayNameFor(store, m, mid)}`);
          const ids = store.get(`items-${m.name}`, m.items || []);
          ids.forEach((iid, idx) => {
            const it = store.getDbItem(iid); if (!it) return;
            const one = store.get(`t-${it.name}`, it.text || '').split(/\r?\n/)[0];
            const prefix = (idx === ids.length - 1) ? 'OUTPUT:' : '-';
            lines.push(`  ${prefix} ${displayNameFor(store, it, iid)} — ${one}`);
          });
          lines.push('');
        });
        return lines.join('\n');
      }, [storeVersion, agent, store]);

      const rightbarManual = store.get('rightbar-prompt-manual', false);
      const rightbarValue = rightbarManual ? store.get('rightbar-prompt', '') : computedPromptText;

      // Omni — define ONCE
      const db = store.getAllDb();
      const omniResults = useMemo(() => {
        const q = (omniQuery || '').toLowerCase().trim();
        if (!q) return [];
        const out = [];
        Object.keys(db).forEach(id => {
          const it = db[id];
          if (it.type !== 'instr') return;
          const name = it.name || '';
          const text = it.text || '';
          const hay = (name + ' ' + text).toLowerCase();
          if (hay.includes(q)) out.push({ type: 'instr', id, name });
        });
        out.sort((a,b)=>a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
        return out;
      }, [db, omniQuery]);

      const focusInlineTextarea = (rowKey) => {
        setTimeout(() => {
          const ta = document.querySelector(`[data-tarea="${rowKey}"]`);
          if (ta) {
            ta.focus();
            const len = ta.value.length;
            try { ta.setSelectionRange(len, len); } catch(_) {}
          }
        }, 0);
      };

      const handleKeyDown = useCallback((e) => {
        if (document.activeElement === omniInputRef.current) return;

        const rows = rowsRef.current;
        const sel = rows[idx]; if (!sel) return;

        const inActionForSel = actionFocus && actionFocus.rowKey === sel.key;
        if (inActionForSel) {
          const list = (sel.type === 'instr') ? ['settings','move','duplicate','delete'] : ['move','settings','duplicate','delete'];
          const ci = Math.max(0, list.indexOf(actionFocus.action));

          if (e.key === 'ArrowUp') { e.preventDefault(); if (actionFocus.action === 'move') moveItemInReorderMode('up'); return; }
          if (e.key === 'ArrowDown') { e.preventDefault(); if (actionFocus.action === 'move') moveItemInReorderMode('down'); return; }
          if ((e.key === 'ArrowLeft' || e.key === 'ArrowRight') && actionFocus.action === 'move') { e.preventDefault(); cancelReorder(); setActionFocus(null); return; }

          if (e.key === 'ArrowRight') { e.preventDefault();
            if (actionFocus.action === 'settings' && sel.type === 'instr' && instrUi.isFor(sel.key) && instrUi.stage() === 1) { instrUi.toStage2(); return; }
            const next = list[(ci + 1) % list.length];
            if (next === 'move' && actionFocus.action !== 'move') startMove(sel);
            setActionFocus({ rowKey: sel.key, action: next });
            return;
          }

          if (e.key === 'ArrowLeft') { e.preventDefault();
            if (actionFocus.action === 'settings' && sel.type === 'instr') { instrUi.backToStage1(); setActionFocus(null); return; }
            if (ci === 0) { setActionFocus(null); return; }
            const prev = list[ci - 1];
            setActionFocus({ rowKey: sel.key, action: prev });
            return;
          }

          if (e.key === 'Enter') { e.preventDefault(); return; }
          if (e.key === 'Escape') { e.preventDefault(); if (actionFocus.action === 'move' && reorderState) cancelReorder(); setActionFocus(null); return; }
        }

        if (e.key === 'ArrowRight' && sel.type === 'instr') {
          e.preventDefault();
          if (!instrUi.isFor(sel.key)) {
            instrUi.openStage1(sel.key);
            focusInlineTextarea(sel.key);
            return;
          }
          if (instrUi.stage() === 1) {
            setActionFocus({ rowKey: sel.key, action: 'settings' });
            instrUi.toStage2();
            return;
          }
        }

        if (e.key === 'ArrowDown' && sel.type === 'instr' && instrUi.isFor(sel.key)) {
          e.preventDefault();
          focusInlineTextarea(sel.key);
          return;
        }

        if (e.key === 'ArrowLeft' && sel.type === 'instr') {
          e.preventDefault();
          if (instrUi.isFor(sel.key)) {
            if (instrUi.stage() === 2) { instrUi.backToStage1(); setActionFocus(null); return; }
            if (instrUi.stage() === 1) { instrUi.closeAll(); setActionFocus(null); return; }
          } else {
            const modId = path[path.length - 1];
            const headerIdx = rowsRef.current.findIndex(r => r.type === 'module' && r.moduleId === modId);
            if (headerIdx >= 0) setIdx(headerIdx);
            return;
          }
        }

        if (e.key === 'ArrowRight' && sel.type === 'module-item') {
          e.preventDefault();
          setNavHistory(h => ({ ...h, [path[0]]: idx }));
          setPath([...path, sel.moduleId]);
          setIdx(1); // land directly on module header
          return;
        }
        if (e.key === 'ArrowLeft' && sel.type === 'module') {
          e.preventDefault();
          const agentId = path[0];
          const lastModId = path[path.length - 1];
          const saved = navHistory[agentId];
          setPath([agentId]);
          const r = rowsRef.current;
          let i = r.findIndex(x => x.type==='module-item' && x.moduleId===lastModId);
          if (i < 0 && Number.isFinite(saved)) i = saved;
          if (i >= 0) setIdx(i);
          return;
        }

        const lastIndex = rows.length - 1;
        const gotoIndex = (n) => { setActionFocus(null); setIdx(n); };

        if (e.key === 'ArrowUp') { e.preventDefault(); gotoIndex(Math.max(0, idx - 1)); return; }

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (idx < lastIndex) {
            gotoIndex(Math.min(lastIndex, idx + 1));
          } else {
            lastIdxBeforeOmniRef.current = idx;
            lastKeyBeforeOmniRef.current = sel.key;
            setOmniActive(true);
            setTimeout(()=>{ if (omniInputRef.current) omniInputRef.current.focus(); }, 0);
          }
          return;
        }

        if (e.key === 'Escape') {
          e.preventDefault();
          if (actionFocus && actionFocus.action === 'move' && reorderState) { cancelReorder(); setActionFocus(null); return; }
          if (actionFocus) { setActionFocus(null); return; }
          if (instrUi.isFor(sel.key)) { instrUi.closeAll(); return; }
          if (path.length > 1) {
            const newPath = path.slice(0, -1);
            const savedIdx = navHistory[newPath[0]];
            setPath(newPath);
            setIdx(Number.isFinite(savedIdx) ? savedIdx : 0);
            return;
          }
        }
      }, [
        idx, path,
        actionFocus, instrUi,
        startMove, moveItemInReorderMode, cancelReorder,
        reorderState, navHistory
      ]);

      useEffect(() => { window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [handleKeyDown]);

      useEffect(() => {
        const hash = '#' + path.join('/'); if (window.location.hash !== hash) window.history.pushState(null, '', hash);
      }, [path]);

      useEffect(() => {
        const handlePopState = () => {
          const hash = window.location.hash.slice(1);
          if (hash) {
            const parts = hash.split('/').filter(Boolean);
            if (parts.length > 0) setPath(parts);
          } else setPath(['expert-maker']);
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      // Omni results computed once above; selection suppression when omni is hovered/focused
      const suppressSel = omniFocus || omniHover;

      return (
        <div className="layout">
          <div className="left-column">
            <div className="panel">
              <div className="sc-title"><strong><em>(: Smile Composer)</em></strong></div>
              {rows.map((row, i) => {
                const isSelected = (i === idx) && !suppressSel;
                const inActionMode = actionFocus && actionFocus.rowKey === row.key;
                const showInline = row.type === 'instr' && instrUi.isFor(row.key) && (i === idx);
                const actions = getActionList(row);
                const focused = inActionMode ? actionFocus.action : null;

                return (
                  <React.Fragment key={row.key}>
                    <div
                      className={['line', isSelected ? 'sel' : ''].join(' ').trim()}
                      style={{ paddingLeft: (row.depth || 0) * TAB }}
                      data-key={row.key}
                      onClick={() => setIdx(i)}
                      onMouseEnter={() => setIdx(i)}
                    >
                      {(row.type === 'instr') && (
                        <span
                          className="hover-settings"
                          onClick={(e) => {
                            e.stopPropagation();
                            setIdx(i);
                            if (!instrUi.isFor(row.key)) { instrUi.openStage1(row.key); focusInlineTextarea(row.key); }
                            else { setActionFocus({ rowKey: row.key, action: 'settings' }); instrUi.toStage2(); }
                          }}
                          title="Open Settings"
                        >→ Settings</span>
                      )}

                      <span className="left-span">
                        {row.isOutput ? <strong>OUTPUT: </strong> : null}{row.label}
                      </span>
                    </div>

                    {row.type === 'instr' && !showInline && isSelected && (
                      <InstructionPreviewLine store={store} row={row} />
                    )}

                    {showInline && row.type === 'instr' && (
                      <>
                        <InstructionInlineEditor
                          store={store}
                          row={row}
                          onTextChange={updateData}
                          getNameOverride={(k, f) => store.get(k, f || '')}
                          setNameOverride={(k, v) => updateData(k, v)}
                          getMeta={(k) => store.get(k, '')}
                          setMeta={(k, v) => updateData(k, v)}
                          getStruct={(k) => store.get(k, 'heavy')}
                          setStruct={(k, v) => updateData(k, v)}
                          stage={instrUi.stage()}
                        />
                        <ActionBar
                          actions={actions}
                          focus={focused || null}
                          onFocus={(a) => {
                            if (focused !== 'move' && a === 'move') startMove(row);
                            setActionFocus({ rowKey: row.key, action: a });
                            if (a === 'settings' && instrUi.stage() === 1) { instrUi.toStage2(); }
                          }}
                          onExecute={(a) => {
                            if (a === 'duplicate') duplicateInstruction(row.dbId, row.pos + 1);
                            if (a === 'delete') removeInstructionAtPos(row.pos);
                            if (a === 'move') startMove(row);
                          }}
                          onBack={() => { setActionFocus(null); }}
                          pad={((row.depth || 0) + 1) * TAB}
                        />
                      </>
                    )}

                    {i === idx && row.type === 'module-item' && (
                      <ModulePreview store={store} moduleId={row.moduleId} depth={row.depth} />
                    )}
                  </React.Fragment>
                );
              })}
            </div>

            <div
              className="add-bar"
              onMouseEnter={() => setOmniHover(true)}
              onMouseLeave={() => setOmniHover(false)}
            >
              <div className="dock">
                <input
                  ref={omniInputRef}
                  className="omni-input"
                  placeholder="Type to search instructions… Enter adds first match, Esc clears, ↑ to return to list"
                  value={omniQuery}
                  onFocus={() => {
                    setOmniActive(true);
                    setOmniFocus(true);
                    if (lastIdxBeforeOmniRef.current === null) {
                      lastIdxBeforeOmniRef.current = idx;
                      const r = rowsRef.current[idx];
                      lastKeyBeforeOmniRef.current = r ? r.key : null;
                    }
                  }}
                  onBlur={() => { setOmniFocus(false); }}
                  onChange={e => { setOmniQuery(e.target.value); }}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      const q = omniQuery.trim();
                      if (!q) return;
                      const top = omniResults[0];
                      if (top) {
                        const targetModuleId = (path.length >= 2) ? path[path.length - 1] : ensureModuleForAgent();
                        addInstructionToModule(targetModuleId, top.id, null);
                        setOmniQuery('');
                        setTimeout(()=>{ if (omniInputRef.current) omniInputRef.current.focus(); }, 0);
                      }
                      return;
                    }
                    if (e.key === 'Escape') {
                      setOmniActive(false);
                      setOmniQuery('');
                      return;
                    }
                    if (e.key === 'ArrowUp') {
                      const el = omniInputRef.current;
                      const caretAtStart = el && el.selectionStart === 0 && el.selectionEnd === 0;
                      if (caretAtStart) {
                        e.preventDefault();
                        const key = lastKeyBeforeOmniRef.current;
                        const idxByKey = key ? rowsRef.current.findIndex(r => r.key === key) : -1;
                        let restoreIdx = -1;
                        if (idxByKey >= 0) restoreIdx = idxByKey;
                        else if (Number.isFinite(lastIdxBeforeOmniRef.current)) restoreIdx = lastIdxBeforeOmniRef.current;
                        else restoreIdx = Math.max(0, rowsRef.current.length - 1);
                        el.blur();
                        setIdx(Math.max(0, restoreIdx));
                        lastIdxBeforeOmniRef.current = null;
                        lastKeyBeforeOmniRef.current = null;
                      }
                    }
                  }}
                />
                {(omniActive && omniQuery.trim()) ? (
                  <div className="omni-list">
                    {omniResults.length === 0 && (<div className="omni-item"><span>No matches</span></div>)}
                    {omniResults.map((r, i) => (
                      <div
                        key={r.id + ':' + i}
                        className="omni-item"
                        onClick={() => {
                          const targetModuleId = (path.length >= 2) ? path[path.length - 1] : ensureModuleForAgent();
                          addInstructionToModule(targetModuleId, r.id, null);
                          setOmniQuery('');
                          setTimeout(()=>{ if (omniInputRef.current) omniInputRef.current.focus(); }, 0);
                        }}
                      >
                        <span>{r.name}</span>
                        <span className="badge">instruction</span>
                      </div>
                    ))}
                  </div>
                ) : null}
              </div>
            </div>
          </div>

          <RightSidebar
            value={rightbarValue}
            onChange={(e) => { updateData('rightbar-prompt', e.target.value); updateData('rightbar-prompt-manual', true); }}
          />
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div class="error">Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
