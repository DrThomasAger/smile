<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>(: Smile Composer ‚Äî Enter to edit, Right to drill, Left to return, Drag to reorder)</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { 
      --indent-gap: 4px;
      --rail-width: 4px;
      --rail-color: rgba(0,0,0,0.10);
      --hover-row: #f6f6f6;
      --select-row: #ededed;
      --indent-fill: rgba(0,0,0,0.05);
      --indent-fill-strong: rgba(0,0,0,0.08);
      --text-size: 13px;
      --pad-x: 10px;
      --row-min-h: 34px;
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif;
      background: #fff;
      color: #111;
      padding: 24px;
      margin: 0;
      line-height: 1.5;
      font-size: var(--text-size);
    }
    .container { max-width: 900px; margin: 0 auto; }
    .panel { background: #fff; padding: 16px; border-radius: 10px; }

    .list-container { display: flex; flex-direction: column; gap: 0; }

    .line {
      position: relative;
      user-select: none;
      padding: 8px var(--pad-x);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      cursor: pointer;
      touch-action: none;
      min-height: var(--row-min-h);
      background: transparent;
      transition: background-color 0.12s ease;
    }
    .line:hover { background: var(--hover-row); }
    .line.selected { background: var(--select-row); }

    /* Text must be bolded when selected (hover and keyboard share the same style) */
    .line.selected .line-label,
    .line:hover .line-label { font-weight: 700; }

    .indent-fills {
      pointer-events: none;
      position: absolute;
      left: var(--pad-x);
      top: 0;
      bottom: 0;
      display: flex;
      align-items: stretch;
      gap: var(--indent-gap);
      width: calc(var(--indent-count, 0) * (var(--rail-width) + var(--indent-gap)));
    }
    .indent-fill-box {
      width: var(--rail-width);
      border-radius: 8px;
      background: transparent;
      align-self: stretch;
      transition: background-color 0.12s ease;
    }
    .line:hover .indent-fill-box { background: var(--indent-fill); }
    .line.selected .indent-fill-box { background: var(--indent-fill-strong); }

    .line-inner { display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0; position: relative; z-index: 1; }
    .indent-guides { display: flex; align-items: stretch; gap: var(--indent-gap); margin-right: 8px; }
    .indent-bar { width: var(--rail-width); border-radius: 8px; background: var(--rail-color); align-self: stretch; }
    /* Agent highlight amplifies bars across structure */
    .agent-highlight .indent-bar { background: rgba(0,0,0,0.35); }
    .agent-highlight .indent-fill-box { background: var(--indent-fill-strong); }

    .line-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .line-indicator { font-size: 14px; color: #666; flex-shrink: 0; display: inline-flex; align-items: center; gap: 10px; }

    /* Right arrow only for compositions, visible on hover or keyboard-selection */
    .arrow { opacity: 0; transition: opacity 0.12s ease; }
    .line.composition:hover .arrow, .line.composition.selected .arrow { opacity: 1; }
    .line.menu .arrow, .line.prompt .arrow, .line.module .arrow, .line.search .arrow { display: none; }

    /* Burger visible on hover and when keyboard-selected; not on compositions/search */
    .burger {
      display: inline-flex;
      flex-direction: column;
      justify-content: center;
      gap: 2px;
      width: 12px;
      height: 10px;
      opacity: 0;
      transition: opacity 0.12s ease;
    }
    .burger div { width: 12px; height: 1px; background: #666; border-radius: 1px; }
    .line.menu:hover .burger,
    .line.prompt:hover .burger,
    .line.module:hover .burger,
    .line.selected .burger { opacity: 1; }
    .line.composition .burger, .line.search .burger { display: none; }

    .left-arrow { opacity: 1; cursor: pointer; user-select: none; }

    /* Previews */
    .preview-line {
      position: relative;
      padding: 2px var(--pad-x);
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 24px;
      user-select: none;
      cursor: pointer;
    }
    .preview-line:hover { background: var(--hover-row); }
    .preview-inner { display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0; position: relative; z-index: 1; }
    .preview-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: #666; font-size: 12px; }
    .preview-fills {
      pointer-events: none;
      position: absolute;
      left: var(--pad-x);
      top: 0;
      bottom: 0;
      display: flex;
      align-items: stretch;
      gap: var(--indent-gap);
      width: calc(var(--indent-count, 0) * (var(--rail-width) + var(--indent-gap)));
    }
    .preview-fill-box { width: var(--rail-width); border-radius: 8px; background: var(--indent-fill); align-self: stretch; }

    /* Editor */
    .editor-container { margin-top: 6px; margin-bottom: 6px; padding: 0; border-radius: 8px; background: transparent; }
    .editor-textarea {
      width: 100%;
      min-height: 120px;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: var(--text-size);
      line-height: 1.6;
      resize: vertical;
      background: transparent;
    }
    .editor-textarea:focus { outline: 2px solid #0066ff; outline-offset: 1px; }

    .settings-container { display: flex; flex-direction: column; gap: 12px; padding: 0; background: transparent; border-radius: 6px; font-size: var(--text-size); }
    .settings-field { display: flex; flex-direction: column; gap: 6px; }
    .settings-label { font-size: var(--text-size); font-weight: 500; color: #444; }
    .settings-input, .settings-textarea {
      padding: 8px 10px; border: none; border-radius: 4px; font: inherit; background: transparent; height: var(--row-min-h); display: flex; align-items: center; color: #111;
    }
    .settings-textarea { min-height: 80px; height: auto; resize: vertical; }
    .settings-slider-container { display: flex; align-items: center; gap: 12px; }
    .settings-slider { flex: 1; }
    .settings-slider-label { font-size: 12px; color: #666; min-width: 80px; }

    .editor-buttons { display: flex; gap: 12px; margin-top: 8px; flex-wrap: wrap; font-size: var(--text-size); }
    .editor-btn { padding: 6px 10px; border: none; border-radius: 6px; background: transparent; cursor: pointer; font-size: var(--text-size); display: inline-flex; align-items: center; gap: 6px; height: var(--row-min-h); }
    .editor-btn:hover { background: var(--hover-row); }
    .kbd-hints { color: #999; font-size: 12px; margin-top: 6px; }

    .search-row { cursor: text; }
    .search-input { border: none; outline: none; background: transparent; font: inherit; width: 100%; padding: 6px 2px; color: #111; text-decoration: none; }
    .search-input::placeholder { color: #111; }
    .search-input.active::placeholder { color: #666; }

    .omni-list { display: flex; flex-direction: column; gap: 2px; margin-top: 4px; }
    .omni-item { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 6px 10px; background: transparent; border-radius: 8px; cursor: pointer; font-size: var(--text-size); }
    .omni-item:hover { background: var(--hover-row); }
    .omni-item.selected { background: var(--select-row); }
    .omni-item.create-new { color: #666; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 12px; background: #e0e0e0; color: #555; }

    .toast { position: fixed; bottom: 24px; right: 24px; padding: 12px 20px; background: #333; color: #fff; border-radius: 8px; font-size: 14px; animation: slideIn 0.3s ease; z-index: 2000; }
    @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

    /* Drag and drop */
    .dragging { opacity: 0.4; }
    .drag-preview { position: fixed; pointer-events: none; z-index: 1000; padding: 8px 12px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
    .drop-placeholder { height: var(--row-min-h); background: #e0e0e0; opacity: 0.5; border-radius: 6px; margin: 2px 0; }

    /* Response Format section - only shows when there are items */
    .response-format-section { margin-top: 12px; }
    .response-format-header { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
    .response-format-title { font-size: 13px; color: #666; }
    .response-format-add-btn { padding: 4px 8px; background: transparent; border: 1px solid #ccc; border-radius: 4px; cursor: pointer; font-size: 12px; }
    .response-format-add-btn:hover { background: var(--hover-row); }
    .response-format-items { display: flex; flex-direction: column; gap: 4px; padding: 8px; background: #f9f9f9; border-radius: 6px; border: 1px dashed #ddd; }
    .response-format-item { padding: 6px 10px; background: #fff; border-radius: 4px; font-size: 12px; display: flex; justify-content: space-between; align-items: center; }
    .response-format-remove { background: none; border: none; cursor: pointer; color: #999; font-size: 16px; padding: 0 4px; }
    .response-format-remove:hover { color: #333; }

  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div>Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useMemo } = React;

    const INITIAL_DB = {
      'expert-maker': { 
        name: 'Expert Maker',
        type: 'prompt',
        emojis: 'üéØüß†',
        compositions: ['smile-menu', 'meta-info', 'jargon-cot', 'identify-mistakes']
      },
      'smile-menu': {
        name: '(: Smile Prompt Editor',
        type: 'menu',
        emojis: '',
        items: []
      },
      'meta-info': {
        name: 'Meta-Information MegaBrick',
        type: 'composition',
        emojis: 'üìäüîó',
        items: ['smile-info', 'llm-info', 'user-info']
      },
      'jargon-cot': {
        name: 'Thinking In Jargon',
        type: 'composition',
        emojis: 'üß™üí≠',
        items: ['emoji-section', 'bold-words', 'top-bottom']
      },
      'identify-mistakes': {
        name: 'Output Answer',
        type: 'composition',
        emojis: 'üîç‚úèÔ∏è',
        items: ['emoji-section', 'bold-words']
      },
      'smile-info': {
        name: 'Information About (: Smile',
        type: 'module',
        emojis: 'üòäüìò',
        text: 'Explain Smile syntax: (: flexible, [: rigid, [= literal.'
      },
      'llm-info': { name: 'Information About LLMs', type: 'module', emojis: 'ü§ñüìö', text: 'Meta-knowledge about how LLMs process instructions.' },
      'user-info': { name: 'Information About User', type: 'module', emojis: 'üë§üí°', text: 'Contextualize user needs and goals.' },
      'emoji-section': { name: 'Emoji section name', type: 'module', emojis: 'üòÄüè∑Ô∏è', text: 'Use two emoticons for section names.' },
      'bold-words': { name: 'Bold for important words', type: 'module', emojis: 'üí™üìù', text: 'Use **bold** for attention retention over long contexts.' },
      'top-bottom': { name: 'Maximize adherence through top+bottom replication', type: 'module', emojis: '‚¨ÜÔ∏è‚¨áÔ∏è', text: 'Replicate critical instructions at beginning and end.' },
      'negative-rewrite': { name: 'Identify negatives and rewrite to positive', type: 'module', emojis: '‚ùå‚úÖ', text: 'Find negatives like "not" and rewrite as positive articulations.' }
    };

    const getMockPrompt = (type, id, db) => {
      const item = db[id];
      if (!item) return '';
      if (type === 'menu') {
        return `(: Menu Prompt Editor - ${item.name} (

  [= Description [
    Configure the primary prompt scaffolding and top-level semantics.
  ] End description =]

) End menu :)`;
      }
      if (type === 'prompt') {
        return `(: Prompt - ${item.name} (

  [: Task Definition [
    Create intelligent responses using modular components
  ] End task :]

  [: Response Format [
    ***(: ${item.name}***:
    
    {Your expert response here}
  ] End format :]

) End prompt :)`;
      }
      if (type === 'composition') {
        return `(: Composition - ${item.name} (

  [= Documents [
    ${(item.items || []).map(i => `- ${db[i]?.name || i}`).join('\n    ')}
  ] End documents =]

) End composition :)`;
      }
      if (type === 'module') {
        return `[: Module - ${item.name} [
  ${item.text || ''}
] End document :]`;
      }
      return '';
    };

    function App() {
      const [db, setDb] = useState(INITIAL_DB);
      const [promptId] = useState('expert-maker');
      const [path, setPath] = useState([promptId]); // [prompt] or [prompt, compositionId]
      const [selectedIdx, setSelectedIdx] = useState(0);
      const initializedRef = useRef(false);

      const [hoveredIdx, setHoveredIdx] = useState(null); // hover ‚â° selection
      const [editorOpen, setEditorOpen] = useState(false);
      const [editorItemId, setEditorItemId] = useState(null);
      const [editorItemType, setEditorItemType] = useState(null);
      const [editorMode, setEditorMode] = useState('text');
      const [editorText, setEditorText] = useState('');
      const [settingsName, setSettingsName] = useState('');
      const [settingsEmojis, setSettingsEmojis] = useState('');
      const [settingsText, setSettingsText] = useState('');
      const [settingsMeta, setSettingsMeta] = useState('');
      const [settingsStructure, setSettingsStructure] = useState(1);
      const [toast, setToast] = useState(null);

      const [addQuery, setAddQuery] = useState('');
      const [addActive, setAddActive] = useState(false);
      const [addSelectedIdx, setAddSelectedIdx] = useState(0);
      const addInputRef = useRef(null);
      const prevIdxBeforeAddRef = useRef(null);
      const cameFromPlusRef = useRef(false);

      const [lastCompositionId, setLastCompositionId] = useState(null); // remember which composition we drilled into

      // Drag and drop state
      const [draggedItem, setDraggedItem] = useState(null);
      const [dragOverIdx, setDragOverIdx] = useState(null);
      const [dragPreview, setDragPreview] = useState(null);

      // Response Format state
      const [responseFormatItems, setResponseFormatItems] = useState([]);

      const isPromptView = path.length === 1;
      const isCompositionView = path.length === 2;
      const currentCompositionId = isCompositionView ? path[1] : null;

      const showToast = (msg) => { setToast(msg); setTimeout(() => setToast(null), 1600); };

      const currentItems = useMemo(() => {
        const items = [];
        items.push({ id: 'smile-menu', ...db['smile-menu'], _depth: 0, _class: 'menu' });
        items.push({ id: promptId, ...db[promptId], _depth: 1, _class: 'prompt' });
        if (isCompositionView) {
          const ch = db[currentCompositionId];
          if (ch) {
            items.push({ id: currentCompositionId, ...ch, _depth: 2, _class: 'composition' });
            (ch.items || []).forEach(moduleId => {
              const d = db[moduleId];
              if (d) items.push({ id: moduleId, ...d, _depth: 3, _class: 'module' });
            });
          }
        } else {
          const prompt = db[promptId];
          (prompt.compositions || []).forEach(mid => {
            const m = db[mid];
            if (m && m.type === 'composition') {
              items.push({ id: mid, ...m, _depth: 2, _class: 'composition' });
            }
          });
        }
        return items;
      }, [db, promptId, isCompositionView, currentCompositionId]);

      // First-load: select the first composition by default
      useEffect(() => {
        if (initializedRef.current) return;
        const idx = currentItems.findIndex(i => i.type === 'composition');
        if (idx !== -1) {
          setSelectedIdx(idx);
        } else {
          setSelectedIdx(0);
        }
        initializedRef.current = true;
      }, [currentItems]);

      const addSuggestions = useMemo(() => {
        const q = addQuery.toLowerCase();
        const allItems = Object.entries(db)
          .map(([id, it]) => ({ id, ...it }))
          .filter(x => x.type === 'composition' || x.type === 'module');
        
        if (!addQuery.trim()) {
          // Show all items, most frequently used first (for now, just show all)
          return allItems;
        }
        
        return allItems.filter(x => x.name.toLowerCase().includes(q));
      }, [db, addQuery]);

      const openEditor = (itemId, itemType) => {
        const promptText = getMockPrompt(itemType, itemId, db);
        setEditorItemId(itemId);
        setEditorItemType(itemType);
        setEditorText(promptText);
        setEditorMode('text');
        setEditorOpen(true);
        const it = db[itemId];
        setSettingsName(it?.name || '');
        setSettingsEmojis(it?.emojis || '');
        setSettingsText(it?.text || '');
        setSettingsMeta('');
        setSettingsStructure(1);
      };
      const openEditorAndFocusSettings = (itemId, itemType) => {
        openEditor(itemId, itemType);
        setTimeout(() => setEditorMode('settings'), 0);
      };
      const closeEditor = () => {
        setEditorOpen(false);
        setEditorItemId(null);
        setEditorItemType(null);
        setEditorText('');
        setEditorMode('text');
      };
      const saveEditor = () => { showToast('Saved'); closeEditor(); };

      const getPromptViewCompositionIndex = (compositionId) => {
        const prompt = db[promptId];
        const compositionIds = (prompt.compositions || []).filter(id => db[id]?.type === 'composition');
        const idxInCompositions = compositionIds.indexOf(compositionId);
        if (idxInCompositions === -1) return currentItems.findIndex(i => i.type === 'composition');
        // 0: menu, 1: prompt, then compositions...
        return 2 + idxInCompositions;
      };

      useEffect(() => {
        const onKey = (e) => {
          // Fast path: global '+' or '/' to open Add unless a text window (textarea) is focused
          if (e.key === '+' || e.key === '/') {
            const active = document.activeElement;
            const isTextWindow = active && active.tagName === 'TEXTAREA';
            if (!(editorOpen && editorMode === 'text') && !isTextWindow) {
              e.preventDefault();
              if (addInputRef.current) {
                cameFromPlusRef.current = true;
                prevIdxBeforeAddRef.current = selectedIdx;
                addInputRef.current.focus();
                setAddActive(true);
                setSelectedIdx(-1);
              }
              return;
            }
          }

          // If editor text is open, only handle its dedicated keys
          if (editorOpen && editorMode === 'text') {
            if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); saveEditor(); return; }
            if (e.key === 'Escape') { e.preventDefault(); closeEditor(); return; }
            if (e.key === 'ArrowRight') { e.preventDefault(); setEditorMode('settings'); return; }
            return;
          }

          // Let normal typing in inputs proceed, except we still allowed '+' and '/' above
          const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
          const isAddInput = e.target === addInputRef.current;
          if (isInput && !isAddInput) return;

          // Escape functions as left arrow when not in textbox
          if (e.key === 'Escape' && !isInput) {
            e.preventDefault();
            if (isCompositionView) {
              const backIdx = getPromptViewCompositionIndex(currentCompositionId || lastCompositionId);
              setPath([promptId]);
              setSelectedIdx(backIdx);
            }
            return;
          }

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (selectedIdx < currentItems.length - 1) {
              setSelectedIdx(prev => prev + 1);
            } else if (addInputRef.current) {
              // end-of-list jumps into Add
              cameFromPlusRef.current = false; // entered add via list end, not '+'
              addInputRef.current.focus();
              setAddActive(true);
              setSelectedIdx(-1);
            }
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (selectedIdx > 0) {
              setSelectedIdx(prev => prev - 1);
            } else if (addInputRef.current) {
              cameFromPlusRef.current = false;
              addInputRef.current.focus();
              setAddActive(true);
              setSelectedIdx(-1);
            }
          } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            if (isCompositionView) {
              const backIdx = getPromptViewCompositionIndex(currentCompositionId || lastCompositionId);
              setPath([promptId]);
              setSelectedIdx(backIdx);
            }
          } else if (e.key === 'ArrowRight') {
            e.preventDefault();
            const item = currentItems[selectedIdx];
            if (!item) return;
            if (item.type === 'composition') {
              setLastCompositionId(item.id);
              setPath([promptId, item.id]);
              return;
            }
            if (item.type === 'prompt' && !isCompositionView) {
              openEditorAndFocusSettings(item.id, 'prompt');
              return;
            }
            if (item.type === 'menu' || item.type === 'module' || (item.type === 'prompt' && isCompositionView)) {
              openEditor(item.id, item.type);
              return;
            }
          } else if (e.key === 'Enter') {
            e.preventDefault();
            const item = currentItems[selectedIdx];
            if (!item) return;
            if (item.type === 'composition') {
              openEditor(item.id, 'composition');
            } else if (item.type === 'prompt' && !isCompositionView) {
              openEditorAndFocusSettings(item.id, 'prompt');
            } else {
              openEditor(item.id, item.type);
            }
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [editorOpen, editorMode, selectedIdx, currentItems, isCompositionView, promptId, db, lastCompositionId, currentCompositionId]);

      const IndentGuides = ({ depth }) => {
        const bars = [];
        for (let i = 0; i < depth; i++) bars.push(<div key={i} className="indent-bar"></div>);
        return <div className="indent-guides">{bars}</div>;
      };
      const IndentFills = ({ depth, className }) => {
        const boxes = [];
        for (let i = 0; i < depth; i++) boxes.push(<div key={i} className={className}></div>);
        return <div className={className === 'indent-fill-box' ? 'indent-fills' : 'preview-fills'}>
          {boxes}
        </div>;
      };

      const isSearching = addActive;
      const agentHighlightActive = (!editorOpen && !addActive) && (selectedIdx === 1 || hoveredIdx === 1);
      const panelClass = `panel ${isSearching ? 'searching' : ''} ${agentHighlightActive ? 'agent-highlight' : ''}`;
      const searchDepth = isCompositionView ? 3 : 2;

      return (
        <div className="container">
          <div className={panelClass}>
            <div className="list-container">
              {currentItems.map((item, idx) => {
                const depth = item._depth ?? 0;

                const isActive = (!editorOpen && !addActive) && (selectedIdx === idx || hoveredIdx === idx);
                const rowClass = `line ${item._class || ''}${isActive ? ' selected' : ''}`;

                const getModulePreview = (text) => {
                  const lines = String(text || '').split('\n').slice(0, 3).map(s => s.trim()).filter(Boolean);
                  return lines.join(' ');
                };

                const goBackToPromptAtComposition = () => {
                  const backIdx = getPromptViewCompositionIndex(currentCompositionId || lastCompositionId);
                  setPath([promptId]);
                  setSelectedIdx(backIdx);
                };

                // Burger visibility: hide on prompt row while in composition view (spec wants left-arrow there)
                const showBurger = (
                  item.type === 'menu' ||
                  item.type === 'module' ||
                  (item.type === 'prompt' && !isCompositionView)
                );

                return (
                  <React.Fragment key={item.id}>
                    <div
                      className={rowClass}
                      style={{ '--indent-count': depth }}
                      aria-selected={isActive}
                      onMouseEnter={() => { setHoveredIdx(idx); if (item._class !== 'prompt') setSelectedIdx(-1); }}
                      onMouseLeave={() => setHoveredIdx(null)}
                      draggable={item.type === 'composition' || item.type === 'module'}
                      onDragStart={(e) => {
                        if (item.type !== 'composition' && item.type !== 'module') {
                          e.preventDefault();
                          return;
                        }
                        setDraggedItem(item);
                        e.dataTransfer.effectAllowed = 'move';
                        e.dataTransfer.setData('text/plain', item.id);
                        // Create drag preview
                        const preview = document.createElement('div');
                        preview.textContent = `${item.emojis || ''} ${item.name}`.trim();
                        preview.style.cssText = 'padding: 8px 12px; background: #fff; border: 1px solid #ccc; border-radius: 6px; position: absolute; top: -1000px;';
                        document.body.appendChild(preview);
                        e.dataTransfer.setDragImage(preview, 0, 0);
                        setTimeout(() => document.body.removeChild(preview), 0);
                      }}
                      onDragEnd={() => { setDraggedItem(null); setDragOverIdx(null); }}
                      onDragOver={(e) => {
                        if (!draggedItem) return;
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        setDragOverIdx(idx);
                      }}
                      onDragLeave={() => setDragOverIdx(null)}
                      onDrop={(e) => {
                        e.preventDefault();
                        if (!draggedItem || draggedItem.id === item.id) {
                          setDraggedItem(null);
                          setDragOverIdx(null);
                          return;
                        }
                        // Handle reordering logic
                        if (isCompositionView && draggedItem.type === 'module' && item.type === 'module') {
                          const comp = db[currentCompositionId];
                          const items = [...(comp?.items || [])];
                          const fromIdx = items.indexOf(draggedItem.id);
                          const toIdx = items.indexOf(item.id);
                          if (fromIdx !== -1 && toIdx !== -1) {
                            items.splice(fromIdx, 1);
                            items.splice(toIdx, 0, draggedItem.id);
                            setDb(prev => ({ ...prev, [currentCompositionId]: { ...prev[currentCompositionId], items } }));
                          }
                        } else if (!isCompositionView && draggedItem.type === 'composition' && item.type === 'composition') {
                          const prompt = db[promptId];
                          const comps = [...(prompt?.compositions || [])];
                          const fromIdx = comps.indexOf(draggedItem.id);
                          const toIdx = comps.indexOf(item.id);
                          if (fromIdx !== -1 && toIdx !== -1) {
                            comps.splice(fromIdx, 1);
                            comps.splice(toIdx, 0, draggedItem.id);
                            setDb(prev => ({ ...prev, [promptId]: { ...prev[promptId], compositions: comps } }));
                          }
                        }
                        setDraggedItem(null);
                        setDragOverIdx(null);
                      }}
                      onClick={(e) => {
                        const role = e.target?.getAttribute?.('data-role');
                        if (role === 'burger' || role === 'left-arrow') return;

                        // Clicking prompt in composition view returns to prompt view
                        if (item.type === 'prompt' && isCompositionView) {
                          const backIdx = getPromptViewCompositionIndex(currentCompositionId || lastCompositionId);
                          setPath([promptId]);
                          setSelectedIdx(backIdx);
                          return;
                        }

                        // Clicking composition drills in (acts as right arrow)
                        if (item.type === 'composition' && !editorOpen) {
                          setLastCompositionId(item.id);
                          setPath([promptId, item.id]);
                        } else {
                          setSelectedIdx(idx);
                        }
                      }}
                    >
                      <IndentFills depth={depth} className="indent-fill-box" />
                      <div className="line-inner">
                        <IndentGuides depth={depth} />
                        <span className="line-label">
                          {item.type === 'menu'
                            ? (<><em><strong>(: Smile</strong></em> {" "}Prompt Editor</>)
                            : (<>{item.emojis ? `${item.emojis} ` : ''}{item.name}</>)
                          }
                        </span>
                      </div>
                      <div className="line-indicator">
                        {isCompositionView && item.type === 'prompt' && isActive && (
                          <span
                            className="left-arrow"
                            title="Return to prompt view"
                            data-role="left-arrow"
                            onClick={(e) => { e.stopPropagation(); goBackToPromptAtComposition(); }}
                          >‚Üê</span>
                        )}
                        <span className="arrow">‚Üí</span>
                        {showBurger && (
                          <span
                            className="burger"
                            title={item.type === 'prompt' && !isCompositionView ? 'Open settings' : 'Open editor'}
                            data-role="burger"
                            onClick={(e) => {
                              e.stopPropagation();
                              if (item.type === 'prompt' && !isCompositionView) {
                                openEditorAndFocusSettings(item.id, 'prompt');
                              } else {
                                openEditor(item.id, item.type);
                              }
                            }}
                          ><div></div><div></div><div></div></span>
                        )}
                      </div>
                    </div>

                    {isPromptView && isActive && item.type === 'composition' && item.items && (
                      <div className="module-contents">
                        {(item.items || []).map(moduleId => {
                          const d = db[moduleId];
                          if (!d) return null;
                          const previewDepth = depth + 1;
                          return (
                            <div 
                              key={moduleId} 
                              className="preview-line" 
                              style={{ '--indent-count': previewDepth }}
                              onClick={() => {
                                // Preview is clickable - navigate to composition and select this module
                                setLastCompositionId(item.id);
                                setPath([promptId, item.id]);
                                // Find index of this module in the composition view
                                setTimeout(() => {
                                  const moduleIdx = currentItems.findIndex(it => it.id === moduleId);
                                  if (moduleIdx !== -1) setSelectedIdx(moduleIdx);
                                }, 0);
                              }}
                              draggable={true}
                              onDragStart={(e) => {
                                setDraggedItem({ ...d, id: moduleId });
                                e.dataTransfer.effectAllowed = 'move';
                                e.dataTransfer.setData('text/plain', moduleId);
                              }}
                            >
                              <div className="preview-fills">
                                {Array.from({length: previewDepth}).map((_,i)=><div key={i} className="preview-fill-box"></div>)}
                              </div>
                              <div className="preview-inner">
                                <IndentGuides depth={previewDepth} />
                                <span className="preview-label">{d.emojis} {d.name}</span>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    )}

                    {isActive && item.type === 'module' && (
                      <div className="preview-line" style={{ '--indent-count': (depth + 1) }}>
                        <div className="preview-fills">
                          {Array.from({length: depth + 1}).map((_,i)=><div key={i} className="preview-fill-box"></div>)}
                        </div>
                        <div className="preview-inner">
                          <IndentGuides depth={depth + 1} />
                          <span className="preview-label">{getModulePreview(item.text)}</span>
                        </div>
                      </div>
                    )}

                    {editorOpen && editorItemId === item.id && (
                      <div className="editor-container">
                        {editorMode === 'text' ? (
                          <textarea
                            className="editor-textarea"
                            value={editorText}
                            onChange={(e) => setEditorText(e.target.value)}
                            onKeyDown={(e) => {
                              if (e.key === 'Enter' && e.shiftKey) {
                                e.preventDefault();
                                saveEditor();
                              }
                            }}
                            autoFocus
                          />
                        ) : (
                          <div className="settings-container">
                            <div className="settings-field">
                              <label className="settings-label">Name</label>
                              <input className="settings-input" value={settingsName} onChange={(e) => setSettingsName(e.target.value)} />
                            </div>
                            <div className="settings-field">
                              <label className="settings-label">Emojis (2)</label>
                              <input className="settings-input" value={settingsEmojis} onChange={(e) => setSettingsEmojis(e.target.value)} maxLength={4} />
                            </div>
                            {item.type === 'module' && (
                              <div className="settings-field">
                                <label className="settings-label">Module Text</label>
                                <textarea className="settings-textarea" value={settingsText} onChange={(e) => setSettingsText(e.target.value)} />
                              </div>
                            )}
                            <div className="settings-field">
                              <label className="settings-label">Meta</label>
                              <textarea className="settings-textarea" value={settingsMeta} onChange={(e) => setSettingsMeta(e.target.value)} placeholder="Meta-aware context..." />
                            </div>
                            <div className="settings-field">
                              <label className="settings-label">Structure</label>
                              <div className="settings-slider-container">
                                <input type="range" min="0" max="2" step="1" value={settingsStructure} onChange={(e) => setSettingsStructure(parseInt(e.target.value))} className="settings-slider" />
                                <span className="settings-slider-label">{['Light (:', 'Medium [:', 'Heavy [='][settingsStructure]}</span>
                              </div>
                            </div>
                          </div>
                        )}
                        <div className="editor-buttons">
                          <button className="editor-btn" onClick={() => { showToast('Saved'); closeEditor(); }}>Save</button>
                          <button className="editor-btn" onClick={() => setEditorMode(m => m === 'text' ? 'settings' : 'text')}>Settings</button>
                          <button className="editor-btn" onClick={() => navigator.clipboard.writeText(editorText).then(() => showToast('Copied to clipboard'))}>Copy</button>
                          <button className="editor-btn" onClick={() => { showToast('Deleted'); closeEditor(); }}>Delete</button>
                          <button className="editor-btn" onClick={closeEditor}>Cancel</button>
                        </div>
                        <div className="kbd-hints">(shift+enter) save ‚Ä¢ (esc) cancel</div>
                      </div>
                    )}
                  </React.Fragment>
                );
              })}

              <div className="line search-row" style={{ '--indent-count': searchDepth }}>
                <div className="indent-fills">
                  {Array.from({length: searchDepth}).map((_,i)=><div key={i} className="indent-fill-box"></div>)}
                </div>
                <div className="line-inner" onClick={() => { if (addInputRef.current) addInputRef.current.focus(); }}>
                  <div className="indent-guides">
                    {Array.from({length: searchDepth}).map((_,i)=><div key={i} className="indent-bar"></div>)}
                  </div>
                  <input
                    ref={addInputRef}
                    className={`search-input ${addActive ? 'active' : ''}`}
                    placeholder={addActive ? "Start writing an existing name... Or create one!" : "‚ûïüßä Add New Block"}
                    value={addQuery}
                    onFocus={() => { setAddActive(true); setSelectedIdx(-1); }}
                    onBlur={() => setTimeout(() => setAddActive(false), 150)}
                    onChange={(e) => { setAddQuery(e.target.value); setAddSelectedIdx(0); }}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && e.shiftKey) {
                        // Shift+Enter creates new instruction
                        e.preventDefault();
                        const itemName = addQuery.trim() || 'New Instruction';
                        const newId = 'new-' + Date.now();
                        const newType = isCompositionView ? 'module' : 'composition';
                        const newItem = {
                          name: itemName,
                          type: newType,
                          emojis: '',
                          text: newType === 'module' ? '' : undefined,
                          items: newType === 'composition' ? [] : undefined
                        };
                        setDb(prev => ({ ...prev, [newId]: newItem }));
                        
                        // Add to appropriate location
                        if (isCompositionView) {
                          const composition = db[currentCompositionId];
                          const insertIdx = prevIdxBeforeAddRef.current !== null ? 
                            Math.max(0, prevIdxBeforeAddRef.current - 3) : // -3 accounts for menu, prompt, composition
                            (composition?.items || []).length;
                          const newItems = [...(composition?.items || [])];
                          newItems.splice(insertIdx, 0, newId);
                          setDb(prev => ({ ...prev, [currentCompositionId]: { ...prev[currentCompositionId], items: newItems } }));
                        } else {
                          const prompt = db[promptId];
                          const insertIdx = prevIdxBeforeAddRef.current !== null ? 
                            Math.max(0, prevIdxBeforeAddRef.current - 2) :
                            (prompt?.compositions || []).length;
                          const newComps = [...(prompt?.compositions || [])];
                          newComps.splice(insertIdx, 0, newId);
                          setDb(prev => ({ ...prev, [promptId]: { ...prev[promptId], compositions: newComps } }));
                        }
                        
                        setAddQuery(''); 
                        setAddActive(false);
                        if (addInputRef.current) addInputRef.current.blur();
                        
                        // Open editor for new item
                        setTimeout(() => {
                          openEditor(newId, newType);
                        }, 100);
                      } else if (e.key === 'Enter') {
                        e.preventDefault();
                        const list = addSuggestions;
                        if (list.length > 0 && addSelectedIdx < list.length) {
                          const chosen = list[addSelectedIdx];
                          const allow = (isCompositionView && chosen.type === 'module') || (!isCompositionView && chosen.type === 'composition');
                          if (!allow) return;
                          
                          // Add below where user came from
                          if (isCompositionView) {
                            const composition = db[currentCompositionId];
                            const insertIdx = prevIdxBeforeAddRef.current !== null ? 
                              Math.max(0, prevIdxBeforeAddRef.current - 2) :
                              (composition?.items || []).length;
                            const newItems = [...(composition?.items || [])];
                            newItems.splice(insertIdx, 0, chosen.id);
                            setDb(prev => ({ ...prev, [currentCompositionId]: { ...prev[currentCompositionId], items: newItems } }));
                          } else {
                            const prompt = db[promptId];
                            const insertIdx = prevIdxBeforeAddRef.current !== null ? 
                              Math.max(0, prevIdxBeforeAddRef.current - 2) :
                              (prompt?.compositions || []).length;
                            const newComps = [...(prompt?.compositions || [])];
                            newComps.splice(insertIdx, 0, chosen.id);
                            setDb(prev => ({ ...prev, [promptId]: { ...prev[promptId], compositions: newComps } }));
                          }
                          setAddQuery(''); setAddActive(false);
                          cameFromPlusRef.current = false;
                          if (addInputRef.current) addInputRef.current.blur();
                        }
                      } else if (e.key === 'Escape') {
                        e.preventDefault();
                        setAddQuery(''); setAddActive(false);
                        if (addInputRef.current) addInputRef.current.blur();
                        if (cameFromPlusRef.current && prevIdxBeforeAddRef.current !== null) {
                          setSelectedIdx(prevIdxBeforeAddRef.current);
                        }
                        cameFromPlusRef.current = false;
                      } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        setAddSelectedIdx(prev => Math.min(addSuggestions.length - 1, prev + 1));
                      } else if (e.key === 'ArrowUp') {
                        // Spec: Up arrow exits Add Instruction (regardless of suggestion index)
                        e.preventDefault();
                        setAddQuery(''); setAddActive(false);
                        if (addInputRef.current) addInputRef.current.blur();
                        if (cameFromPlusRef.current && prevIdxBeforeAddRef.current !== null) {
                          setSelectedIdx(prevIdxBeforeAddRef.current);
                        }
                        cameFromPlusRef.current = false;
                      }
                    }}
                  />
                </div>
                <div className="line-indicator">
                  <span className="arrow"></span>
                  <span className="burger"><div></div><div></div><div></div></span>
                </div>
              </div>

              {addActive && (
                <div className="omni-list">
                  {addSuggestions.map((item, idx) => {
                    const allowed = (isCompositionView && item.type === 'module') || (!isCompositionView && item.type === 'composition');
                    const isSel = idx === addSelectedIdx && addActive;
                    return (
                      <div
                        key={item.id}
                        className={`omni-item ${isSel ? 'selected' : ''}`}
                        onMouseEnter={() => setAddSelectedIdx(idx)}
                        onMouseDown={() => {
                          if (!allowed) return;
                          if (isCompositionView) {
                            const composition = db[currentCompositionId];
                            const insertIdx = prevIdxBeforeAddRef.current !== null ? 
                              Math.max(0, prevIdxBeforeAddRef.current - 3) :
                              (composition?.items || []).length;
                            const newItems = [...(composition?.items || [])];
                            newItems.splice(insertIdx, 0, item.id);
                            setDb(prev => ({ ...prev, [currentCompositionId]: { ...prev[currentCompositionId], items: newItems } }));
                          } else {
                            const prompt = db[promptId];
                            const insertIdx = prevIdxBeforeAddRef.current !== null ? 
                              Math.max(0, prevIdxBeforeAddRef.current - 2) :
                              (prompt?.compositions || []).length;
                            const newMods = [...(prompt?.compositions || []), item.id];
                            newMods.splice(insertIdx, 0, item.id);
                            setDb(prev => ({ ...prev, [promptId]: { ...prev[promptId], compositions: newMods } }));
                          }
                          setAddQuery(''); setAddActive(false);
                          cameFromPlusRef.current = false;
                          if (addInputRef.current) addInputRef.current.blur();
                        }}
                        title={allowed ? 'Add' : 'Not addable in this context'}
                      >
                        <span>{item.emojis} {item.name}</span>
                        <span className="badge">{item.type}</span>
                      </div>
                    );
                  })}
                  {/* Create New Instruction as a list item */}
                  <div
                    className={`omni-item create-new ${addSelectedIdx === addSuggestions.length ? 'selected' : ''}`}
                    onMouseEnter={() => setAddSelectedIdx(addSuggestions.length)}
                    onMouseDown={(e) => {
                      e.preventDefault();
                      const itemName = addQuery.trim() || 'New Instruction';
                      const newId = 'new-' + Date.now();
                      const newType = isCompositionView ? 'module' : 'composition';
                      const newItem = {
                        name: itemName,
                        type: newType,
                        emojis: '',
                        text: newType === 'module' ? '' : undefined,
                        items: newType === 'composition' ? [] : undefined
                      };
                      setDb(prev => ({ ...prev, [newId]: newItem }));
                      
                      if (isCompositionView) {
                        const composition = db[currentCompositionId];
                        const insertIdx = prevIdxBeforeAddRef.current !== null ? 
                          Math.max(0, prevIdxBeforeAddRef.current - 3) :
                          (composition?.items || []).length;
                        const newItems = [...(composition?.items || [])];
                        newItems.splice(insertIdx, 0, newId);
                        setDb(prev => ({ ...prev, [currentCompositionId]: { ...prev[currentCompositionId], items: newItems } }));
                      } else {
                        const prompt = db[promptId];
                        const insertIdx = prevIdxBeforeAddRef.current !== null ? 
                          Math.max(0, prevIdxBeforeAddRef.current - 2) :
                          (prompt?.compositions || []).length;
                        const newComps = [...(prompt?.compositions || [])];
                        newComps.splice(insertIdx, 0, newId);
                        setDb(prev => ({ ...prev, [promptId]: { ...prev[promptId], compositions: newComps } }));
                      }
                      
                      setAddQuery(''); 
                      setAddActive(false);
                      if (addInputRef.current) addInputRef.current.blur();
                      
                      setTimeout(() => openEditor(newId, newType), 100);
                    }}
                  >
                    <span>‚ûï Create New Instruction{addQuery.trim() ? ` "${addQuery.trim()}"` : ''}</span>
                    <span className="badge">new</span>
                  </div>
                </div>
              )}
            </div>

            {/* Response Format Section - only shows when there are items */}
            {responseFormatItems.length > 0 && (
              <div className="response-format-section">
                <div className="response-format-header">
                  <span className="response-format-title">Response Format</span>
                  <button 
                    className="response-format-add-btn"
                    onClick={() => {
                      const item = currentItems[selectedIdx];
                      if (item && (item.type === 'composition' || item.type === 'module')) {
                        setResponseFormatItems(prev => [...prev, { id: item.id, name: item.name, emojis: item.emojis, type: item.type }]);
                        showToast('Added to Response Format');
                      }
                    }}
                  >+</button>
                </div>
                <div 
                  className="response-format-items"
                  onDragOver={(e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; }}
                  onDrop={(e) => {
                    e.preventDefault();
                    if (draggedItem && (draggedItem.type === 'composition' || draggedItem.type === 'module')) {
                      setResponseFormatItems(prev => [...prev, { id: draggedItem.id, name: draggedItem.name, emojis: draggedItem.emojis, type: draggedItem.type }]);
                      showToast('Added to Response Format');
                    }
                  }}
                >
                  {responseFormatItems.map((item, idx) => (
                    <div key={idx} className="response-format-item">
                      <span>{item.emojis} {item.name}</span>
                      <button 
                        className="response-format-remove"
                        onClick={() => setResponseFormatItems(prev => prev.filter((_, i) => i !== idx))}
                        title="Remove"
                      >√ó</button>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {toast && <div className="toast">{toast}</div>}
          </div>
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div>Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>

