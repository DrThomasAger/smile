<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>(: Smile Composer — live module add, exact bottom-return ↑, correct module indent)</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { --tab: 32px; --soft-bg: #fafafa; --select-bg: #f2f2f2; --rule: rgba(0,0,0,0.08); --sidebar-w: 360px; --soft-chroma: #888; }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif; background: #fff; color: #111; padding: 24px; margin: 0; }
    .layout { display: grid; grid-template-columns: 1fr var(--sidebar-w); gap: 16px; align-items: start; }
    .left-column { display: grid; grid-template-rows: auto auto; gap: 12px; }
    .panel { background: #fff; padding: 16px; box-shadow: 0 1px 0 0 var(--rule); border-radius: 10px; }

    .sc-title { font-size: inherit; font-weight: 400; display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
    .sc-title strong em { font-style: italic; }

    .line { user-select: none; padding: 8px 10px; border-radius: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; cursor: pointer; transition: background-color 0.12s ease, opacity 0.12s ease; touch-action: none; position: relative; }
    .line.sel { font-weight: 600; background-color: var(--select-bg); }
    .left-span { flex: 1 1 auto; min-width: 0; display: inline-flex; align-items: center; gap: 10px; }

    .indent-block { margin-top: 8px; }
    .prompt-preview { white-space: pre-wrap; font-size: 13px; color: #222; }
    .soft { color: var(--soft-chroma); }

    .underline-input, .underline-textarea {
      width: 100%; background: transparent; border: none; border-bottom: 1px solid #ccc; border-radius: 0;
      padding: 6px 2px 6px 0; font: inherit; outline: none; resize: vertical; min-height: 34px;
    }
    .underline-textarea { min-height: 280px; } /* taller editor */

    .action-bar-inline { display: block; margin-top: 8px; }
    .action-row { display: inline-flex; align-items: center; gap: 10px; width: 100%; }
    .action-spacer { flex: 1 1 auto; }
    .action-hint-left, .action-hint-right { font-size: 12px; color: #444; user-select: none; }

    .settings-buttons { display: flex; justify-content: flex-end; gap: 8px; margin-top: 6px; }
    .settings-btn { font-size: 12px; border: 1px solid var(--rule); background: #fff; border-radius: 8px; padding: 4px 10px; cursor: default; }

    .rightbar { position: sticky; top: 16px; height: calc(100vh - 32px); overflow: auto; background: #fff; box-shadow: 0 1px 0 0 var(--rule); border-radius: 10px; padding: 12px; }
    .rightbar textarea { width: 100%; height: calc(100vh - 56px); border: none; outline: none; resize: none; background: transparent; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; line-height: 1.5; }

    .add-bar .dock { border-radius: 12px; padding: 8px; background: #fff; box-shadow: 0 1px 0 0 var(--rule); }
    .omni-input { border: none; outline: none; background: transparent; font: inherit; padding: 8px 2px; width: 100%; transition: background-color 0.12s ease; }
    .omni-input:focus { background-color: var(--select-bg); }
    .omni-list { max-height: 320px; overflow: auto; display: grid; gap: 6px; margin-top: 6px; }
    .omni-item { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; background: var(--soft-bg); border-radius: 12px; cursor: pointer; }
    .omni-item.sel { font-weight: 600; background-color: var(--select-bg); }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; background: #eee; text-transform: lowercase; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div class="error">Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useCallback, useMemo } = React;
    const TAB = 32;

    /* ========= Utilities: names, soft-highlighting, drafts ========= */

    const stripFolders = (s) => s.split('/').pop();
    const stripExtension = (s) => s.replace(/\.[^./\\]+$/, '');
    const displayShortName = (s) => stripExtension(stripFolders(s));

    const SOFT_CHARS = new Set(['(', ')', '[', ']', '{', '}', ':', ';']);
    function isEmojiChar(ch) {
      const cp = ch.codePointAt(0);
      return (cp >= 0x1F000 && cp <= 0x1FAFF) || (cp >= 0x2600 && cp <= 0x27BF) || cp === 0xFE0F;
    }
    function renderSoftHighlighted(text, keyPrefix='k') {
      const nodes = [];
      let k = 0;
      for (const ch of text) {
        if (SOFT_CHARS.has(ch) || isEmojiChar(ch)) nodes.push(<span key={keyPrefix + (k++)} className="soft">{ch}</span>);
        else nodes.push(<span key={keyPrefix + (k++)}>{ch}</span>);
      }
      return nodes;
    }
    const SoftText = ({ text }) => <>{renderSoftHighlighted(text, 'st-')}</>;

    const draftKeyFor = (relPath) => `draft:${relPath}`;
    const saveDraft = (relPath, text) => { try { localStorage.setItem(draftKeyFor(relPath), text); } catch(_) {} };
    const loadDraft = (relPath) => { try { return localStorage.getItem(draftKeyFor(relPath)); } catch(_) { return null; } };
    const clearDraft = (relPath) => { try { localStorage.removeItem(draftKeyFor(relPath)); } catch(_) {} };

    /* ========= File System Access API ========= */

    async function verifyPerm(handle, mode = 'readwrite') {
      if (!handle) return false;
      const opts = { mode };
      const q = await handle.queryPermission(opts);
      if (q === 'granted') return true;
      const r = await handle.requestPermission(opts);
      return r === 'granted';
    }

    async function getFileHandleFromPath(rootDirHandle, relPath) {
      let dir = rootDirHandle;
      const parts = relPath.split('/').filter(Boolean);
      for (let i = 0; i < parts.length; i++) {
        const seg = parts[i];
        const isLast = i === parts.length - 1;
        if (isLast) return await dir.getFileHandle(seg, { create: false });
        dir = await dir.getDirectoryHandle(seg, { create: false });
      }
    }

    async function readTextFile(fileHandle) {
      const file = await fileHandle.getFile();
      return await file.text();
    }

    async function writeTextFile(fileHandle, text) {
      const writable = await fileHandle.createWritable();
      await writable.write(text);
      await writable.close();
    }

    /**
     * Resolve the project’s prompt folder by allowing the user’s first click to grant access,
     * then descending to /prompt or /smile/prompt based on the selected directory.
     * This avoids an explicit “Connect” UI while still respecting browser permissions.
     */
    async function getPromptRootViaFirstUserAction() {
      const base = await window.showDirectoryPicker();
      // Try descend to prompt, or smile/prompt
      async function tryGetPromptFrom(sel) {
        try { return await sel.getDirectoryHandle('prompt', { create: false }); } catch(_) {}
        try {
          const smile = await sel.getDirectoryHandle('smile', { create: false });
          return await smile.getDirectoryHandle('prompt', { create: false });
        } catch(_) {}
        // If selected is the prompt folder itself
        try {
          // Duck test by checking presence of "modules" inside
          const m = await sel.getDirectoryHandle('modules', { create: false });
          if (m) return sel;
        } catch(_) {}
        throw new Error('Could not resolve prompt folder relative to selection');
      }
      const promptHandle = await tryGetPromptFrom(base);
      const ok = await verifyPerm(promptHandle, 'readwrite');
      if (!ok) throw new Error('Permission denied for prompt folder');
      return promptHandle;
    }

    /* ========= DB store ========= */

    class DataStore {
      constructor() { this.data = {}; this.db = {}; this.version = 0; }
      get(key, def) { return key in this.data ? this.data[key] : def; }
      set(key, value) { this.data = { ...this.data, [key]: value }; this.version++; return this.data; }
      replaceDb(db) { this.db = db || {}; this.version++; }
      getDbItem(id) { return this.db[id] || null; }
      getAllDb() { return this.db; }
      getVersion() { return this.version; }
      reset() { this.data = {}; this.version++; return this.data; }
    }

    /* ========= Scanning prompt/ into memory ========= */

    async function scanPrompt(promptRootHandle) {
      const db = {};
      const agentId = 'expert-maker';
      db[agentId] = { name: 'Expert Maker', type: 'agent', input: 'Question', output: 'Answer', modules: [] };

      // Modules: prompt/modules (files at top-level of /modules excluding "instructions" dir)
      const modulesDir = await promptRootHandle.getDirectoryHandle('modules', { create: false });
      const moduleFiles = [];
      for await (const entry of modulesDir.values()) {
        if (entry.kind === 'file') moduleFiles.push(entry.name);
      }
      moduleFiles.sort((a,b) => a.toLowerCase().localeCompare(b.toLowerCase()));
      const moduleIds = [];

      for (const fname of moduleFiles) {
        const moduleId = `mod:${stripExtension(fname)}`;
        db[moduleId] = { name: stripExtension(fname), type: 'mod', items: [] };
        moduleIds.push(moduleId);
      }

      // Instructions: prompt/modules/instructions recursively
      let instrDir;
      try {
        instrDir = await modulesDir.getDirectoryHandle('instructions', { create: false });
      } catch(_) {
        instrDir = null;
      }

      const instructionEntries = [];
      async function walk(dirHandle, relPrefix) {
        for await (const node of dirHandle.values()) {
          if (node.kind === 'directory') {
            await walk(node, relPrefix + node.name + '/');
          } else if (node.kind === 'file') {
            instructionEntries.push(relPrefix + node.name);
          }
        }
      }
      if (instrDir) await walk(instrDir, 'modules/instructions/');

      instructionEntries.sort((a,b) => displayShortName(a).toLowerCase().localeCompare(displayShortName(b).toLowerCase()));

      // For now, each module shows the full instruction set in its view (your structure guarantees single instruction folder)
      // Create DB items for instructions
      for (const relPath of instructionEntries) {
        const insId = `ins:${relPath}`;
        db[insId] = { name: displayShortName(relPath), type: 'instr', path: relPath };
      }
      for (const mid of moduleIds) {
        db[mid].items = instructionEntries.map(p => `ins:${p}`);
      }

      // Attach modules to agent
      db[agentId].modules = moduleIds;

      // Build Omni index: all files under prompt/ recursively with content
      const omni = [];
      // modules (by name only)
      for (const mid of moduleIds) {
        omni.push({ id: mid, type: 'mod', name: db[mid].name });
      }
      // all prompt files
      async function walkAll(dirHandle, relPrefix) {
        for await (const node of dirHandle.values()) {
          if (node.kind === 'directory') {
            await walkAll(node, relPrefix + node.name + '/');
          } else {
            const rel = relPrefix + node.name;
            try {
              const fh = await getFileHandleFromPath(promptRootHandle, rel);
              const txt = await readTextFile(fh);
              omni.push({ id: `file:${rel}`, type: 'file', name: displayShortName(rel), relPath: rel, content: txt });
            } catch(_) {
              omni.push({ id: `file:${rel}`, type: 'file', name: displayShortName(rel), relPath: rel, content: '' });
            }
          }
        }
      }
      await walkAll(promptRootHandle, '');

      return { db, omni };
    }

    /* ========= React App ========= */

    function App() {
      const storeRef = useRef(new DataStore());
      const store = storeRef.current;

      const [storeVersion, setStoreVersion] = useState(store.getVersion());
      const [path, setPath] = useState(() => {
        const hash = window.location.hash.slice(1);
        if (hash) { const parts = hash.split('/').filter(Boolean); if (parts.length > 0) return parts; }
        return ['expert-maker'];
      });
      const [idx, setIdx] = useState(0);

      const [promptRoot, setPromptRoot] = useState(null);
      const [status, setStatus] = useState('Ready');
      const [omniIndex, setOmniIndex] = useState([]);
      const [omniActive, setOmniActive] = useState(false);
      const [omniQuery, setOmniQuery] = useState('');
      const [omniSelectedIdx, setOmniSelectedIdx] = useState(0);
      const omniInputRef = useRef(null);

      const rowsRef = useRef([]);
      const openEditorKeyRef = useRef(null);
      const currentEditValueRef = useRef(null);
      const currentFileHandleRef = useRef(null);
      const currentFilePathRef = useRef(null);

      const agent = store.getDbItem(path[0]) || store.getDbItem('expert-maker');
      const atModule = path.length >= 2;

      // First user click triggers scanning of smile/prompt automatically, avoiding explicit "connect" UI.
      const didInitScanRef = useRef(false);
      const requestScanIfNeeded = useCallback(async () => {
        if (didInitScanRef.current) return;
        try {
          setStatus('Loading prompt folder…');
          const pr = await getPromptRootViaFirstUserAction();
          setPromptRoot(pr);
          const { db, omni } = await scanPrompt(pr);
          store.replaceDb(db);
          setOmniIndex(omni);
          setStoreVersion(store.getVersion());
          didInitScanRef.current = true;
          setStatus('Loaded');
          // default agent view index
          setPath(['expert-maker']);
          setIdx( agent && agent.modules && agent.modules.length ? 1 : 0 );
        } catch (e) {
          setStatus('Permission required for prompt folder');
        }
      }, [store, agent]);

      // Build rows view
      const buildRows = useCallback(() => {
        const rows = [];
        const ag = store.getDbItem('expert-maker');
        rows.push({ key: `agent:expert-maker`, type: 'agent', depth: 0, label: ag ? ag.name : 'Expert Maker' });

        if (atModule) {
          const modId = path[path.length - 1];
          const mod = store.getDbItem(modId);
          rows.push({ key: `module:${modId}`, type: 'module', depth: 1, label: mod ? mod.name : 'Module', moduleId: modId });
          const items = mod ? (mod.items || []) : [];
          items.forEach((iid, i) => {
            const it = store.getDbItem(iid);
            const relPath = it ? (it.path || '') : '';
            rows.push({
              key: `ins:${iid}`, type: 'instr', depth: 2,
              label: it ? displayShortName(relPath) : 'Instruction', dbId: iid, pos: i, isOutput: i === items.length - 1,
              relPath
            });
          });
        } else {
          const mods = (ag && ag.modules) ? ag.modules : [];
          mods.forEach((mid, i) => {
            const m = store.getDbItem(mid);
            rows.push({
              key: `mod:${mid}:${i}`, type: 'module-item', depth: 1, label: m ? m.name : 'Module', moduleId: mid, pos: i, isOutput: i === mods.length - 1
            });
          });
        }
        return rows;
      }, [store, path, atModule]);

      const rows = useMemo(() => {
        const built = buildRows();
        rowsRef.current = built;
        return built;
      }, [buildRows, storeVersion]);

      // Hash sync
      useEffect(() => {
        const hash = '#' + path.join('/');
        if (window.location.hash !== hash) window.history.pushState(null, '', hash);
      }, [path]);
      useEffect(() => {
        const handlePopState = () => {
          const hash = window.location.hash.slice(1);
          if (hash) {
            const parts = hash.split('/').filter(Boolean);
            if (parts.length > 0) setPath(parts);
          } else setPath(['expert-maker']);
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      // Auto-save when leaving an instruction
      const closeAndSaveIfNeeded = useCallback(async () => {
        const key = openEditorKeyRef.current;
        const text = currentEditValueRef.current;
        const fileHandle = currentFileHandleRef.current;
        const relPath = currentFilePathRef.current;
        if (!key || text == null || !fileHandle || !relPath) return;
        try {
          const disk = await readTextFile(fileHandle);
          if (disk !== text) await writeTextFile(fileHandle, text);
        } catch(_) {}
        clearDraft(relPath);
        openEditorKeyRef.current = null;
        currentEditValueRef.current = null;
        currentFileHandleRef.current = null;
        currentFilePathRef.current = null;
      }, []);

      // Keyboard navigation + Omni toggle
      useEffect(() => {
        const onKeyDown = (e) => {
          // open Omni with + or =
          if ((e.key === '+' || e.key === '=') && document.activeElement !== omniInputRef.current) {
            e.preventDefault();
            setOmniActive(true);
            setTimeout(() => { if (omniInputRef.current) omniInputRef.current.focus(); }, 0);
            return;
          }
          if (omniActive) return;

          const rws = rowsRef.current;
          if (!rws.length) return;
          const last = rws.length - 1;

          if (e.key === 'ArrowUp') {
            e.preventDefault();
            const next = Math.max(0, idx - 1);
            if (next !== idx) { closeAndSaveIfNeeded(); setIdx(next); }
          }
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            const next = Math.min(last, idx + 1);
            if (next !== idx) { closeAndSaveIfNeeded(); setIdx(next); }
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            closeAndSaveIfNeeded();
          }

          const sel = rws[idx];
          if (!sel) return;

          if (e.key === 'ArrowRight' && sel.type === 'module-item') {
            e.preventDefault();
            setPath(prev => [prev[0], sel.moduleId]);
            setTimeout(() => {
              const firstInstrIdx = rowsRef.current.findIndex(x => x.type === 'instr');
              setIdx(firstInstrIdx >= 0 ? firstInstrIdx : idx);
            }, 0);
            return;
          }
          if (e.key === 'ArrowLeft' && sel.type !== 'agent') {
            e.preventDefault();
            setPath(['expert-maker']);
            setTimeout(() => {
              const target = rowsRef.current.findIndex(x => x.type === 'module-item' && x.moduleId === (path[1] || ''));
              setIdx(target >= 0 ? target : 0);
            }, 0);
            return;
          }
        };
        window.addEventListener('keydown', onKeyDown);
        return () => window.removeEventListener('keydown', onKeyDown);
      }, [idx, omniActive, path, closeAndSaveIfNeeded]);

      // OmniSearch results across all prompt files
      const omniResults = useMemo(() => {
        const q = (omniQuery || '').toLowerCase().trim();
        if (!q) return [];
        const results = omniIndex.filter(item => {
          if (item.type === 'mod') return item.name.toLowerCase().includes(q);
          return (item.name.toLowerCase().includes(q) || (item.content || '').toLowerCase().includes(q));
        });
        results.sort((a, b) => {
          if (a.type !== b.type) return a.type === 'mod' ? -1 : 1;
          return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
        return results.slice(0, 100);
      }, [omniQuery, omniIndex]);
      useEffect(() => {
        if (omniSelectedIdx >= omniResults.length && omniResults.length > 0) {
          setOmniSelectedIdx(omniResults.length - 1);
        } else if (omniResults.length === 0) {
          setOmniSelectedIdx(0);
        }
      }, [omniResults, omniSelectedIdx]);

      const navigateOmniItem = useCallback((item) => {
        if (!item) return;
        if (item.type === 'mod') {
          setPath(['expert-maker', item.id]);
          setOmniActive(false);
          setOmniQuery('');
          setTimeout(() => {
            const firstInstrIdx = rowsRef.current.findIndex(x => x.type === 'instr');
            setIdx(firstInstrIdx >= 0 ? firstInstrIdx : 0);
          }, 0);
          return;
        }
        if (item.type === 'file') {
          // If file is an instruction under modules/instructions, open its module view and select it
          if ((item.relPath || '').startsWith('modules/instructions/')) {
            const ag = store.getDbItem('expert-maker');
            const firstMod = ag && ag.modules && ag.modules[0];
            if (firstMod) {
              setPath(['expert-maker', firstMod]);
              setOmniActive(false);
              setOmniQuery('');
              setTimeout(() => {
                const dbId = `ins:${item.relPath}`;
                const found = rowsRef.current.findIndex(x => x.type === 'instr' && x.dbId === dbId);
                setIdx(found >= 0 ? found : 0);
              }, 0);
              return;
            }
          }
          // Otherwise just close Omni; files outside instruction set are searchable but not directly selectable
          setOmniActive(false);
          setOmniQuery('');
          return;
        }
      }, [store]);

      /* ===== Preview and Editor Components ===== */

      function InstructionPreviewLine({ relPath, depth }) {
        const [lines, setLines] = useState(['Select once to grant folder access…']);
        useEffect(() => {
          let alive = true;
          (async () => {
            if (!promptRoot || !relPath) return;
            try {
              const fh = await getFileHandleFromPath(promptRoot, relPath);
              const txt = await readTextFile(fh);
              const first = txt.split(/\r?\n/).slice(0, 3);
              if (alive) setLines(first);
            } catch(_) {
              if (alive) setLines(['Missing file']);
            }
          })();
          return () => { alive = false; };
        }, [relPath, promptRoot]);
        const pad = ((depth || 0) + 1) * TAB;
        return (
          <div className="indent-block" style={{ paddingLeft: pad }}>
            <div className="prompt-preview">
              {lines.map((ln, i) => <div key={'pv-' + i}><SoftText text={ln} /></div>)}
            </div>
          </div>
        );
      }

      function InstructionInlineEditor({ row, depth }) {
        const pad = ((depth || 0) + 1) * TAB;
        const taRef = useRef(null);
        const [value, setValue] = useState('');
        const [loadErr, setLoadErr] = useState(null);

        useEffect(() => {
          let alive = true;
          (async () => {
            try {
              if (!promptRoot) {
                // First user action lazily triggers prompt access
                await requestScanIfNeeded();
              }
              if (!promptRoot) { setLoadErr('No folder'); return; }
              const fh = await getFileHandleFromPath(promptRoot, row.relPath);
              const draft = loadDraft(row.relPath);
              const disk = await readTextFile(fh);
              const txt = draft != null ? draft : disk;
              if (!alive) return;
              setValue(txt);
              openEditorKeyRef.current = row.key;
              currentEditValueRef.current = txt;
              currentFileHandleRef.current = fh;
              currentFilePathRef.current = row.relPath;
              setLoadErr(null);
              setTimeout(() => {
                if (taRef.current) {
                  taRef.current.focus();
                  try {
                    const len = taRef.current.value.length;
                    taRef.current.setSelectionRange(len, len);
                  } catch(_) {}
                }
              }, 0);
            } catch (e) {
              setLoadErr('Missing or blocked file');
            }
          })();
          return () => { alive = false; };
        }, [row]);

        return (
          <div className="indent-block" style={{ paddingLeft: pad }}>
            <textarea
              ref={taRef}
              className="underline-textarea"
              value={loadErr ? loadErr : value}
              onChange={(e) => {
                const v = e.target.value;
                setValue(v);
                currentEditValueRef.current = v;
                if (row.relPath) saveDraft(row.relPath, v);
              }}
              placeholder="Instruction…"
            />
            <input type="text" className="underline-input" placeholder="Name…" defaultValue={row.label} />
            <textarea className="underline-textarea" placeholder="Meta information…"></textarea>
            <StructureDots5 id={row.dbId} value={'heavy'} onChange={() => {}} />
          </div>
        );
      }

      function StructureDots5({ id, value, onChange }) {
        const opts = [
          { v: 'heavy', label: 'Heavy' },
          { v: 'heavy-mid', label: '●' },
          { v: 'medium', label: 'Medium' },
          { v: 'medium-light', label: '●' },
          { v: 'light', label: 'Light' }
        ];
        return (
          <div className="seg" role="radiogroup" aria-label="Structure">
            <span className="label">Structure</span>
            {opts.map((o) => (
              <label key={o.v} title={o.label}>
                <input type="radio" name={`struct-${id}`} value={o.v} checked={value === o.v} onChange={(e) => onChange(e.target.value)} />
                <span className="opt">
                  {o.label === '●' ? <span className="dot" aria-hidden="true"></span> : <span style={{ fontSize: 12 }}>{o.label}</span>}
                </span>
              </label>
            ))}
          </div>
        );
      }

      function ModulePreview({ moduleId, depth }) {
        const mod = store.getDbItem(moduleId);
        if (!mod) return null;
        const items = mod.items || [];
        const pad = ((depth || 0) + 1) * TAB;
        const showIds = items.slice(0, 3);
        const hasMore = items.length > 3;
        return (
          <div className="indent-block" style={{ paddingLeft: pad }}>
            {showIds.length === 0 ? <div className="prompt-preview">Empty module</div> :
              <>
                {showIds.map((iid) => {
                  const ins = store.getDbItem(iid); if (!ins) return null;
                  const rel = ins.path || ins.name;
                  return <div key={iid} className="prompt-preview"><SoftText text={displayShortName(rel)} /></div>;
                })}
                {hasMore ? <div className="prompt-preview">...</div> : null}
              </>
            }
          </div>
        );
      }

      // Rightbar summary
      const rightbarText = useMemo(() => {
        const lines = [];
        const ag = store.getDbItem('expert-maker');
        lines.push('Modules:');
        const mods = (ag && ag.modules) ? ag.modules : [];
        for (const mid of mods) {
          const m = store.getDbItem(mid);
          if (!m) continue;
          lines.push('  - ' + m.name);
        }
        lines.push('');
        return lines.join('\n');
      }, [storeVersion]);

      /* ===== Render ===== */

      return (
        <div className="layout" onClick={requestScanIfNeeded}>
          <div className="left-column">
            <div className="panel">
              <div className="sc-title">
                <span><strong><em>(: Smile Composer)</em></strong></span>
                <span style={{ fontSize: 12, color: '#444' }}><SoftText text={status} /></span>
              </div>

              {rows.map((row, i) => {
                const isSelected = (i === idx);
                return (
                  <React.Fragment key={row.key}>
                    <div
                      className={['line', isSelected ? 'sel' : ''].join(' ').trim()}
                      style={{ paddingLeft: (row.depth || 0) * TAB }}
                      data-key={row.key}
                      onClick={async () => {
                        if (i !== idx) await closeAndSaveIfNeeded();
                        setIdx(i);
                      }}
                      onDoubleClick={() => {
                        if (row.type === 'module-item') {
                          setPath(prev => [prev[0], row.moduleId]);
                          setTimeout(() => {
                            const firstInstrIdx = rowsRef.current.findIndex(x => x.type === 'instr');
                            setIdx(firstInstrIdx >= 0 ? firstInstrIdx : i);
                          }, 0);
                        }
                      }}
                      title="Select"
                    >
                      <span className="left-span">
                        {row.isOutput ? <strong>OUTPUT: </strong> : null}
                        <SoftText text={row.label} />
                      </span>
                    </div>

                    {row.type === 'instr' && !isSelected && (
                      <InstructionPreviewLine relPath={row.relPath} depth={row.depth} />
                    )}

                    {row.type === 'instr' && isSelected && (
                      <>
                        <InstructionInlineEditor row={row} depth={row.depth} />
                        <div className="action-bar-inline" style={{ paddingLeft: ((row.depth || 0) + 1) * TAB }}>
                          <div className="action-row" onClick={(e)=>e.stopPropagation()}>
                            <span className="action-hint-left">([Esc] to cancel)</span>
                            <span className="action-spacer"></span>
                            <span className="action-hint-right">-> Settings</span>
                          </div>
                        </div>
                        <div className="settings-buttons" style={{ paddingLeft: ((row.depth || 0) + 1) * TAB }}>
                          <span className="settings-btn" title="Movement uses Arrow keys">-> Movement</span>
                          <span className="settings-btn" title="Duplicate disabled in file-mirror build">-> + Duplicate</span>
                          <span className="settings-btn" title="Delete disabled in file-mirror build">-> Delete</span>
                        </div>
                      </>
                    )}

                    {i === idx && row.type === 'module-item' && (
                      <ModulePreview moduleId={row.moduleId} depth={row.depth} />
                    )}
                  </React.Fragment>
                );
              })}
            </div>

            <div className="add-bar">
              <div className="dock">
                <input
                  ref={omniInputRef}
                  className="omni-input"
                  placeholder="OmniSearch: type to search modules and all prompt files…"
                  value={omniQuery}
                  onFocus={() => setOmniActive(true)}
                  onBlur={() => setOmniActive(false)}
                  onChange={e => { setOmniQuery(e.target.value); setOmniSelectedIdx(0); }}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter' || e.key === 'ArrowRight') {
                      e.preventDefault();
                      const list = omniResults;
                      if (list.length > 0 && omniSelectedIdx >= 0 && omniSelectedIdx < list.length) {
                        navigateOmniItem(list[omniSelectedIdx]);
                      }
                      return;
                    }
                    if (e.key === 'Escape') {
                      e.preventDefault();
                      setOmniActive(false);
                      setOmniQuery('');
                      setOmniSelectedIdx(0);
                      try { omniInputRef.current && omniInputRef.current.blur(); } catch(_) {}
                      return;
                    }
                    if (e.key === 'ArrowDown') {
                      e.preventDefault();
                      if (omniResults.length > 0) setOmniSelectedIdx(prev => Math.min(omniResults.length - 1, prev + 1));
                      return;
                    }
                    if (e.key === 'ArrowUp') {
                      e.preventDefault();
                      if (omniResults.length > 0 && omniSelectedIdx > 0) setOmniSelectedIdx(prev => Math.max(0, prev - 1));
                      return;
                    }
                  }}
                />
                {(omniActive && omniResults.length) ? (
                  <div className="omni-list">
                    {omniResults.map((r, i) => (
                      <div
                        key={r.id + ':' + i}
                        className={`omni-item ${i === omniSelectedIdx ? 'sel' : ''}`}
                        onMouseDown={(e) => { e.preventDefault(); }} /* keep focus */
                        onClick={() => navigateOmniItem(r)}
                      >
                        <span><SoftText text={r.name} /></span>
                        <span className="badge">{r.type === 'mod' ? 'module' : 'file'}</span>
                      </div>
                    ))}
                  </div>
                ) : null}
              </div>
            </div>
          </div>

          <div className="rightbar">
            <textarea readOnly value={rightbarText} />
          </div>
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div class="error">Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
