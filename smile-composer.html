<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Smile Composer — Inline Actions, Right-Flow Settings, Bottom Add</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { --tab: 32px; --soft-bg: #fafafa; --hover-bg: #f6f6f6; --select-bg: #f2f2f2; --rule: rgba(0,0,0,0.08); --sidebar-w: 360px; }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif; background: #fff; color: #111; padding: 24px; margin: 0; }
    .layout { display: grid; grid-template-columns: 1fr var(--sidebar-w); gap: 16px; align-items: start; }
    .container { display: block; width: 100%; }
    .panel { background: #fff; padding: 16px; box-shadow: 0 1px 0 0 var(--rule); border-radius: 10px; }

    .line { user-select: none; padding: 8px 10px; border-radius: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; cursor: pointer; transition: background-color 0.12s ease, opacity 0.12s ease; touch-action: none; position: relative; }
    .line:hover { background-color: var(--hover-bg); }
    .line.sel { font-weight: 600; background-color: var(--select-bg); }
    .line.held { opacity: 0.35; }
    .line.drop-target { outline: 3px solid #111; outline-offset: -3px; border-radius: 12px; }
    .left-span { flex: 1 1 auto; min-width: 0; display: inline-flex; align-items: center; gap: 10px; }

    .actions-text { font-size: inherit; color: #222; display: inline-flex; gap: 6px; flex-wrap: wrap; align-items: center; }
    .action-chip { padding: 4px 8px; border-radius: 8px; display: inline-flex; align-items: center; border: 1px solid var(--rule); background: #fff; cursor: pointer; }
    .action-chip:hover { background: var(--hover-bg); }
    .action-chip.focus { font-weight: 800; background: var(--select-bg); }

    .action-bar-inline { display: inline-flex; align-items: center; gap: 10px; width: 100%; }
    .action-spacer { flex: 1 1 auto; }
    .action-back { font-size: 12px; color: #444; cursor: pointer; user-select: none; }
    .action-back:hover { text-decoration: underline; }
    .action-hint { font-size: 12px; color: #666; }

    .indent-block { margin-top: 8px; }
    .underline-input, .underline-textarea { width: 100%; background: transparent; border: none; border-bottom: 1px solid #ccc; border-radius: 0; padding: 6px 2px 6px 0; font: inherit; outline: none; resize: vertical; min-height: 34px; }
    .underline-textarea { min-height: 80px; }

    .error { color: red; padding: 20px; border: 1px solid red; margin: 20px; border-radius: 8px; }

    .seg { display: inline-flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 999px; background: var(--soft-bg); }
    .seg .label { font-size: 12px; margin-right: 4px; }
    .seg input[type="radio"] { position: absolute; opacity: 0; pointer-events: none; }
    .seg .opt { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; }
    .seg .dot { width: 8px; height: 8px; border-radius: 50%; background: #bbb; display: inline-block; }
    .seg input[type="radio"]:checked + .opt .dot { background: #111; }

    .prompt-preview { white-space: pre-wrap; font-size: 13px; color: #222; }

    /* Hover-only left pin for quick settings */
    .hover-settings {
      position: absolute;
      left: 6px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 12px;
      padding: 2px 6px;
      background: #fff;
      border: 1px solid var(--rule);
      border-radius: 8px;
      opacity: 0;
      pointer-events: none;
    }
    .line:hover .hover-settings { opacity: 1; pointer-events: auto; }
    .hover-settings:hover { background: var(--hover-bg); }

    /* Bottom Add Dock */
    .bottom-dock { margin-top: 16px; }
    .dock-toggle { display: inline-flex; align-items: center; gap: 6px; padding: 8px 12px; border-radius: 999px; background: var(--soft-bg); border: 1px solid var(--rule); cursor: pointer; }
    .dock { margin-top: 8px; border-radius: 12px; padding: 8px; background: #fff; box-shadow: 0 1px 0 0 var(--rule); }
    .omni-list { max-height: 300px; overflow: auto; display: grid; gap: 6px; }
    .omni-item { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; background: var(--soft-bg); border-radius: 12px; cursor: pointer; }
    .omni-item:hover { background-color: var(--hover-bg); }
    .omni-item.sel { background-color: var(--select-bg); font-weight: 600; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; background: #eee; }
    .omni-input { border: none; outline: none; background: transparent; font: inherit; padding: 8px 2px; width: 100%; }

    /* Right Sidebar */
    .rightbar { position: sticky; top: 16px; height: calc(100vh - 32px); overflow: auto; background: #fff; box-shadow: 0 1px 0 0 var(--rule); border-radius: 10px; padding: 12px; }
    .rightbar textarea { width: 100%; height: calc(100vh - 56px); border: none; outline: none; resize: none; background: transparent; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; line-height: 1.5; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div class="error">Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useCallback, useMemo } = React;
    const TAB = 32;

    const INITIAL_DB = {
      'expert-maker': { name: 'Expert Maker', type: 'agent', input: 'Question', output: 'Answer', modules: ['meta-info', 'jargon-cot', 'identify-mistakes'] },
      'meta-info': { name: 'Meta-Information MegaBrick', type: 'mod', items: ['smile-info', 'llm-info', 'user-info'] },
      'jargon-cot': { name: 'Jargon CoT', type: 'mod', items: ['emoji-section', 'bold-words', 'top-bottom'] },
      'identify-mistakes': { name: 'Identify Mistakes and Rewrite', type: 'mod', items: ['emoji-section', 'bold-words', 'negative-rewrite'] },

      'smile-info': { name: 'Information About (: Smile', type: 'instr', text: 'Explain Smile syntax: (: flexible, [: rigid, [= literal.' },
      'llm-info': { name: 'Information About LLMs', type: 'instr', text: 'Meta-knowledge about how LLMs process instructions.' },
      'user-info': { name: 'Information About User', type: 'instr', text: 'Contextualize user needs and goals.' },

      'emoji-section': { name: 'Emoji section name', type: 'instr', text: 'Use two emoticons for section names.' },
      'bold-words': { name: 'Bold for important words', type: 'instr', text: 'Use **bold** for attention retention over long contexts.' },
      'top-bottom': { name: 'Maximize adherence through top+bottom replication', type: 'instr', text: 'Replicate critical instructions at beginning and end.' },

      'negative-rewrite': { name: 'Identify negatives and rewrite to positive', type: 'instr', text: 'Find negatives like “not” and rewrite as positive articulations.' }
    };

    class DataStore {
      constructor() { this.data = this.loadFromStorage(); this.db = { ...INITIAL_DB }; this.version = 0; }
      loadFromStorage() { try { const stored = localStorage.getItem('smileData'); return stored ? JSON.parse(stored) : {}; } catch(e){ return {}; } }
      saveToStorage(data) { try { localStorage.setItem('smileData', JSON.stringify(data)); } catch(e){} }
      get(key, def) { return key in this.data ? this.data[key] : def; }
      set(key, value) { this.data = { ...this.data, [key]: value }; this.version++; this.saveToStorage(this.data); return this.data; }
      reset() { this.data = {}; localStorage.removeItem('smileData'); this.db = { ...INITIAL_DB }; this.version++; return this.data; }
      getDbItem(id) { return this.db[id] || null; }
      addCustomDbItem(id, item) { this.db[id] = item; this.version++; }
      getAllDb() { return this.db; }
      getVersion() { return this.version; }
    }

    const moveInList = (arr, fromPos, toPos) => {
      if (fromPos === toPos || fromPos < 0 || toPos < 0 || fromPos >= arr.length) return arr;
      const newArr = [...arr];
      const [item] = newArr.splice(fromPos, 1);
      const insertPos = Math.min(toPos, newArr.length);
      newArr.splice(insertPos, 0, item);
      return newArr;
    };

    const displayNameFor = (store, dbItem, id) =>
      store.get(`nn-${id}`, store.get(`n-${dbItem.name}`, dbItem.name));

    class RowBuilder {
      constructor(store, path) { this.store = store; this.path = path; this.rows = []; }
      build() {
        this.addAgent();
        this.addBreadcrumbs();
        if (this.isAtModule()) this.addModuleContent(); else this.addAgentModules();
        return this.rows;
      }
      addAgent() {
        const agent = this.getAgent(); if (!agent) return;
        this.rows.push({ key: `agent:${this.path[0]}`, type: 'agent', depth: 1, label: this.store.get(`n-${agent.name}`, agent.name) });
      }
      addBreadcrumbs() {
        if (this.path.length <= 2) return;
        for (let i = 1; i < this.path.length - 1; i++) {
          const breadcrumbMod = this.store.getDbItem(this.path[i]); if (!breadcrumbMod) continue;
          this.rows.push({ key: `breadcrumb:${i}`, type: 'breadcrumb', depth: i + 1, label: this.store.get(`n-${breadcrumbMod.name}`, breadcrumbMod.name), pathIndex: i });
        }
      }
      addModuleContent() {
        const module = this.getCurrentModule(); if (!module) return;
        const moduleDBKey = this.path[this.path.length - 1];
        this.rows.push({ key: `module:${moduleDBKey}`, type: 'module', depth: 2, label: this.store.get(`n-${module.name}`, module.name), moduleId: moduleDBKey });

        const items = this.store.get(`items-${module.name}`, module.items || []);
        items.forEach((id, i) => {
          const ins = this.store.getDbItem(id); if (!ins) return;
          this.rows.push({
            key: `ins:${id}`, type: 'instr', depth: 3,
            label: displayNameFor(this.store, ins, id),
            isOutput: i === items.length - 1,
            nameKey: `n-${ins.name}`, nameOverrideKey: `nn-${id}`,
            textKey: `t-${ins.name}`, defaultText: ins.text || '',
            metaKey: `meta-${id}`, structKey: `struct-${id}`,
            promptKey: `t-${ins.name}`, dbId: id, pos: i, canReorder: true
          });
        });

        this.rows.push({ key: `adder-instr:${module.name}`, type: 'adder-instr', depth: 3, moduleId: moduleDBKey, label: '[+] Add Instruction' });
      }
      addAgentModules() {
        const agent = this.getAgent(); if (!agent) return;
        const modules = this.store.get(`mods-${agent.name}`, agent.modules || []);
        modules.forEach((mid, i) => {
          const mod = this.store.getDbItem(mid); if (!mod) return;
          this.rows.push({
            key: `mod:${mid}:${i}`, type: 'module-item', depth: 2,
            label: displayNameFor(this.store, mod, mid),
            isOutput: i === modules.length - 1,
            nameKey: `n-${mod.name}`, nameOverrideKey: `nn-${mid}`,
            metaKey: `meta-${mid}`, structKey: `struct-${mid}`,
            moduleId: mid, pos: i, canReorder: true
          });
        });
        this.rows.push({ key: `adder-mod-${agent.name}`, type: 'adder-mod', depth: 2, label: '+ Add Module' });
      }
      isAtModule() { return this.path.length >= 2; }
      getAgent() { return this.store.getDbItem(this.path[0]); }
      getCurrentModule() { const last = this.path[this.path.length - 1]; return this.store.getDbItem(last); }
    }

    function StructureDots5({ id, value, onChange }) {
      const opts = [
        { v: 'heavy', label: 'Heavy', aria: 'Heavy' },
        { v: 'heavy-mid', label: '●', aria: 'Between heavy and medium' },
        { v: 'medium', label: 'Medium', aria: 'Medium' },
        { v: 'medium-light', label: '●', aria: 'Between medium and light' },
        { v: 'light', label: 'Light', aria: 'Light' }
      ];
      return (
        <div className="seg" role="radiogroup" aria-label="Structure">
          <span className="label">Structure</span>
          {opts.map((o) => (
            <label key={o.v} title={o.aria}>
              <input type="radio" name={`struct-${id}`} value={o.v} checked={value === o.v} onChange={(e) => onChange(e.target.value)} />
              <span className="opt">
                {o.label === '●' ? <span className="dot" aria-hidden="true"></span> : <span style={{ fontSize: 12 }}>{o.label}</span>}
              </span>
            </label>
          ))}
        </div>
      );
    }

    function InlineActionsInline({ actions, focus, onFocus, onExecute, onBack, labelForSettings="→ Settings" }) {
      return (
        <div className="action-bar-inline" onClick={(e)=>e.stopPropagation()}>
          <span className="action-back" onClick={(e)=>{ e.stopPropagation(); onBack && onBack(); }} title="Commit and exit">← Back</span>
          <span className="actions-text">
            {actions.map((a) => {
              const label = a === 'settings' ? labelForSettings : (a[0].toUpperCase()+a.slice(1));
              return (
                <button
                  type="button"
                  key={a}
                  className={`action-chip ${focus === a ? 'focus' : ''}`}
                  onMouseEnter={(e) => { e.stopPropagation(); onFocus && onFocus(a); }}
                  onClick={(e) => { e.stopPropagation(); onExecute && onExecute(a); }}
                  title={a === 'move' ? '[↑] [↓] To Move' : label}
                >
                  {a === 'move' ? '[↑] [↓] To Move' : label}
                </button>
              );
            })}
          </span>
          <span className="action-spacer"></span>
          <span className="action-hint">[Esc] Cancel</span>
        </div>
      );
    }

    function ModulePreview({ store, moduleId, depth }) {
      const mod = store.getDbItem(moduleId);
      if (!mod) return null;
      const items = store.get(`items-${mod.name}`, mod.items || []);
      const pad = ((depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          {items.length === 0 ? <div className="prompt-preview">Empty module</div> :
            items.map((iid, idx) => {
              const ins = store.getDbItem(iid); if (!ins) return null;
              const isLast = idx === items.length - 1;
              return (
                <div key={iid} className="prompt-preview">
                  {isLast ? <strong>OUTPUT:&nbsp;</strong> : null}{displayNameFor(store, ins, iid)}
                </div>
              );
            })}
        </div>
      );
    }

    function InstructionPreview({ store, row }) {
      const dbItem = store.getDbItem(row.dbId);
      if (!dbItem) return null;
      const body = store.get(row.promptKey, dbItem.text || '');
      const pad = ((row.depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          <div className="prompt-preview">{row.isOutput ? <strong>OUTPUT:&nbsp;</strong> : null}{body}</div>
        </div>
      );
    }

    function InstructionEdit({ store, row, onTextChange, getNameOverride, setNameOverride, getMeta, setMeta, getStruct, setStruct, stage=2, settingsKey }) {
      const pad = ((row.depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }} data-settings-for={settingsKey}>
          {stage === 1 ? (
            <textarea
              className="underline-textarea"
              value={store.get(row.promptKey, '')}
              onChange={(e) => onTextChange(row.promptKey, e.target.value)}
              placeholder="Instruction…"
            />
          ) : (
            <>
              <input
                type="text"
                className="underline-input"
                value={getNameOverride(row.nameOverrideKey, '')}
                onChange={(e) => setNameOverride(row.nameOverrideKey, e.target.value)}
                placeholder="Name…"
              />
              <textarea
                className="underline-textarea"
                value={getMeta(row.metaKey) || ''}
                onChange={(e) => setMeta(row.metaKey, e.target.value)}
                placeholder="Meta information…"
              />
              <textarea
                className="underline-textarea"
                value={store.get(row.promptKey, '')}
                onChange={(e) => onTextChange(row.promptKey, e.target.value)}
                placeholder="Instruction…"
              />
              <StructureDots5
                id={row.dbId}
                value={getStruct(row.structKey) || 'heavy'}
                onChange={(v) => setStruct(row.structKey, v)}
              />
            </>
          )}
        </div>
      );
    }

    function RightSidebar({ text }) {
      return (
        <div className="rightbar">
          <textarea readOnly value={text}></textarea>
        </div>
      );
    }

    function App() {
      const storeRef = useRef(new DataStore());
      const store = storeRef.current;

      const [storeVersion, setStoreVersion] = useState(store.getVersion());
      const [path, setPath] = useState(() => {
        const hash = window.location.hash.slice(1);
        if (hash) { const parts = hash.split('/').filter(Boolean); if (parts.length > 0) return parts; }
        return ['expert-maker'];
      });

      const [idx, setIdx] = useState(0);
      const [navHistory, setNavHistory] = useState({});
      const [reorderState, setReorderState] = useState(null);
      const [dragItem, setDragItem] = useState(null);
      const [dragOver, setDragOver] = useState(null);

      const rowsRef = useRef([]);
      const [actionFocus, setActionFocus] = useState(null); // {rowKey, action}
      const [rightPhase, setRightPhase] = useState({ rowKey: null, phase: 0 });
      const [instrSettingsStage, setInstrSettingsStage] = useState(1);

      // Settings container refs by rowKey for ArrowDown focus routing
      const settingsRefs = useRef(new Map());

      // Omnisearch bottom dock
      const [omniActive, setOmniActive] = useState(false);
      const [omniQuery, setOmniQuery] = useState('');
      const [omniIndex, setOmniIndex] = useState(0);
      const [omniTarget, setOmniTarget] = useState(null); // { kind: 'mod'|'instr', agentId/moduleId, insertPos }
      const omniInputRef = useRef(null);

      const rows = useMemo(() => {
        const builder = new RowBuilder(store, path);
        const built = builder.build();
        rowsRef.current = built;
        return built;
      }, [store, path, storeVersion]);

      const atAgent = path.length === 1;
      const atModule = path.length >= 2;
      const agent = store.getDbItem(path[0]) || store.getDbItem('expert-maker');
      const module = atModule ? store.getDbItem(path[path.length - 1]) : null;

      const updateData = useCallback((key, value) => { store.set(key, value); setStoreVersion(store.getVersion()); }, [store]);

      const computeInsertPosModules = useCallback(() => {
        const a = store.getDbItem(path[0]); if (!a) return 0;
        const mods = store.get(`mods-${a.name}`, a.modules || []);
        const sel = rows[idx];
        if (sel && sel.type === 'module-item') return sel.pos + 1;
        if (path.length >= 2) {
          const pos = mods.findIndex(m => m === path[1]);
          if (pos >= 0) return pos + 1;
        }
        return mods.length;
      }, [rows, idx, path, store]);

      const computeInsertPosInstr = useCallback(() => {
        if (!(atModule && module)) return null;
        const arr = store.get(`items-${module.name}`, module.items || []);
        const sel = rows[idx];
        if (sel && sel.type === 'instr') return sel.pos + 1;
        if (sel && sel.type === 'adder-instr') return arr.length;
        return arr.length;
      }, [rows, idx, atModule, module, store]);

      const openOmniAddAt = useCallback((target) => {
        setOmniActive(true); setOmniQuery(''); setOmniIndex(0); setOmniTarget(target);
        setTimeout(()=>{ omniInputRef.current && omniInputRef.current.focus(); }, 0);
      }, []);

      const attachModuleToAgent = useCallback((agentId, mid, insertPos = null) => {
        const a = store.getDbItem(agentId); if (!a) return;
        const key = `mods-${a.name}`;
        const arr = store.get(key, a.modules || []);
        const pos = (insertPos !== null && insertPos >= 0 && insertPos <= arr.length) ? insertPos : arr.length;
        const newArr = [...arr]; newArr.splice(pos, 0, mid);
        updateData(key, newArr);
      }, [store, updateData]);

      const addInstructionToModule = useCallback((moduleId, instrId, insertPos = null) => {
        const m = store.getDbItem(moduleId); if (!m) return;
        const key = `items-${m.name}`;
        const arr = store.get(key, m.items || []);
        const pos = (insertPos !== null && insertPos >= 0 && insertPos <= arr.length) ? insertPos : arr.length;
        const newArr = [...arr]; newArr.splice(pos, 0, instrId);
        updateData(key, newArr);
      }, [store, updateData]);

      const navigateToPath = useCallback((newPath, autoSelect = true) => {
        setPath(newPath);
        setReorderState(null);
        setActionFocus(null);
        setRightPhase({ rowKey: null, phase: 0 });
        setInstrSettingsStage(1);
        setIdx(autoSelect ? (newPath.length === 1 ? 0 : 1) : 0);
      }, []);

      const createNewAgent = useCallback((name) => {
        const id = 'agent-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'agent', input: '', output: '', modules: [] });
        navigateToPath([id], true);
      }, [store, navigateToPath]);

      const createNewModule = useCallback((name, attachToAgentId, insertPos = null) => {
        const id = 'mod-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'mod', items: [] });
        attachModuleToAgent(attachToAgentId, id, insertPos);
      }, [store, attachModuleToAgent]);

      const createNewInstruction = useCallback((name, toModuleId, insertPos = null) => {
        const id = 'custom-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'instr', text: '' });
        addInstructionToModule(toModuleId, id, insertPos);
      }, [store, addInstructionToModule]);

      const removeInstructionAtPos = useCallback((pos) => {
        if (!atModule || !module) return;
        const arr = store.get(`items-${module.name}`, module.items || []);
        updateData(`items-${module.name}`, arr.filter((_, i) => i !== pos));
      }, [atModule, module, store, updateData]);

      const removeModuleAtPos = useCallback((pos) => {
        const a = store.getDbItem(path[0]); if (!a) return;
        const arr = store.get(`mods-${a.name}`, a.modules || []);
        updateData(`mods-${a.name}`, arr.filter((_, i) => i !== pos));
      }, [store, updateData, path]);

      const duplicateItem = useCallback((dbId, isModule, insertAtPos = null) => {
        const item = store.getDbItem(dbId); if (!item) return;
        if (isModule) {
          const a = store.getDbItem(path[0]); if (!a) return;
          const arr = store.get(`mods-${a.name}`, a.modules || []);
          const newArr = [...arr];
          const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
          newArr.splice(at, 0, dbId); updateData(`mods-${a.name}`, newArr);
        } else {
          if (!module) return;
          const arr = store.get(`items-${module.name}`, module.items || []);
          const newId = 'custom-' + Date.now();
          const baseName = displayNameFor(store, item, dbId);
          const baseText = store.get(`t-${item.name}`, item.text || '');
          store.addCustomDbItem(newId, { name: baseName + ' (copy)', type: 'instr', text: baseText });
          const newArr = [...arr];
          const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
          newArr.splice(at, 0, newId); updateData(`items-${module.name}`, newArr);
          updateData(`nn-${newId}`, baseName + ' (copy)'); updateData(`t-${newId}`, baseText); setStoreVersion(store.getVersion());
        }
      }, [store, updateData, path, module]);

      const getActionList = (row) => {
        if (row.type === 'module-item') return ['move','settings','duplicate','delete'];
        if (row.type === 'instr') return ['settings','move','duplicate','delete'];
        return [];
      };

      // MOVE MODE — snapshot-based and persistent
      const startMove = useCallback((row) => {
        const itemId = row.dbId || row.moduleId;
        let arrKey = null;
        let arr = [];
        if (row.type === 'instr') {
          if (!module) return;
          arrKey = `items-${module.name}`;
          arr = store.get(arrKey, module.items || []);
        } else if (row.type === 'module-item') {
          const a = store.getDbItem(path[0]); if (!a) return;
          arrKey = `mods-${a.name}`;
          arr = store.get(arrKey, a.modules || []);
        } else { return; }
        setReorderState({
          rowKey: row.key,
          itemId,
          type: row.type,
          arrKey,
          originalOrder: [...arr],
          originalPos: row.pos,
          currentPos: row.pos
        });
      }, [store, path, module]);

      const moveItemInReorderMode = useCallback((direction) => {
        if (!reorderState) return;
        const arr = store.get(reorderState.arrKey, []);
        const delta = direction === 'up' ? -1 : 1;
        const from = reorderState.currentPos;
        const to = from + delta;
        if (to < 0 || to >= arr.length) return;
        const newArr = moveInList(arr, from, to);
        updateData(reorderState.arrKey, newArr);
        setReorderState(prev => ({ ...prev, currentPos: to }));
        // keep action focus pinned
        if (reorderState.type === 'instr') {
          setActionFocus(prev => prev ? { ...prev, rowKey: `ins:${reorderState.itemId}`, action: 'move' } : prev);
        } else {
          setActionFocus(prev => prev ? { ...prev, rowKey: `mod:${reorderState.itemId}:${to}`, action: 'move' } : prev);
        }
      }, [reorderState, store, updateData]);

      const commitReorder = useCallback(() => {
        if (!reorderState) return;
        const { type, itemId, currentPos } = reorderState;
        setReorderState(null);
        setTimeout(() => {
          const targetIdx = rowsRef.current.findIndex(r =>
            (type === 'instr' ? r.type === 'instr' : r.type === 'module-item') &&
            ((type === 'instr' ? r.dbId : r.moduleId) === itemId) &&
            r.pos === currentPos
          );
          if (targetIdx >= 0) setIdx(targetIdx);
        }, 0);
      }, [reorderState]);

      const cancelReorder = useCallback(() => {
        if (!reorderState) return;
        const { arrKey, originalOrder, type, itemId, originalPos } = reorderState;
        updateData(arrKey, originalOrder);
        setReorderState(null);
        setTimeout(() => {
          const targetIdx = rowsRef.current.findIndex(r =>
            (type === 'instr' ? r.type === 'instr' : r.type === 'module-item') &&
            ((type === 'instr' ? r.dbId : r.moduleId) === itemId) &&
            r.pos === originalPos
          );
          if (targetIdx >= 0) setIdx(targetIdx);
        }, 0);
      }, [reorderState, updateData]);

      const executeRowAction = useCallback((row, action) => {
        if (!row) return;
        if (action === 'move') return;
        if (row.type === 'module-item') {
          if (action === 'settings') { /* show settings panel */ return; }
          if (action === 'duplicate') { commitReorder(); duplicateItem(row.moduleId, true, row.pos + 1); return; }
          if (action === 'delete') { commitReorder(); removeModuleAtPos(row.pos); setActionFocus(null); return; }
        }
        if (row.type === 'instr') {
          if (action === 'settings') { /* handled by panel render */ return; }
          if (action === 'duplicate') { commitReorder(); duplicateItem(row.dbId, false, row.pos + 1); return; }
          if (action === 'delete') { commitReorder(); removeInstructionAtPos(row.pos); setActionFocus(null); return; }
        }
      }, [duplicateItem, removeInstructionAtPos, removeModuleAtPos, commitReorder]);

      // Visible text for right sidebar (modules => one-line per instruction)
      const rightSidebarText = useMemo(() => {
        if (!agent) return '';
        const mods = store.get(`mods-${agent.name}`, agent.modules || []);
        const lines = [];
        mods.forEach(mid => {
          const m = store.getDbItem(mid); if (!m) return;
          lines.push(`Module: ${displayNameFor(store, m, mid)}`);
          const ids = store.get(`items-${m.name}`, m.items || []);
          ids.forEach((iid, idx) => {
            const it = store.getDbItem(iid); if (!it) return;
            const one = store.get(`t-${it.name}`, it.text || '').split(/\r?\n/)[0];
            const prefix = (idx === ids.length - 1) ? 'OUTPUT:' : '-';
            lines.push(`  ${prefix} ${displayNameFor(store, it, iid)} — ${one}`);
          });
          lines.push('');
        });
        return lines.join('\n');
      }, [storeVersion, agent, store]);

      // Omnisearch source data
      const db = store.getAllDb();
      const agentModules = useMemo(() => agent ? (store.get(`mods-${agent.name}`, agent.modules || [])) : [], [store, agent]);

      const omniResults = useMemo(() => {
        const q = (omniQuery || '').toLowerCase().trim();
        const out = [];
        const push = (r) => out.push(r);
        // Current project modules/instructions
        agentModules.forEach(mid => {
          const m = db[mid]; if (!m) return;
          if (!q || (m.name || '').toLowerCase().includes(q)) push({ type: 'mod', id: mid, name: m.name, scope: 'current' });
          const items = store.get(`items-${m.name}`, m.items || []);
          items.forEach(iid => {
            const ins = db[iid]; if (!ins) return;
            const iname = displayNameFor(store, ins, iid);
            const text = store.get(`t-${ins.name}`, ins.text || '');
            const hay = (iname + ' ' + text).toLowerCase();
            if (!q || hay.includes(q)) push({ type: 'instr', id: iid, name: iname, scope: 'current' });
          });
        });
        // Library
        Object.keys(db).forEach(id => {
          const it = db[id];
          if (it.type === 'mod' || it.type === 'instr') {
            const hay = ((it.name||'') + ' ' + (it.text||'')).toLowerCase();
            if (!q || hay.includes(q)) {
              const dup = out.find(r => r.type===it.type && r.id===id);
              if (!dup) push({ type: it.type, id, name: it.name, scope: 'library' });
            }
          }
        });
        return out;
      }, [omniQuery, db, agentModules, store, storeVersion]);

      const actOnOmniRow = useCallback((r) => {
        if (!omniTarget) { setOmniActive(false); return; }
        if (r.type === 'mod' && omniTarget.kind === 'mod') {
          attachModuleToAgent(omniTarget.agentId, r.id, omniTarget.insertPos ?? null);
        } else if (r.type === 'instr' && omniTarget.kind === 'instr') {
          addInstructionToModule(omniTarget.moduleId, r.id, omniTarget.insertPos ?? null);
        } else if (r.type === 'create-mod' && omniTarget.kind === 'mod') {
          createNewModule(omniQuery.trim(), omniTarget.agentId, omniTarget.insertPos ?? null);
        } else if (r.type === 'create-instr' && omniTarget.kind === 'instr') {
          createNewInstruction(omniQuery.trim(), omniTarget.moduleId, omniTarget.insertPos ?? null);
        }
        setOmniActive(false);
      }, [omniTarget, attachModuleToAgent, addInstructionToModule, createNewModule, createNewInstruction, omniQuery]);

      // Keyboard handling
      const handleKeyDown = useCallback((e) => {
        // Universal add dock with '+'
        if (e.key === '+') {
          e.preventDefault();
          const sel = rowsRef.current[idx];
          if (!sel) return;
          if (sel.type === 'module-item' || atAgent) {
            const pos = computeInsertPosModules();
            setOmniTarget({ kind: 'mod', agentId: path[0], insertPos: pos });
            setOmniActive(true); setOmniQuery(''); setOmniIndex(0);
            setTimeout(()=>{ omniInputRef.current && omniInputRef.current.focus(); }, 0);
          } else if (sel.type === 'instr' || sel.type === 'adder-instr' || atModule) {
            const pos = computeInsertPosInstr();
            setOmniTarget({ kind: 'instr', moduleId: path[path.length - 1], insertPos: pos });
            setOmniActive(true); setOmniQuery(''); setOmniIndex(0);
            setTimeout(()=>{ omniInputRef.current && omniInputRef.current.focus(); }, 0);
          }
          return;
        }

        if (omniActive) return;

        const rows = rowsRef.current;
        const sel = rows[idx]; if (!sel) return;

        // If settings are open and user presses Down, focus first editable field
        if (actionFocus && actionFocus.rowKey === sel.key && actionFocus.action === 'settings' && e.key === 'ArrowDown') {
          e.preventDefault();
          const host = document.querySelector(`[data-settings-for="${sel.key}"]`);
          if (host) {
            const el = host.querySelector('textarea, input');
            if (el) el.focus();
          }
          return;
        }

        // In action mode
        const inActionForSel = actionFocus && actionFocus.rowKey === sel.key;
        if (inActionForSel) {
          const list = getActionList(sel);
          const ci = Math.max(0, list.indexOf(actionFocus.action));

          if (e.key === 'ArrowUp') { e.preventDefault(); if (actionFocus.action === 'move') moveItemInReorderMode('up'); return; }
          if (e.key === 'ArrowDown') { e.preventDefault(); if (actionFocus.action === 'move') moveItemInReorderMode('down'); return; }

          if (e.key === 'ArrowRight') {
            e.preventDefault();
            if (actionFocus.action === 'settings' && sel.type === 'instr') {
              if (instrSettingsStage === 1) { setInstrSettingsStage(2); return; }
            }
            const next = list[(ci + 1) % list.length];
            if (actionFocus.action === 'move' && next !== 'move') commitReorder();
            if (actionFocus.action !== 'move' && next === 'move') startMove(sel);
            setActionFocus({ rowKey: sel.key, action: next });
            if (next === 'settings' && sel.type === 'instr') setInstrSettingsStage(1);
            return;
          }

          if (e.key === 'ArrowLeft') {
            e.preventDefault();
            if (actionFocus.action === 'settings' && sel.type === 'instr') {
              setActionFocus(null);
              setRightPhase({ rowKey: sel.key, phase: 1 });
              setInstrSettingsStage(1);
              return;
            }
            if (ci === 0) {
              if (reorderState) commitReorder();
              setActionFocus(null);
              setRightPhase({ rowKey: null, phase: 0 });
              return;
            }
            const prev = list[ci - 1];
            if (prev === 'move' && actionFocus.action !== 'move') startMove(sel);
            setActionFocus({ rowKey: sel.key, action: prev });
            if (prev === 'settings' && sel.type === 'instr') setInstrSettingsStage(1);
            return;
          }

          if (e.key === 'Enter') { e.preventDefault(); executeRowAction(sel, actionFocus.action); return; }
          if (e.key === 'Escape') { e.preventDefault(); if (actionFocus.action === 'move' && reorderState) cancelReorder(); setActionFocus(null); setRightPhase({ rowKey: null, phase: 0 }); setInstrSettingsStage(1); return; }
        }

        // Right-driven for instructions
        if (e.key === 'ArrowRight' && sel.type === 'instr') {
          e.preventDefault();
          if (!(rightPhase.rowKey === sel.key && rightPhase.phase === 1) && !actionFocus) { setRightPhase({ rowKey: sel.key, phase: 1 }); return; }
          if (!actionFocus) { setActionFocus({ rowKey: sel.key, action: 'settings' }); setInstrSettingsStage(1); return; }
        }

        // Left-driven for modules to enter action mode (Move first)
        if (e.key === 'ArrowLeft' && sel.type === 'module-item') {
          e.preventDefault();
          startMove(sel);
          setActionFocus({ rowKey: sel.key, action: 'move' });
          setRightPhase({ rowKey: null, phase: 0 });
          return;
        }

        // Default navigation and drill
        const gotoIndex = (n) => { setActionFocus(null); setRightPhase({ rowKey: null, phase: 0 }); setIdx(n); };

        if (e.key === 'ArrowUp') { e.preventDefault(); gotoIndex(Math.max(0, idx - 1)); return; }
        if (e.key === 'ArrowDown') { e.preventDefault(); gotoIndex(Math.min(rows.length - 1, idx + 1)); return; }

        if (e.key === 'ArrowRight' && sel.type === 'module-item') {
          e.preventDefault();
          setNavHistory(h => ({ ...h, [path[0]]: idx }));
          setPath([...path, sel.moduleId]);
          setIdx(1);
          return;
        }

        if (e.key === 'Enter') {
          e.preventDefault();
          if (sel.type === 'adder-instr') {
            const pos = computeInsertPosInstr();
            openOmniAddAt({ kind: 'instr', moduleId: path[path.length - 1], insertPos: pos });
            return;
          }
          if (sel.type === 'adder-mod') {
            const pos = computeInsertPosModules();
            openOmniAddAt({ kind: 'mod', agentId: path[0], insertPos: pos });
            return;
          }
        }

        if (e.key === 'Escape') {
          e.preventDefault();
          if (actionFocus && actionFocus.action === 'move' && reorderState) { cancelReorder(); setActionFocus(null); return; }
          if (actionFocus) { setActionFocus(null); return; }
          if (path.length > 1) {
            const newPath = path.slice(0, -1);
            const savedIdx = navHistory[newPath[0]];
            setPath(newPath);
            setIdx(Number.isFinite(savedIdx) ? savedIdx : 0);
            return;
          }
        }
      }, [
        idx, path, atAgent, atModule,
        omniActive, computeInsertPosModules, computeInsertPosInstr, openOmniAddAt,
        actionFocus, rightPhase, instrSettingsStage,
        startMove, moveItemInReorderMode, commitReorder, cancelReorder, executeRowAction,
        reorderState
      ]);

      useEffect(() => { window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [handleKeyDown]);

      // Click selection handlers
      const handleLineClick = useCallback((row, i) => {
        setIdx(i);
        if (row.type === 'adder-mod') {
          const pos = computeInsertPosModules();
          openOmniAddAt({ kind: 'mod', agentId: path[0], insertPos: pos });
        }
        if (row.type === 'adder-instr') {
          const pos = computeInsertPosInstr();
          openOmniAddAt({ kind: 'instr', moduleId: path[path.length - 1], insertPos: pos });
        }
      }, [computeInsertPosModules, computeInsertPosInstr, openOmniAddAt, path]);

      useEffect(() => {
        const hash = '#' + path.join('/'); if (window.location.hash !== hash) window.history.pushState(null, '', hash);
        if (!window.location.hash) setIdx(path.length === 1 ? 0 : 1);
      }, [path]);

      useEffect(() => {
        const handlePopState = () => {
          const hash = window.location.hash.slice(1);
          if (hash) {
            const parts = hash.split('/').filter(Boolean);
            if (parts.length > 0) navigateToPath(parts, true);
          } else navigateToPath(['expert-maker'], true);
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, [navigateToPath]);

      // Combined prompt (multi-line, one per instruction) already computed for sidebar

      return (
        <div className="layout">
          <div className="container">
            <div className="panel">
              {rows.map((row, i) => {
                const isSelected = i === idx;
                const isDragging = dragItem && dragItem.key === row.key;
                const isDropTarget = dragOver === row.key;
                const inActionMode = actionFocus && actionFocus.rowKey === row.key;
                const showRightBar = rightPhase.rowKey === row.key && rightPhase.phase === 1 && row.type === 'instr' && isSelected;

                const actions = getActionList(row);
                const focused = inActionMode ? actionFocus.action : null;

                return (
                  <React.Fragment key={row.key}>
                    <div
                      className={[
                        'line',
                        isSelected ? 'sel' : '',
                        isDragging ? 'held' : '',
                        isDropTarget ? 'drop-target' : ''
                      ].join(' ').trim()}
                      style={{ paddingLeft: (row.depth || 0) * TAB }}
                      data-key={row.key}
                      onClick={() => handleLineClick(row, i)}
                      draggable={row.type==='instr' || row.type==='module-item'}
                      onDragStart={e => { if (row.type==='instr' || row.type==='module-item') setDragItem(row); }}
                      onDragOver={e => {
                        if (row.type==='instr' || row.type==='module-item') {
                          e.preventDefault(); if (!dragItem) return; setDragOver(row.key);
                        }
                      }}
                      onDrop={e => {
                        if (!(row.type==='instr' || row.type==='module-item')) return;
                        e.preventDefault();
                        if (!dragItem) return;
                        if (dragItem.type === 'instr' && row.type === 'instr' && module) {
                          const arr = store.get(`items-${module.name}`, module.items || []); updateData(`items-${module.name}`, moveInList(arr, dragItem.pos, row.pos));
                        } else if (dragItem.type === 'module-item' && row.type === 'module-item') {
                          const a = store.getDbItem(path[0]); if (a) {
                            const arr = store.get(`mods-${a.name}`, a.modules || []); updateData(`mods-${a.name}`, moveInList(arr, dragItem.pos, row.pos));
                          }
                        }
                        setDragItem(null); setDragOver(null);
                      }}
                      onDragEnd={() => { setDragItem(null); setDragOver(null); }}
                    >
                      {(row.type === 'instr' || row.type === 'module-item') && (
                        <span
                          className="hover-settings"
                          onClick={(e) => {
                            e.stopPropagation();
                            setIdx(i);
                            if (row.type === 'instr') {
                              setRightPhase({ rowKey: row.key, phase: 1 });
                              setActionFocus({ rowKey: row.key, action: 'settings' });
                              setInstrSettingsStage(1);
                            } else {
                              setActionFocus({ rowKey: row.key, action: 'settings' });
                            }
                          }}
                          title="Open Settings"
                        >[→] Settings</span>
                      )}

                      <span className="left-span">
                        {isSelected && (inActionMode || showRightBar)
                          ? (
                            <InlineActionsInline
                              actions={actions}
                              focus={focused || null}
                              onFocus={(a) => {
                                if (focused === 'move' && a !== 'move') commitReorder();
                                if (focused !== 'move' && a === 'move') startMove(row);
                                setActionFocus({ rowKey: row.key, action: a });
                                if (a === 'settings' && row.type === 'instr') setInstrSettingsStage(1);
                              }}
                              onExecute={(a) => executeRowAction(row, a)}
                              onBack={() => { if (reorderState) commitReorder(); setActionFocus(null); setRightPhase({ rowKey: null, phase: 0 }); }}
                            />
                          ) : (
                            <>
                              {row.isOutput ? <strong>OUTPUT:&nbsp;</strong> : null}{row.label}
                            </>
                          )
                        }
                      </span>
                    </div>

                    {/* Instruction settings panel (Stage 1/2) */}
                    {isSelected && inActionMode && actionFocus.action === 'settings' && row.type === 'instr' && (
                      <InstructionEdit
                        store={store}
                        row={row}
                        onTextChange={updateData}
                        getNameOverride={(k, f) => store.get(k, f || '')}
                        setNameOverride={(k, v) => updateData(k, v)}
                        getMeta={(k) => store.get(k, '')}
                        setMeta={(k, v) => updateData(k, v)}
                        getStruct={(k) => store.get(k, 'heavy')}
                        setStruct={(k, v) => updateData(k, v)}
                        stage={instrSettingsStage}
                        settingsKey={row.key}
                        refEl={(el)=>{ if (el) settingsRefs.current.set(row.key, el); else settingsRefs.current.delete(row.key); }}
                      />
                    )}

                    {/* Module settings panel */}
                    {isSelected && inActionMode && actionFocus.action === 'settings' && row.type === 'module-item' && (
                      <div className="indent-block" style={{ paddingLeft: ((row.depth || 0) + 1) * TAB }} data-settings-for={row.key}>
                        <input
                          type="text"
                          className="underline-input"
                          value={store.get(row.nameOverrideKey, '')}
                          onChange={(e) => updateData(row.nameOverrideKey, e.target.value)}
                          placeholder="Name…"
                        />
                        <textarea
                          className="underline-textarea"
                          value={store.get(row.metaKey, '')}
                          onChange={(e) => updateData(row.metaKey, e.target.value)}
                          placeholder="Meta information…"
                        />
                        <textarea
                          className="underline-textarea"
                          value={store.get(`prompt-mod-${row.moduleId}`, '')}
                          onChange={(e) => updateData(`prompt-mod-${row.moduleId}`, e.target.value)}
                          placeholder="Module instruction…"
                        />
                        <StructureDots5
                          id={row.moduleId}
                          value={store.get(row.structKey, 'heavy')}
                          onChange={(v) => updateData(row.structKey, v)}
                        />
                      </div>
                    )}

                    {/* Previews when not in action mode */}
                    {isSelected && !inActionMode && row.type === 'module-item' && (
                      <ModulePreview store={store} moduleId={row.moduleId} depth={row.depth} />
                    )}
                    {isSelected && !inActionMode && row.type === 'instr' && (
                      <InstructionPreview store={store} row={row} />
                    )}
                  </React.Fragment>
                );
              })}
            </div>

            {/* Bottom Add Dock (Omnisearch) */}
            <div className="bottom-dock">
              <button className="dock-toggle" title="Add" onClick={() => {
                // open in context of current selection
                const rows = rowsRef.current; const sel = rows[idx];
                if (!sel) return;
                if (sel.type === 'module-item' || atAgent) {
                  const pos = computeInsertPosModules();
                  openOmniAddAt({ kind: 'mod', agentId: path[0], insertPos: pos });
                } else {
                  const pos = computeInsertPosInstr();
                  openOmniAddAt({ kind: 'instr', moduleId: path[path.length - 1], insertPos: pos });
                }
              }}>[+] Add</button>

              {omniActive && (
                <div className="dock">
                  <div style={{ margin: '4px 6px 8px 6px', fontSize: 12 }}>Add mode • Items will be inserted at the current position</div>
                  <div className="omni-list">
                    {omniResults.length === 0 && (<div className="omni-item"><span>No matches</span></div>)}
                    {omniResults.map((r, i) => (
                      <div
                        key={r.type + ':' + r.id + ':' + i}
                        className={`omni-item${i === omniIndex ? ' sel' : ''}`}
                        onMouseEnter={() => setOmniIndex(i)}
                        onClick={() => actOnOmniRow(r)}
                      >
                        <span>{r.name}</span>
                        <span className="badge">{r.type}{r.scope ? ` • ${r.scope}` : ''}</span>
                      </div>
                    ))}
                  </div>
                  <input
                    ref={omniInputRef}
                    className="omni-input"
                    placeholder="Type to filter…  ↑/↓ select • Enter add • Esc close"
                    value={omniQuery}
                    onChange={e => setOmniQuery(e.target.value)}
                    onKeyDown={(e) => {
                      const has = omniResults.length > 0;
                      if (e.key === 'ArrowDown') { e.preventDefault(); if (has) setOmniIndex(prev => Math.min(omniResults.length - 1, prev + 1)); }
                      else if (e.key === 'ArrowUp') { e.preventDefault(); if (has) setOmniIndex(prev => Math.max(0, prev - 1)); }
                      else if (e.key === 'Enter') { e.preventDefault(); if (has) actOnOmniRow(omniResults[Math.max(0, Math.min(omniIndex, omniResults.length - 1))]); }
                      else if (e.key === 'Escape') { e.preventDefault(); setOmniActive(false); }
                    }}
                  />
                </div>
              )}
            </div>
          </div>

          {/* Right Sidebar */}
          <RightSidebar text={rightSidebarText} />
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div class="error">Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
