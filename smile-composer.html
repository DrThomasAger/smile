<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Smile Composer — Preview + Settings Flow</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { --tab: 32px; --panel-radius: 10px; --soft-bg: #fafafa; --hover-bg: #f6f6f6; --select-bg: #f2f2f2; --rule: rgba(0,0,0,0.08); }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif; background: #fff; color: #111; padding: 24px; margin: 0; }
    .container { display: block; width: 100%; }

    .panel { background: #fff; border-radius: var(--panel-radius); padding: 16px; border: none; box-shadow: 0 1px 0 0 var(--rule); margin-top: 20px; }
    .panel-title { font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap; cursor: default; }
    .panel-title .clickable { cursor: pointer; }
    .panel-title-right { display: inline-flex; align-items: center; gap: 8px; }
    .panel-subtle { font-size: 12px; color: #666; }

    .omni { position: sticky; top: 0; z-index: 10; background: #fff; padding: 8px 0 0 0; margin-bottom: 8px; }
    .omni-bar { display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; padding: 10px 12px; border-radius: 999px; background: var(--soft-bg); box-shadow: 0 1px 0 0 var(--rule); }
    .omni-input { border: none; outline: none; background: transparent; font: inherit; padding: 6px 2px; }
    .omni-mode { display: inline-flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 999px; background: #fff; visibility: hidden; }
    .omni-mode.show { visibility: visible; }
    .omni-mode button { font: inherit; background: transparent; border: none; padding: 6px 10px; border-radius: 999px; cursor: pointer; }
    .omni-mode .active { background: var(--select-bg); font-weight: 600; }
    .omni-drawer { margin-top: 8px; border-radius: 12px; padding: 8px; background: #fff; }
    .omni-list { max-height: 320px; overflow: auto; display: grid; gap: 6px; }
    .omni-item { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; background: var(--soft-bg); border-radius: 12px; cursor: pointer; }
    .omni-item:hover { background: var(--hover-bg); }
    .omni-item.sel { background: var(--select-bg); font-weight: 600; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; background: #eee; }
    .subtle { font-size: 12px; color: #666; }

    .line { user-select: none; padding: 8px 10px; border-radius: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; cursor: pointer; transition: background-color 0.12s ease, opacity 0.12s ease; touch-action: none; position: relative; }
    .line:hover { background-color: var(--hover-bg); }
    .line.sel { font-weight: 600; background-color: var(--select-bg); }
    .line.reorder-mode { font-weight: 700; background-color: #eee; }
    .line.held { opacity: 0.35; }
    .line.drop-target { outline: 3px solid #111; outline-offset: -3px; border-radius: 12px; }
    .left-span { flex: 1 1 auto; min-width: 0; }
    .right-actions { flex: 0 0 auto; display: inline-flex; gap: 6px; }
    .action-cluster { opacity: 0; pointer-events: none; transition: opacity 0.12s ease; }
    .line:hover .action-cluster, .line.sel .action-cluster { opacity: 1; pointer-events: auto; }

    .indent-block { margin-top: 8px; }
    .indent-grid { display: grid; gap: 10px; }

    .underline-input, .underline-textarea { width: 100%; background: transparent; border: none; border-bottom: 1px solid #ccc; border-radius: 0; padding: 6px 2px 6px 0; font: inherit; outline: none; resize: vertical; min-height: 34px; }
    .underline-textarea { min-height: 80px; }

    .btn { font: inherit; border: none; background: #fff; padding: 6px 12px; border-radius: 999px; cursor: pointer; font-size: 12px; box-shadow: 0 1px 0 0 var(--rule); white-space: nowrap; }
    .btn.sel { font-weight: 700; background: var(--select-bg); }
    .btn + .btn { margin-left: 6px; }

    .tree-view { max-height: 500px; overflow: auto; font-size: 13px; line-height: 1.8; }
    .tree-item { padding: 6px 8px; cursor: pointer; user-select: none; border-radius: 8px; }
    .tree-item:hover { background: var(--hover-bg); }
    .tree-item.active { font-weight: 700; background: var(--select-bg); }

    .error { color: red; padding: 20px; border: 1px solid red; margin: 20px; border-radius: 8px; }

    .seg { display: inline-flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 999px; background: var(--soft-bg); }
    .seg .label { font-size: 12px; margin-right: 4px; }
    .seg input[type="radio"] { position: absolute; opacity: 0; pointer-events: none; }
    .seg .opt { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; }
    .seg .dot { width: 8px; height: 8px; border-radius: 50%; background: #bbb; display: inline-block; }
    .seg input[type="radio"]:checked + .opt .dot { background: #111; }

    .alltext { width: 100%; min-height: 220px; padding: 10px; border: none; border-bottom: 1px solid #ccc; border-radius: 0; resize: vertical; background: #fff; }

    /* Preview colors */
    .c-red { color: #c62828; font-weight: 600; }
    .c-green { color: #2e7d32; }
    .c-blue { color: #1565c0; }
    .preview-block { padding-left: var(--tab); }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div class="error">Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useCallback, useMemo } = React;
    const TAB = 32;

    const INITIAL_DB = {
      'expert-maker': { name: 'Expert Maker', type: 'agent', input: 'Question', output: 'Answer', modules: ['meta-info', 'jargon-cot', 'identify-mistakes'] },
      'input-mod': { name: 'INPUT: Question', type: 'mod', items: ['input-enter', 'input-understand', 'input-result'] },
      'output-mod': { name: 'OUTPUT: Answer', type: 'mod', items: ['output-enter', 'output-understand', 'output-result'] },
      'meta-info': { name: 'Meta-Information MegaBrick', type: 'mod', items: ['smile-info', 'llm-info', 'user-info'] },
      'jargon-cot': { name: 'Jargon CoT', type: 'mod', items: ['emoji-section', 'bold-words', 'top-bottom'] },
      'identify-mistakes': { name: 'Identify Mistakes and Rewrite', type: 'mod', items: ['emoji-section', 'bold-words', 'negative-rewrite'] },
      'smile-info': { name: 'Information About (: Smile', type: 'instr', text: 'Explain Smile syntax: (: flexible, [: rigid, [= literal.' },
      'llm-info': { name: 'Information About LLMs', type: 'instr', text: 'Meta-knowledge about how LLMs process instructions.' },
      'user-info': { name: 'Information About User', type: 'instr', text: 'Contextualize user needs and goals.' },
      'emoji-section': { name: 'Emoji section name', type: 'instr', text: 'Use two emoticons for section names.' },
      'bold-words': { name: 'Bold for important words', type: 'instr', text: 'Use **bold** for attention retention over long contexts.' },
      'top-bottom': { name: 'Maximize adherence through top+bottom replication', type: 'instr', text: 'Replicate critical instructions at beginning and end.' },
      'negative-rewrite': { name: 'Identify negatives and rewrite to positive', type: 'instr', text: 'Find negatives like "not" and rewrite as positive articulations.' },
      'input-enter': { name: 'Provide Input', type: 'instr', text: 'Enter or paste the incoming question or payload in full fidelity.' },
      'input-understand': { name: 'Reasoning / Understanding', type: 'instr', text: 'Interpret the input; list goals, constraints, and ambiguities.' },
      'input-result': { name: 'Synthesis (Input + Understanding)', type: 'instr', text: 'Combine the raw input with the understanding into a structured representation.' },
      'output-enter': { name: 'Draft Output', type: 'instr', text: 'Produce an initial answer or output shape based on the current state.' },
      'output-understand': { name: 'Quality / Checks', type: 'instr', text: 'Reason about correctness, coverage, and criteria; refine the output.' },
      'output-result': { name: 'Final Output', type: 'instr', text: 'Deliver the polished final output after reasoning and checks.' }
    };

    class DataStore {
      constructor() { this.data = this.loadFromStorage(); this.db = { ...INITIAL_DB }; this.version = 0; }
      loadFromStorage() { try { const stored = localStorage.getItem('smileData'); return stored ? JSON.parse(stored) : {}; } catch(e){ return {}; } }
      saveToStorage(data) { try { localStorage.setItem('smileData', JSON.stringify(data)); } catch(e){} }
      get(key, def) { return key in this.data ? this.data[key] : def; }
      set(key, value) { this.data = { ...this.data, [key]: value }; this.version++; this.saveToStorage(this.data); return this.data; }
      reset() { this.data = {}; localStorage.removeItem('smileData'); this.db = { ...INITIAL_DB }; this.version++; return this.data; }
      getDbItem(id) { return this.db[id] || null; }
      addCustomDbItem(id, item) { this.db[id] = item; this.version++; }
      getAllDb() { return this.db; }
      getVersion() { return this.version; }
    }

    const moveInList = (arr, fromPos, toPos) => {
      if (fromPos === toPos || fromPos < 0 || toPos < 0 || fromPos >= arr.length) return arr;
      const newArr = [...arr];
      const [item] = newArr.splice(fromPos, 1);
      const insertPos = Math.min(toPos, newArr.length);
      newArr.splice(insertPos, 0, item);
      return newArr;
    };

    const displayNameFor = (store, dbItem, id) =>
      store.get(`nn-${id}`, store.get(`n-${dbItem.name}`, dbItem.name));

    const ownerKeyOfRow = (row) => {
      if (!row) return null;
      if (row.type === 'module-item') return `mod:${row.moduleId}`;
      if (row.type === 'instr') return `instr:${row.dbId}`;
      if (row.type === 'settings-panel') {
        return (row.ownerType === 'module') ? `mod:${row.ownerId}` : `instr:${row.ownerId}`;
      }
      return null;
    };

    /* ---------- Row Builder ---------- */
    class RowBuilder {
      constructor(store, path, reorderState, revealedOwnerKey, settingsOpen) {
        this.store = store;
        this.path = path;
        this.reorderState = reorderState;
        this.revealedOwnerKey = revealedOwnerKey || null;
        this.settingsOpen = settingsOpen || {};
        this.rows = [];
      }
      build() {
        this.addRoot(); this.addAgent(); this.addBreadcrumbs();
        if (this.isAtModule()) this.addModuleContent(); else this.addAgentModules();
        return this.rows;
      }
      addRoot() { this.rows.push({ key: 'root', type: 'root', depth: 0, label: '(: Smile Composer' }); }
      addAgent() {
        const agent = this.getAgent(); if (!agent) return;
        this.rows.push({ key: `agent:${this.path[0]}`, type: 'agent', depth: 1, label: this.store.get(`n-${agent.name}`, agent.name) });
      }
      addBreadcrumbs() {
        if (this.path.length <= 2) return;
        for (let i = 1; i < this.path.length - 1; i++) {
          const breadcrumbMod = this.store.getDbItem(this.path[i]); if (!breadcrumbMod) continue;
          this.rows.push({ key: `breadcrumb:${i}`, type: 'breadcrumb', depth: i + 1, label: this.store.get(`n-${breadcrumbMod.name}`, breadcrumbMod.name), pathIndex: i });
        }
      }
      addModuleContent() {
        const module = this.getCurrentModule(); if (!module) return;
        const moduleDBKey = this.path[this.path.length - 1];

        this.rows.push({ key: `module:${moduleDBKey}`, type: 'module', depth: 2, label: this.store.get(`n-${module.name}`, module.name), moduleId: moduleDBKey });

        const items = this.store.get(`items-${module.name}`, module.items || []);
        const visualItems = items.map((item, idx) => ({ item, originalPos: idx }));

        visualItems.forEach(({ item: id, originalPos }, i) => {
          const ins = this.store.getDbItem(id); if (!ins) return;
          const isLast = i === visualItems.length - 1;
          this.rows.push({
            key: `ins:${id}:${originalPos}`, type: 'instr', depth: 3,
            label: displayNameFor(this.store, ins, id), isOutput: isLast,
            nameKey: `n-${ins.name}`, nameOverrideKey: `nn-${id}`,
            textKey: `t-${ins.name}`, defaultText: ins.text || '',
            metaKey: `meta-${id}`, structKey: `struct-${id}`,
            promptKey: `t-${ins.name}`, dbId: id, pos: originalPos, canReorder: true
          });
        });
      }
      addAgentModules() {
        const agent = this.getAgent(); if (!agent) return;
        const modules = this.store.get(`mods-${agent.name}`, agent.modules || []);
        const visualModules = modules.map((item, idx) => ({ item, originalPos: idx }));

        visualModules.forEach(({ item: mid, originalPos }, i) => {
          const mod = this.store.getDbItem(mid); if (!mod) return;
          const isLast = i === visualModules.length - 1;
          this.rows.push({
            key: `mod:${mid}:${originalPos}`, type: 'module-item', depth: 2,
            label: displayNameFor(this.store, mod, mid), isOutput: isLast,
            nameKey: `n-${mod.name}`, nameOverrideKey: `nn-${mid}`,
            moduleId: mid, pos: originalPos, canReorder: true
          });
        });

        this.rows.push({ key: `adder-mod-${agent.name}`, type: 'adder-mod', depth: 2, label: '+ Add Module' });
      }
      isAtModule() { return this.path.length >= 2; }
      getAgent() { return this.store.getDbItem(this.path[0]); }
      getCurrentModule() { return this.isAtModule() ? this.store.getDbItem(this.path[this.path.length - 1]) : null; }
    }

    /* ---------- UI Components ---------- */
    function TreeView({ store, path, onNavigate, storeVersion }) {
      const renderModule = React.useCallback((modId, parentPath, depth) => {
        const mod = store.getDbItem(modId); if (!mod) return null;
        const modulePath = [...parentPath, modId];
        const isActive = path.join('/') === modulePath.join('/');
        const items = store.get(`items-${mod.name}`, mod.items || []);
        return (
          <div key={modId}>
            <div className={`tree-item${isActive ? ' active' : ''}`} style={{ paddingLeft: depth * 12 }} onClick={() => onNavigate(modulePath, true)}>
              {displayNameFor(store, mod, modId)}
            </div>
            {items.map(iid => {
              const ins = store.getDbItem(iid); if (!ins) return null;
              return (
                <div key={iid} className="tree-item" style={{ paddingLeft: (depth + 1) * 12 }}>
                  {displayNameFor(store, ins, iid)}
                </div>
              );
            })}
          </div>
        );
      }, [store, path, onNavigate, storeVersion]);

      const agentId = 'expert-maker';
      const agent = store.getDbItem(agentId); if (!agent) return null;
      const isAgentActive = path.length === 1 && path[0] === agentId;
      const modules = store.get(`mods-${agent.name}`, agent.modules || []);
      return (
        <div className="tree-view">
          <div className={`tree-item${isAgentActive ? ' active' : ''}`} onClick={() => onNavigate([agentId], true)}>
            {store.get(`n-${agent.name}`, agent.name)}
          </div>
          {modules.map(mid => renderModule(mid, [agentId], 1))}
        </div>
      );
    }

    function StructureDots5({ id, value, onChange }) {
      const opts = [
        { v: 'heavy', label: 'Heavy', aria: 'Heavy' },
        { v: 'heavy-mid', label: '●', aria: 'Between heavy and medium' },
        { v: 'medium', label: 'Medium', aria: 'Medium' },
        { v: 'medium-light', label: '●', aria: 'Between medium and light' },
        { v: 'light', label: 'Light', aria: 'Light' }
      ];
      return (
        <div className="seg" role="radiogroup" aria-label="Structure">
          <span className="label">Structure</span>
          {opts.map((o) => (
            <label key={o.v} title={o.aria}>
              <input type="radio" name={`struct-${id}`} value={o.v} checked={value === o.v} onChange={(e) => onChange(e.target.value)} />
              <span className="opt">
                {o.label === '●' ? <span className="dot" aria-hidden="true"></span> : <span style={{ fontSize: 12 }}>{o.label}</span>}
              </span>
            </label>
          ))}
        </div>
      );
    }

    const LABELS = {
      view: () => <strong>View Inside [Enter] [v]</strong>,
      move: () => 'Move',
      settings: () => 'Settings',
      duplicate: () => 'Duplicate',
      delete: () => 'Delete'
    };

    function ActionCluster({ row, actions, onActionExecute }) {
      return (
        <span className="right-actions action-cluster" onClick={(e) => e.stopPropagation()}>
          {actions.map((a) => (
            <button
              key={a}
              className="btn"
              onClick={() => onActionExecute(row, a)}
              title={a === 'view' ? 'View Inside' : a.charAt(0).toUpperCase() + a.slice(1)}
            >
              {LABELS[a]() }
            </button>
          ))}
        </span>
      );
    }

    function PreviewModuleContents({ store, moduleId }) {
      const mod = store.getDbItem(moduleId);
      if (!mod) return null;
      const items = store.get(`items-${mod.name}`, mod.items || []);
      return (
        <div className="indent-block preview-block" style={{ paddingLeft: TAB }}>
          {items.length === 0 ? <div className="subtle">Empty module</div> : items.map((iid) => {
            const ins = store.getDbItem(iid); if (!ins) return null;
            const nm = displayNameFor(store, ins, iid);
            const txt = store.get(`t-${ins.name}`, ins.text || '');
            return (
              <div key={iid} className="line" style={{ paddingLeft: 0 }}>
                <span className="left-span">{nm}</span>
                <span className="subtle" style={{ maxWidth: '50%', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                  {txt}
                </span>
              </div>
            );
          })}
        </div>
      );
    }

    function PreviewInstructionColored({ store, row }) {
      const dbItem = store.getDbItem(row.dbId);
      if (!dbItem) return null;
      const name = store.get(`nn-${row.dbId}`, displayNameFor(store, dbItem, row.dbId));
      const meta = store.get(`meta-${row.dbId}`, '');
      const body = store.get(row.promptKey, dbItem.text || '');
      return (
        <div className="indent-block preview-block" style={{ paddingLeft: TAB }}>
          <div className="line" style={{ paddingLeft: 0 }}>
            <span className="left-span">
              <span className="c-red">{name}</span>
            </span>
          </div>
          {meta ? (
            <div className="line" style={{ paddingLeft: 0 }}>
              <span className="left-span">
                <span className="c-green">{meta}</span>
              </span>
            </div>
          ) : null}
          <div className="line" style={{ paddingLeft: 0 }}>
            <span className="left-span">
              <span className="c-blue">{body}</span>
            </span>
          </div>
        </div>
      );
    }

    function LineRenderer({
      row, isSelected, inReorderMode, isDragging, isDropTarget,
      store, onLineClick, onTextChange,
      onDragStart, onDragOver, onDrop, onDragEnd,
      onTouchStartRow, onTouchMoveRow, onTouchEndRow,
      onActionExecute,
      getStruct, setStruct, setNameOverride, getNameOverride, getMeta, setMeta,
      setRowRef,
      isSettingsOpenFor
    }) {
      const classes = ['line'];
      if (isSelected && !inReorderMode) classes.push('sel');
      if (inReorderMode) classes.push('reorder-mode');
      if (isDragging) classes.push('held');
      if (isDropTarget) classes.push('drop-target');

      const style = { paddingLeft: (row.depth || 0) * TAB };
      const headingRef = useRef(null);
      useEffect(() => {
        if (row.type === 'settings-panel' && headingRef.current) {
          headingRef.current.focus();
          headingRef.current.select();
        }
      }, [row.type]);

      const canDragAnytime = (row.type === 'instr' || row.type === 'module-item');
      const actionsForRow = useMemo(() => {
        if (row.type === 'module-item') return ['view','move','settings','duplicate','delete'];
        if (row.type === 'instr') return ['move','settings','duplicate','delete'];
        return [];
      }, [row.type]);

      const settingsPanelForRow = (row.type === 'module-item' || row.type === 'instr') && isSettingsOpenFor(row);

      return (
        <div key={row.key}>
          <div
            ref={(el) => setRowRef && setRowRef(row.key, el)}
            className={classes.join(' ')}
            style={style}
            data-key={row.key}
            onClick={() => onLineClick(row)}
            draggable={canDragAnytime}
            onDragStart={e => canDragAnytime ? onDragStart(e, row) : null}
            onDragOver={e => canDragAnytime ? onDragOver(e, row) : null}
            onDrop={e => canDragAnytime ? onDrop(e, row) : null}
            onDragEnd={onDragEnd}
            onTouchStart={(e) => canDragAnytime ? onTouchStartRow(e, row) : null}
            onTouchMove={(e) => canDragAnytime ? onTouchMoveRow(e, row) : null}
            onTouchEnd={(e) => canDragAnytime ? onTouchEndRow(e, row) : null}
          >
            <span className="left-span">
              {row.isOutput ? <strong>OUTPUT:&nbsp;</strong> : null}{row.label}
            </span>
            {(row.type === 'module-item' || row.type === 'instr') && (
              <ActionCluster
                row={row}
                actions={actionsForRow}
                onActionExecute={onActionExecute}
              />
            )}
          </div>

          {/* Default PREVIEW when selected and settings closed */}
          {isSelected && !settingsPanelForRow && (row.type === 'module-item') && (
            <PreviewModuleContents store={store} moduleId={row.moduleId} />
          )}
          {isSelected && !settingsPanelForRow && (row.type === 'instr') && (
            <PreviewInstructionColored store={store} row={row} />
          )}

          {/* SETTINGS PANEL */}
          {settingsPanelForRow && (
            <div className="indent-block indent-grid" style={{ paddingLeft: (row.depth || 0) * TAB }}>
              <input
                ref={headingRef}
                type="text"
                className="underline-input"
                value={getNameOverride(row.nameOverrideKey, '')}
                onChange={(e) => setNameOverride(row.nameOverrideKey, e.target.value)}
                placeholder="Name…"
              />
              <textarea
                className="underline-textarea"
                value={getMeta(row.metaKey) || ''}
                onChange={(e) => setMeta(row.metaKey, e.target.value)}
                placeholder="Meta information…"
              />
              <textarea
                className="underline-textarea"
                value={store.get(row.promptKey, '')}
                onChange={(e) => onTextChange(row.promptKey, e.target.value)}
                placeholder={row.type === 'module-item' ? 'Module instruction…' : 'Instruction…'}
              />
              <StructureDots5
                id={row.type === 'module-item' ? row.moduleId : row.dbId}
                value={getStruct(row.structKey) || 'heavy'}
                onChange={(v) => setStruct(row.structKey, v)}
              />
            </div>
          )}
        </div>
      );
    }

    /* ---------- App ---------- */
    function App() {
      const storeRef = useRef(new DataStore());
      const store = storeRef.current;

      const [storeVersion, setStoreVersion] = useState(store.getVersion());
      const [path, setPath] = useState(() => {
        const hash = window.location.hash.slice(1);
        if (hash) { const parts = hash.split('/').filter(Boolean); if (parts.length > 0) return parts; }
        return ['expert-maker'];
      });

      const [idx, setIdx] = useState(0);
      const [navHistory, setNavHistory] = useState({});
      const [reorderState, setReorderState] = useState(null);
      const [dragItem, setDragItem] = useState(null);
      const [dragOver, setDragOver] = useState(null);

      const rowsDomRef = useRef(new Map());
      const [touchDrag, setTouchDrag] = useState(null);

      const [settingsOpen, setSettingsOpen] = useState({}); // map of spanel:mod|instr:ID => true

      const rows = useMemo(() => {
        const builder = new RowBuilder(store, path, reorderState, null, settingsOpen);
        return builder.build();
      }, [store, path, reorderState, settingsOpen, storeVersion]);

      const rowsRef = useRef(rows);
      useEffect(() => { rowsRef.current = rows; }, [rows]);

      const atAgent = path.length === 1;
      const atModule = path.length >= 2;
      const agent = store.getDbItem(path[0]) || store.getDbItem('expert-maker');
      const module = atModule ? store.getDbItem(path[path.length - 1]) : null;

      const updateData = useCallback((key, value) => { store.set(key, value); setStoreVersion(store.getVersion()); }, [store]);

      const openOmniAddModule = useCallback(() => {
        setOmniActive(true); setOmniMode('search'); setOmniQuery(''); setOmniIndex(0);
        setOmniFilterType('mod'); setOmniIntent('add-module');
      }, []);

      const resetAll = useCallback(() => {
        if (confirm('Reset everything to defaults? This will clear all your customizations.')) {
          store.reset();
          setPath(['expert-maker']); setIdx(2); setNavHistory({}); setReorderState(null);
          setSettingsOpen({});
          setOmniActive(false); setOmniQuery(''); setOmniIndex(0); setOmniMode('search'); setOmniFilterType(null); setOmniIntent(null);
          window.location.hash = ''; setStoreVersion(store.getVersion());
        }
      }, [store]);

      const navigateToPath = useCallback((newPath, autoSelect = true) => {
        setPath(newPath); setReorderState(null);
        setSettingsOpen({});
        setIdx(autoSelect ? (newPath.length === 1 ? 2 : 3) : 0);
      }, []);

      const addModuleToAgent = useCallback((moduleResult) => {
        const a = store.getDbItem(path[0]); if (!a) return;
        const key = `mods-${a.name}`;
        const arr = store.get(key, a.modules || []);
        const id = moduleResult.id || moduleResult;
        updateData(key, [...arr, id]);
      }, [store, updateData, path]);

      const attachModuleToAgent = useCallback((mid) => { addModuleToAgent({ id: mid }); }, [addModuleToAgent]);

      const openAndFocusSettings = useCallback((ownerType, ownerId) => {
        const panelKey = ownerType === 'module' ? `spanel:mod:${ownerId}` : `spanel:instr:${ownerId}`;
        setSettingsOpen(prev => ({ ...prev, [panelKey]: true }));
        setTimeout(() => {
          const i = rowsRef.current.findIndex(r =>
            (r.type === (ownerType === 'module' ? 'module-item' : 'instr')) &&
            ((ownerType === 'module' ? r.moduleId : r.dbId) === ownerId)
          );
          if (i >= 0) setIdx(i);
        }, 0);
      }, []);

      const addInstructionToModule = useCallback((instructionResult) => {
        if (!module) return;
        const arr = store.get(`items-${module.name}`, module.items || []);
        if (instructionResult.isNew) {
          const newId = 'custom-' + Date.now();
          store.addCustomDbItem(newId, { name: instructionResult.name, type: 'instr', text: '' });
          updateData(`items-${module.name}`, [...arr, newId]); setStoreVersion(store.getVersion());
          openAndFocusSettings('instr', newId);
        } else {
          const id = instructionResult.id || instructionResult;
          updateData(`items-${module.name}`, [...arr, id]);
        }
      }, [module, store, updateData, openAndFocusSettings]);

      const attachInstruction = useCallback((iid) => {
        if (atModule && module) {
          addInstructionToModule({ id: iid });
        } else {
          const a = store.getDbItem(path[0]); if (!a) return;
          const mods = store.get(`mods-${a.name}`, a.modules || []);
          if (mods.length === 0) {
            const newMid = 'mod-' + Date.now();
            store.addCustomDbItem(newMid, { name: 'Custom Module', type: 'mod', items: [] });
            updateData(`mods-${a.name}`, [newMid]);
            updateData(`items-Custom Module`, []);
            navigateToPath([path[0], newMid], true);
            setTimeout(() => { addInstructionToModule({ id: iid }); }, 0);
          } else {
            navigateToPath([path[0], mods[0]], true);
            setTimeout(() => { addInstructionToModule({ id: iid }); }, 0);
          }
        }
      }, [atModule, module, addInstructionToModule, store, updateData, path, navigateToPath]);

      const createNewAgent = useCallback((name) => {
        const id = 'agent-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'agent', input: '', output: '', modules: [] });
        navigateToPath([id], true);
      }, [store, navigateToPath]);

      const createNewModule = useCallback((name) => {
        const id = 'mod-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'mod', items: [] });
        attachModuleToAgent(id);
        navigateToPath([path[0], id], true);
        openAndFocusSettings('module', id);
      }, [store, attachModuleToAgent, navigateToPath, path, openAndFocusSettings]);

      const createNewInstruction = useCallback((name) => {
        const id = 'custom-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'instr', text: '' });
        if (atModule && module) {
          const arr = store.get(`items-${module.name}`, module.items || []);
          updateData(`items-${module.name}`, [...arr, id]);
          openAndFocusSettings('instr', id);
        } else {
          attachInstruction(id);
          openAndFocusSettings('instr', id);
        }
      }, [store, attachInstruction, atModule, module, updateData, openAndFocusSettings]);

      const removeItemById = useCallback((iid) => {
        if (!atModule || !module) return;
        const arr = store.get(`items-${module.name}`, module.items || []);
        const pos = arr.findIndex(x => x === iid);
        if (pos >= 0) updateData(`items-${module.name}`, arr.filter((_, i) => i !== pos));
      }, [atModule, module, store, updateData]);

      const removeModuleById = useCallback((mid) => {
        const a = store.getDbItem(path[0]); if (!a) return;
        const arr = store.get(`mods-${a.name}`, a.modules || []);
        updateData(`mods-${a.name}`, arr.filter(x => x !== mid));
      }, [store, updateData, path]);

      const duplicateItem = useCallback((dbId, isModule, insertAtPos = null) => {
        const item = store.getDbItem(dbId); if (!item) return;
        if (isModule) {
          const a = store.getDbItem(path[0]); if (!a) return;
          const arr = store.get(`mods-${a.name}`, a.modules || []);
          const newArr = [...arr];
          const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
          newArr.splice(at, 0, dbId); updateData(`mods-${a.name}`, newArr);
        } else {
          if (!module) return;
          const arr = store.get(`items-${module.name}`, module.items || []);
          const newId = 'custom-' + Date.now();
          const baseName = displayNameFor(store, item, dbId);
          const baseText = store.get(`t-${item.name}`, item.text || '');
          store.addCustomDbItem(newId, { name: baseName + ' (copy)', type: 'instr', text: baseText });
          const newArr = [...arr];
          const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
          newArr.splice(at, 0, newId); updateData(`items-${module.name}`, newArr);
          updateData(`nn-${newId}`, baseName + ' (copy)'); updateData(`t-${newId}`, baseText); setStoreVersion(store.getVersion());
        }
      }, [store, updateData, path, module]);

      const setRowRef = useCallback((key, el) => {
        if (!rowsDomRef.current) rowsDomRef.current = new Map();
        if (el) rowsDomRef.current.set(key, el); else rowsDomRef.current.delete(key);
      }, []);

      const isSettingsOpenFor = useCallback((row) => {
        if (row.type === 'module-item') return !!settingsOpen[`spanel:mod:${row.moduleId}`];
        if (row.type === 'instr') return !!settingsOpen[`spanel:instr:${row.dbId}`];
        return false;
      }, [settingsOpen]);

      /* Reorder (via Move button only) */
      const moveItemInReorderMode = useCallback((direction) => {
        if (!reorderState) return;
        const delta = direction === 'up' ? -1 : 1;
        const newCurrentPos = reorderState.currentPos + delta;

        let arr = [];
        if (reorderState.type === 'instr' && atModule && module) arr = store.get(`items-${module.name}`, module.items || []);
        else if (reorderState.type === 'module-item') {
          const a = store.getDbItem(path[0]); if (a) arr = store.get(`mods-${a.name}`, a.modules || []);
        }

        if (newCurrentPos >= 0 && newCurrentPos < arr.length) {
          let candidateIdx = idx + delta;
          const within = i => i >= 0 && i < rows.length;
          while (within(candidateIdx)) {
            const targetRow = rows[candidateIdx];
            const okType = reorderState.type === 'instr' ? targetRow.type === 'instr' : targetRow.type === 'module-item';
            if (okType) break;
            candidateIdx += delta;
          }
          if (!within(candidateIdx)) return;
          setReorderState(prev => ({ ...prev, currentPos: newCurrentPos })); setIdx(candidateIdx);
        }
      }, [reorderState, idx, rows, atModule, module, store, path]);

      const findPlacedIndex = useCallback((type, pos, ownerId) => {
        return rows.findIndex(r =>
          (type === 'instr' ? r.type === 'instr' : r.type === 'module-item') &&
          (type === 'instr' ? r.dbId === ownerId : r.moduleId === ownerId) &&
          r.pos === pos
        );
      }, [rows]);

      const commitReorder = useCallback(() => {
        if (!reorderState) return;
        const originalPos = reorderState.originalPos;
        const theCurrentPos = (reorderState.currentPos !== undefined) ? reorderState.currentPos : originalPos;

        if (theCurrentPos !== originalPos && theCurrentPos >= 0) {
          if (reorderState.type === 'instr' && atModule && module) {
            const arr = store.get(`items-${module.name}`, module.items || []); updateData(`items-${module.name}`, moveInList(arr, originalPos, theCurrentPos));
          } else if (reorderState.type === 'module-item') {
            const a = store.getDbItem(path[0]); if (a) {
              const arr = store.get(`mods-${a.name}`, a.modules || []); updateData(`mods-${a.name}`, moveInList(arr, originalPos, theCurrentPos));
            }
          }
        }

        const ownerId = reorderState.dbId || reorderState.moduleId;
        const targetIdx = findPlacedIndex(reorderState.type, theCurrentPos, ownerId);
        setReorderState(null);
        if (targetIdx >= 0) setIdx(targetIdx);
      }, [reorderState, atModule, module, store, updateData, findPlacedIndex, path]);

      /* DnD desktop */
      const handleDragStart = useCallback((e, row) => { e.dataTransfer.effectAllowed = 'move'; setDragItem(row); }, []);
      const handleDragOver = useCallback((e, row) => { e.preventDefault(); if (!dragItem) return; e.dataTransfer.dropEffect = 'move'; setDragOver(row.key); }, [dragItem]);
      const handleDrop = useCallback((e, row) => {
        e.preventDefault(); if (!dragItem) return;

        if (dragItem.type === 'instr' && row.type === 'instr' && atModule && module) {
          const arr = store.get(`items-${module.name}`, module.items || []); updateData(`items-${module.name}`, moveInList(arr, dragItem.pos, row.pos));
          const newIdx = findPlacedIndex('instr', row.pos, row.dbId); if (newIdx >= 0) setIdx(newIdx);
        } else if (dragItem.type === 'module-item' && row.type === 'module-item') {
          const a = store.getDbItem(path[0]); if (a) {
            const arr = store.get(`mods-${a.name}`, a.modules || []); updateData(`mods-${a.name}`, moveInList(arr, dragItem.pos, row.pos));
            const newIdx = findPlacedIndex('module-item', row.pos, row.moduleId); if (newIdx >= 0) setIdx(newIdx);
          }
        }

        setDragItem(null); setDragOver(null);
      }, [dragItem, atModule, module, store, updateData, findPlacedIndex, path]);
      const handleDragEnd = useCallback(() => { setDragItem(null); setDragOver(null); }, []);

      /* Touch DnD */
      const onTouchStartRow = useCallback((e, row) => {
        if (!(row.type === 'instr' || row.type === 'module-item')) return;
        const t = e.touches[0];
        setTouchDrag({ row, startY: t.clientY });
        setDragItem(row);
      }, []);
      const onTouchMoveRow = useCallback((e) => {
        if (!touchDrag) return;
        const t = e.touches[0];
        const el = document.elementFromPoint(t.clientX, t.clientY);
        if (!el) return;
        const targetLine = el.closest && el.closest('.line');
        if (!targetLine) return;
        const key = targetLine.getAttribute('data-key');
        setDragOver(key);
      }, [touchDrag]);
      const onTouchEndRow = useCallback(() => {
        if (!touchDrag) return;
        const row = touchDrag.row;
        const overKey = dragOver;
        if (overKey) {
          const targetRow = rowsRef.current.find(r => r.key === overKey);
          if (targetRow) {
            if (row.type === 'instr' && targetRow.type === 'instr' && atModule && module) {
              const arr = store.get(`items-${module.name}`, module.items || []);
              updateData(`items-${module.name}`, moveInList(arr, row.pos, targetRow.pos));
            } else if (row.type === 'module-item' && targetRow.type === 'module-item') {
              const a = store.getDbItem(path[0]); if (a) {
                const arr = store.get(`mods-${a.name}`, a.modules || []);
                updateData(`mods-${a.name}`, moveInList(arr, row.pos, targetRow.pos));
              }
            }
          }
        }
        setTouchDrag(null); setDragItem(null); setDragOver(null);
      }, [touchDrag, dragOver, atModule, module, store, updateData, path]);

      /* Execute actions */
      const executeRowAction = useCallback((row, action) => {
        if (!row) return;
        if (row.type === 'module-item') {
          if (action === 'view') {
            const pathKey = path.join('/'); setNavHistory(h => ({ ...h, [pathKey]: rows.findIndex(r => r.key === row.key) }));
            setPath([...path, row.moduleId]);
            setIdx(3);
            return;
          }
          if (action === 'move') {
            const i = rows.findIndex(r => r.key === row.key);
            setIdx(i);
            setReorderState({ rowKey: row.key, dbId: row.moduleId, type: row.type, originalIdx: i, originalPos: row.pos, currentPos: row.pos });
            return;
          }
          if (action === 'settings') {
            setSettingsOpen(s => ({ ...s, [`spanel:mod:${row.moduleId}`]: !s[`spanel:mod:${row.moduleId}`] }));
            return;
          }
          if (action === 'duplicate') { duplicateItem(row.moduleId, true); return; }
          if (action === 'delete') { removeModuleById(row.moduleId); return; }
        }
        if (row.type === 'instr') {
          if (action === 'move') {
            const i = rows.findIndex(r => r.key === row.key);
            setIdx(i);
            setReorderState({ rowKey: row.key, dbId: row.dbId, type: row.type, originalIdx: i, originalPos: row.pos, currentPos: row.pos });
            return;
          }
          if (action === 'settings') {
            setSettingsOpen(s => ({ ...s, [`spanel:instr:${row.dbId}`]: !s[`spanel:instr:${row.dbId}`] }));
            return;
          }
          if (action === 'duplicate') { duplicateItem(row.dbId, false); return; }
          if (action === 'delete') { removeItemById(row.dbId); return; }
        }
      }, [duplicateItem, removeItemById, removeModuleById, rows, path]);

      /* Keyboard: Left = Back; Right = open Settings */
      const [omniActive, setOmniActive] = useState(false);
      const [omniMode, setOmniMode] = useState('search');
      const [omniQuery, setOmniQuery] = useState('');
      const [omniIndex, setOmniIndex] = useState(0);
      const [omniFilterType, setOmniFilterType] = useState(null);
      const [omniIntent, setOmniIntent] = useState(null);

      const handleKeyDown = useCallback((e) => {
        if (e.key === '/' && !omniActive) {
          const activeEl = document.activeElement;
          const inField = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA');
          if (!inField) { e.preventDefault(); openOmniAddModule(); return; }
        }
        if (omniActive) return;

        const sel = rows[idx]; if (!sel) return;

        const activeEl = document.activeElement;
        const inField = activeEl && (activeEl.tagName === 'TEXTAREA' || (activeEl.tagName === 'INPUT' && activeEl.type === 'text'));
        if (inField) {
          const valueLength = activeEl.value.length;
          const start = activeEl.selectionStart ?? 0;
          const end = activeEl.selectionEnd ?? 0;
          if ((e.key === 'ArrowLeft' || e.key === 'ArrowUp') && start === 0 && end === 0) { e.preventDefault(); activeEl.blur(); setIdx(prev => Math.max(0, prev - 1)); return; }
          if ((e.key === 'ArrowRight' || e.key === 'ArrowDown') && start === valueLength && end === valueLength) { e.preventDefault(); activeEl.blur(); setIdx(prev => Math.min(rows.length - 1, prev + 1)); return; }
          return;
        }

        const gotoIndex = (nextIdx) => { setIdx(nextIdx); };

        if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (reorderState) { moveItemInReorderMode('up'); }
          else { gotoIndex(Math.max(0, idx - 1)); }
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (reorderState) { moveItemInReorderMode('down'); }
          else { gotoIndex(Math.min(rows.length - 1, idx + 1)); }
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          if (reorderState) { setReorderState(null); return; }
          // Close settings if open for this row
          if (sel.type === 'module-item' && isSettingsOpenFor(sel)) { setSettingsOpen(s => { const k = `spanel:mod:${sel.moduleId}`; const cp = { ...s }; delete cp[k]; return cp; }); return; }
          if (sel.type === 'instr' && isSettingsOpenFor(sel)) { setSettingsOpen(s => { const k = `spanel:instr:${sel.dbId}`; const cp = { ...s }; delete cp[k]; return cp; }); return; }
          // Navigate back to agent if in module
          if (path.length > 1) {
            const newPath = path.slice(0, -1);
            const pathKey = newPath.join('/'); const savedIdx = navHistory[pathKey];
            setPath(newPath);
            setIdx(savedIdx !== undefined ? savedIdx : (newPath.length === 1 ? 2 : 3));
            return;
          }
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          // Open settings by default
          if (sel.type === 'module-item') { openAndFocusSettings('module', sel.moduleId); return; }
          if (sel.type === 'instr') { openAndFocusSettings('instr', sel.dbId); return; }
          if (sel.type === 'adder-mod') { openOmniAddModule(); return; }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          // Default Enter: navigate into module; for instr, open settings
          if (sel.type === 'module-item') {
            const pathKey = path.join('/'); setNavHistory(h => ({ ...h, [pathKey]: rows.findIndex(r => r.key === sel.key) }));
            setPath([...path, sel.moduleId]); setIdx(3); return;
          }
          if (sel.type === 'instr') { openAndFocusSettings('instr', sel.dbId); return; }
          if (sel.type === 'adder-mod') { openOmniAddModule(); return; }
        } else if (e.key === 'Escape') {
          e.preventDefault();
          if (reorderState) { setReorderState(null); return; }
          // Close settings if open for current row, else back to agent if possible
          if (sel.type === 'module-item' && isSettingsOpenFor(sel)) { setSettingsOpen(s => { const k = `spanel:mod:${sel.moduleId}`; const cp = { ...s }; delete cp[k]; return cp; }); return; }
          if (sel.type === 'instr' && isSettingsOpenFor(sel)) { setSettingsOpen(s => { const k = `spanel:instr:${sel.dbId}`; const cp = { ...s }; delete cp[k]; return cp; }); return; }
          if (path.length > 1) {
            const newPath = path.slice(0, -1);
            const pathKey = newPath.join('/'); const savedIdx = navHistory[pathKey];
            setPath(newPath);
            setIdx(savedIdx !== undefined ? savedIdx : (newPath.length === 1 ? 2 : 3));
            return;
          }
        }
      }, [
        rows, idx, reorderState, path, navHistory,
        moveItemInReorderMode, isSettingsOpenFor,
        omniActive, openOmniAddModule, openAndFocusSettings
      ]);

      useEffect(() => { window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [handleKeyDown]);

      const handleLineClick = useCallback((row) => {
        const rowIdx = rows.findIndex(r => r.key === row.key);
        if (rowIdx !== -1) setIdx(rowIdx);

        if (row.type === 'root') { navigateToPath([path[0]], true); return; }
        if (row.type === 'adder-mod') { openOmniAddModule(); return; }

        if (row.type === 'module-item') {
          // Toggle settings on click when already selected; otherwise just select
          const key = `spanel:mod:${row.moduleId}`;
          setSettingsOpen(s => ({ ...s, [key]: s[key] ? false : true }));
        } else if (row.type === 'instr') {
          const key = `spanel:instr:${row.dbId}`;
          setSettingsOpen(s => ({ ...s, [key]: s[key] ? false : true }));
        }
      }, [rows, path, navigateToPath, openOmniAddModule]);

      /* Omnisearch */
      const [omniModeStateInit] = useState(true); // sink to keep hooks order stable
      const [omniActiveStateInit] = useState(true); // ditto

      const promptText = useMemo(() => {
        let text = '(: Smile Composer\n    ' + store.get(`n-${agent.name}`, agent.name);
        if (atModule) {
          text += path.slice(1).map(mid => {
            const m = store.getDbItem(mid);
            const name = m ? displayNameFor(store, m, mid) : '';
            return m ? '\n        ' + name : '';
          }).join('');
        }
        return text;
      }, [path, agent, atModule, store, storeVersion]);

      const allTextContent = useMemo(() => {
        let parts = [];
        if (atModule && module) {
          const ids = store.get(`items-${module.name}`, module.items || []);
          ids.forEach(id => {
            const it = store.getDbItem(id); if (!it) return;
            const name = store.get(`nn-${id}`, displayNameFor(store, it, id));
            const text = store.get(`t-${it.name}`, it.text || '');
            const meta = store.get(`meta-${id}`, '');
            parts.push(`${name}\n${text}${meta ? `\n(meta) ${meta}` : ''}`);
          });
        } else if (agent) {
          const mods = store.get(`mods-${agent.name}`, agent.modules || []);
          mods.forEach(mid => {
            const m = store.getDbItem(mid); if (!m) return;
            const mname = displayNameFor(store, m, mid);
            parts.push(`== ${mname} ==`);
            const ids = store.get(`items-${m.name}`, m.items || []);
            ids.forEach(id => {
              const it = store.getDbItem(id); if (!it) return;
              const name = store.get(`nn-${id}`, displayNameFor(store, it, id));
              const text = store.get(`t-${it.name}`, it.text || '');
              const meta = store.get(`meta-${id}`, '');
              parts.push(`${name}\n${text}${meta ? `\n(meta) ${meta}` : ''}`);
            });
          });
        }
        return parts.join('\n\n');
      }, [storeVersion, path, atModule, module, agent, store]);

      const outputKey = atModule && module ? `output-${module.name}` : `output-${agent.name}`;
      const outputDefault = atModule ? '' : agent.output;

      return (
        <div className="container">
          {/* Omnisearch header */}
          <div className="omni">
            <div className="omni-bar">
              <input
                className="omni-input"
                placeholder="Omnisearch — press / to open, Tab switches modes"
                value={omniActive ? omniQuery : ''}
                readOnly={!omniActive}
                onFocus={() => omniActive ? null : openOmniAddModule()}
                onChange={e => setOmniQuery(e.target.value)}
              />
              <div className={`omni-mode ${omniActive ? 'show' : ''}`}>
                <button className={omniMode === 'search' ? 'active' : ''} onClick={() => setOmniMode('search')}>Search</button>
                <button className={omniMode === 'browse' ? 'active' : ''} onClick={() => setOmniMode('browse')}>Browse</button>
              </div>
              <button className="btn" title="Add Module" onClick={openOmniAddModule}>Add Module</button>
            </div>
          </div>

          <OmniSearch
            store={store} path={path} atModule={atModule} agent={agent} module={module}
            omniActive={omniActive} setOmniActive={setOmniActive}
            omniMode={omniMode} setOmniMode={setOmniMode}
            omniQuery={omniQuery} setOmniQuery={setOmniQuery}
            omniIndex={omniIndex} setOmniIndex={setOmniIndex}
            omniFilterType={omniFilterType} omniIntent={omniIntent}
            navigateToPath={navigateToPath}
            attachModuleToAgent={attachModuleToAgent}
            attachInstruction={attachInstruction}
            createNewAgent={createNewAgent}
            createNewModule={createNewModule}
            createNewInstruction={createNewInstruction}
          />

          {/* Main Composer */}
          <div className="panel">
            <div className="panel-title">
              <span className="clickable" onClick={() => navigateToPath([path[0]], true)}>Smile Composer</span>
              <div className="panel-title-right">
                <span className="panel-subtle">Left = Back • Right = Settings • Enter on module = Inside • Drag to reorder • / = Omnisearch</span>
                <button className="btn" onClick={openOmniAddModule}>Add Module</button>
              </div>
            </div>
            {rows.map((row, i) => {
              const isSelected = i === idx;
              const inReorderMode = reorderState && row.key === reorderState.rowKey;
              const isDragging = dragItem && dragItem.key === row.key;
              const isDropTarget = dragOver === row.key;

              return (
                <LineRenderer
                  key={row.key}
                  row={row}
                  isSelected={isSelected}
                  inReorderMode={!!inReorderMode}
                  isDragging={!!isDragging}
                  isDropTarget={!!isDropTarget}
                  store={store}
                  onLineClick={handleLineClick}
                  onTextChange={updateData}
                  onDragStart={handleDragStart}
                  onDragOver={handleDragOver}
                  onDrop={handleDrop}
                  onDragEnd={handleDragEnd}
                  onTouchStartRow={onTouchStartRow}
                  onTouchMoveRow={onTouchMoveRow}
                  onTouchEndRow={onTouchEndRow}
                  onActionExecute={executeRowAction}
                  getStruct={(k) => store.get(k, 'heavy')}
                  setStruct={(k,v) => updateData(k, v)}
                  getNameOverride={(k, f) => store.get(k, f || '')}
                  setNameOverride={(k, v) => updateData(k, v)}
                  getMeta={(k) => store.get(k, '')}
                  setMeta={(k, v) => updateData(k, v)}
                  setRowRef={setRowRef}
                  isSettingsOpenFor={isSettingsOpenFor}
                />
              );
            })}
          </div>

          {/* Lower panels moved down */}
          <div className="panel">
            <div className="panel-title"><span>Structure</span></div>
            <TreeView store={store} path={path} onNavigate={navigateToPath} storeVersion={storeVersion} />
          </div>

          <div className="panel">
            <div className="panel-title"><span>Prompt</span></div>
            <textarea readOnly value={promptText} className="underline-textarea" style={{ minHeight: '120px' }} />
            <div style={{ height: 8 }}></div>
            <button className="btn" data-hotkey-scope="ui" onClick={() => {
              const wrap = document.getElementById('alltext-wrapper');
              if (wrap) wrap.style.display = (wrap.style.display === 'none' ? '' : 'none');
            }}>Show / Hide All Text</button>
            <div id="alltext-wrapper" style={{ marginTop: 8 }}>
              <textarea className="alltext" readOnly value={allTextContent}></textarea>
            </div>
          </div>

          <div className="panel">
            <div className="panel-title">
              <span>Output</span>
              <button className="btn" data-hotkey-scope="ui" onClick={resetAll}>Reset All</button>
            </div>
            <textarea className="underline-textarea" value={store.get(outputKey, outputDefault)} onChange={e => updateData(outputKey, e.target.value)} style={{ minHeight: '150px' }}></textarea>
          </div>
        </div>
      );
    }

    /* ---------- OmniSearch ---------- */
    function OmniSearch({
      store, path, atModule, agent, module,
      omniActive, setOmniActive,
      omniMode, setOmniMode,
      omniQuery, setOmniQuery,
      omniIndex, setOmniIndex,
      omniFilterType, omniIntent,
      navigateToPath, attachModuleToAgent, attachInstruction, createNewAgent, createNewModule, createNewInstruction
    }) {
      const inputRef = useRef(null);
      const db = store.getAllDb();
      const agentModules = useMemo(() => agent ? (store.get(`mods-${agent.name}`, agent.modules || [])) : [], [store, agent]);

      const moduleFrequency = useMemo(() => {
        const freq = {};
        Object.keys(db).forEach(id => {
          const it = db[id];
          if (it.type === 'agent') {
            const mods = store.get(`mods-${it.name}`, it.modules || []);
            mods.forEach(mid => { freq[mid] = (freq[mid] || 0) + 1; });
          }
        });
        return freq;
      }, [db, store]);

      const topModules = useMemo(() => {
        const mods = Object.keys(db).filter(id => db[id].type === 'mod');
        return mods.sort((a, b) => {
          const fa = moduleFrequency[a] || 0;
          const fb = moduleFrequency[b] || 0;
          if (fb !== fa) return fb - fa;
          const na = (db[a].name || '').toLowerCase();
          const nb = (db[b].name || '').toLowerCase();
          return na.localeCompare(nb);
        });
      }, [db, moduleFrequency]);

      const scopeResults = useMemo(() => {
        if (!agent) return [];
        const q = (omniQuery || '').toLowerCase().trim();
        const out = [];
        const pushIf = (cond, row) => { if (cond) out.push(row); };

        pushIf(!omniFilterType || omniFilterType === 'agent',
          (!q || agent.name.toLowerCase().includes(q)) && { type: 'agent', id: path[0], name: store.get(`n-${agent.name}`, agent.name), scope: 'current' });

        for (const mid of agentModules) {
          const m = db[mid]; if (!m) continue;
          const mname = store.get(`n-${m.name}`, m.name);
          pushIf(!omniFilterType || omniFilterType === 'mod',
            (!q || mname.toLowerCase().includes(q)) && { type: 'mod', id: mid, name: mname, scope: 'current' });

          const items = store.get(`items-${m.name}`, m.items || []);
          for (const iid of items) {
            const ins = db[iid]; if (!ins) continue;
            const iname = store.get(`nn-${iid}`, displayNameFor(store, ins, iid));
            if (!omniFilterType || omniFilterType === 'instr') {
              if (!q) { out.push({ type: 'instr', id: iid, name: iname, scope: 'current' }); }
              else {
                const text = store.get(`t-${ins.name}`, ins.text || '');
                const meta = store.get(`meta-${iid}`, '');
                const hay = (iname + ' ' + text + ' ' + meta).toLowerCase();
                if (hay.includes(q)) out.push({ type: 'instr', id: iid, name: iname, scope: 'current' });
              }
            }
          }
        }
        return out.filter(Boolean);
      }, [agent, agentModules, store, db, omniQuery, path, omniFilterType]);

      const libraryResults = useMemo(() => {
        const q = (omniQuery || '').toLowerCase().trim();
        const out = [];
        Object.keys(db).forEach(id => {
          const it = db[id];
          if (omniFilterType && it.type !== omniFilterType) return;
          const name = it.name || '';
          const text = it.text || '';
          const hay = (name + ' ' + text).toLowerCase();
          if (q && !hay.includes(q)) return;
          const dup = scopeResults.find(s => s.type === it.type && s.id === id);
          if (!dup) out.push({ type: it.type, id, name, scope: 'library' });
        });
        out.sort((a,b)=>a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
        return out;
      }, [db, omniQuery, scopeResults, omniFilterType]);

      const suggestedModuleRows = useMemo(() => {
        if (!(omniIntent === 'add-module' && omniFilterType === 'mod' && (omniQuery || '').trim() === '')) return [];
        const rows = [];
        topModules.forEach(mid => {
          const m = db[mid]; if (!m) return;
          rows.push({ type: 'mod', id: mid, name: m.name, scope: 'library', suggested: true });
        });
        return rows;
      }, [omniIntent, omniFilterType, omniQuery, topModules, db]);

      const createRows = useMemo(() => {
        const q = (omniQuery || '').trim();
        if (!q) return [];
        const rows = [];
        if (!omniFilterType || omniFilterType === 'agent') rows.push({ type: 'create-agent', id: 'new-agent', name: `Create Agent "${q}"` });
        if (!omniFilterType || omniFilterType === 'mod') rows.push({ type: 'create-mod', id: 'new-mod', name: `Create Module "${q}"` });
        if (!omniFilterType || omniFilterType === 'instr') rows.push({ type: 'create-instr', id: 'new-instr', name: `Create Instruction "${q}"` });
        return rows;
      }, [omniQuery, omniFilterType]);

      const browseRows = useMemo(() => {
        const rows = [];
        rows.push({ type: 'label', id: 'label-in', name: 'In this project' });
        for (const mid of agentModules) {
          const m = db[mid]; if (!m) continue;
          const mname = store.get(`n-${m.name}`, m.name);
          rows.push({ type: 'mod', id: mid, name: mname, scope: 'current' });
          const items = store.get(`items-${m.name}`, m.items || []);
          for (const iid of items) {
            const ins = db[iid]; if (!ins) continue;
            const iname = store.get(`nn-${iid}`, displayNameFor(store, ins, iid));
            rows.push({ type: 'instr', id: iid, name: '• ' + iname, scope: 'current' });
          }
        }
        rows.push({ type: 'label', id: 'label-lib', name: 'From library' });
        Object.keys(db).forEach(id => {
          const it = db[id];
          if (it.type === 'mod' && !agentModules.includes(id)) rows.push({ type: 'mod', id, name: it.name, scope: 'library' });
          if (it.type === 'instr') rows.push({ type: 'instr', id, name: it.name, scope: 'library' });
        });
        rows.push({ type: 'label', id: 'label-create', name: 'Quick create' });
        rows.push({ type: 'create-mod', id: 'quick-mod', name: 'Create Module…' });
        rows.push({ type: 'create-instr', id: 'quick-instr', name: 'Create Instruction…' });
        rows.push({ type: 'create-agent', id: 'quick-agent', name: 'Create Agent…' });
        return rows;
      }, [agentModules, db, store]);

      const visibleRows = useMemo(() => {
        if (!omniActive) return [];
        if (omniMode === 'search') {
          if (omniIntent === 'add-module' && omniFilterType === 'mod' && (omniQuery || '').trim() === '') {
            const seen = new Set();
            const list = [];
            suggestedModuleRows.forEach(r => { const k = r.type+':'+r.id; if (!seen.has(k)) { seen.add(k); list.push(r); } });
            scopeResults.forEach(r => { if (r.type !== 'mod') return; const k = r.type+':'+r.id; if (!seen.has(k)) { seen.add(k); list.push(r); } });
            libraryResults.forEach(r => { if (r.type !== 'mod') return; const k = r.type+':'+r.id; if (!seen.has(k)) { seen.add(k); list.push(r); } });
            createRows.forEach(r => list.push(r));
            return list;
          }
          return [...scopeResults, ...libraryResults, ...createRows];
        } else {
          return browseRows;
        }
      }, [omniActive, omniMode, scopeResults, libraryResults, createRows, browseRows, omniIntent, omniFilterType, omniQuery, suggestedModuleRows]);

      useEffect(() => {
        if (!omniActive) return;
        const t = setTimeout(() => { inputRef.current && inputRef.current.focus(); }, 0);
        return () => clearTimeout(t);
      }, [omniActive]);

      useEffect(() => { setOmniIndex(0); }, [omniMode, omniQuery, setOmniIndex, omniFilterType, omniIntent]);

      const onKeyDown = (e) => {
        if (!omniActive) return;
        const has = visibleRows.length > 0;
        if (e.key === 'Tab') {
          e.preventDefault();
          setOmniMode(prev => prev === 'search' ? 'browse' : 'search');
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (has) setOmniIndex(prev => Math.min(visibleRows.length - 1, prev + 1));
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (has) setOmniIndex(prev => Math.max(0, prev - 1));
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (!has) return;
          actOnRow(visibleRows[Math.max(0, Math.min(omniIndex, visibleRows.length - 1))]);
        } else if (e.key === 'Escape') {
          e.preventDefault();
          setOmniActive(false);
        }
      };

      const actOnRow = (row) => {
        if (!row) return;
        if (row.type === 'agent') { navigateToPath([row.id], true); setOmniActive(false); return; }
        if (row.type === 'mod')   { attachModuleToAgent(row.id); navigateToPath([path[0], row.id], true); setOmniActive(false); return; }
        if (row.type === 'instr') { attachInstruction(row.id); setOmniActive(false); return; }
        if (row.type === 'create-agent') { createNewAgent(omniQuery.trim()); setOmniActive(false); return; }
        if (row.type === 'create-mod')   { createNewModule(omniQuery.trim()); setOmniActive(false); return; }
        if (row.type === 'create-instr') { createNewInstruction(omniQuery.trim()); setOmniActive(false); return; }
      };

      return omniActive ? (
        <div className="omni-drawer">
          <div className="subtle" style={{ margin: '4px 6px 8px 6px' }}>
            {omniMode === 'search'
              ? (omniIntent === 'add-module' && omniFilterType === 'mod' && (omniQuery || '').trim()===''
                  ? 'Suggested modules (most used) • Enter to add • Tab to switch modes'
                  : 'Search names, text, meta in this project and library • Enter to open/add • Tab to switch modes')
              : 'Browse current project and library • Enter to open or attach'}
          </div>
          <div className="omni-list">
            {visibleRows.length === 0 && (<div className="omni-item"><span>No matches</span></div>)}
            {visibleRows.map((r, i) => (
              r.type === 'label' ? (
                <div key={r.id} className="subtle" style={{ padding: '6px 2px 2px 2px' }}>{r.name}</div>
              ) : (
                <div
                  key={r.type + ':' + r.id + ':' + i}
                  className={`omni-item${i === omniIndex ? ' sel' : ''}`}
                  onMouseEnter={() => setOmniIndex(i)}
                  onClick={() => actOnRow(r)}
                >
                  <span>{r.name}</span>
                  <span className="badge">{r.type}{r.scope ? ` • ${r.scope}` : ''}{r.suggested ? ' • suggested' : ''}</span>
                </div>
              )
            ))}
          </div>
          <input
            ref={inputRef}
            className="omni-input"
            style={{ width: '1px', height: '1px', opacity: 0, pointerEvents: 'none', position: 'absolute' }}
            value={omniQuery}
            onChange={()=>{}}
            onKeyDown={onKeyDown}
          />
        </div>
      ) : null;
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div class="error">Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
