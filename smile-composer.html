<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>(: Smile Composer â€” Enter to edit, Right to drill, Left to return, Drag to reorder)</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { 
      --indent-gap: 4px;
      --rail-width: 4px;
      --rail-color: rgba(0,0,0,0.08);
      --hover-bg: #f6f6f6;
      --select-bg: #ededed;
      --text-size: 13px;
      --pad-x: 10px;
      --row-min-h: 34px;
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif;
      background: #fff;
      color: #111;
      padding: 24px;
      margin: 0;
      line-height: 1.5;
      font-size: var(--text-size);
    }
    .container { max-width: 900px; margin: 0 auto; }
    .panel { background: #fff; padding: 16px; border-radius: 10px; }

    .list-container {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .line {
      position: relative;
      user-select: none;
      padding: 8px var(--pad-x);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      cursor: pointer;
      touch-action: none;
      min-height: var(--row-min-h);
      background: transparent;
    }
    .indent-bg {
      pointer-events: none;
      position: absolute;
      left: var(--pad-x);
      top: 0;
      bottom: 0;
      width: calc(var(--indent-count, 0) * (var(--rail-width) + var(--indent-gap)));
      border-radius: 6px;
      background: transparent;
      transition: background-color 0.12s ease;
    }
    .line:hover .indent-bg { background: var(--hover-bg); }
    .line.selected .indent-bg { background: var(--select-bg); }

    .line-inner {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 0;
    }
    .indent-guides {
      display: flex;
      align-items: stretch;
      gap: var(--indent-gap);
      margin-right: 8px;
    }
    .indent-bar {
      width: var(--rail-width);
      border-radius: 8px;
      background: var(--rail-color);
      align-self: stretch;
    }

    .line-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .line-indicator { font-size: 14px; color: #666; flex-shrink: 0; display: inline-flex; align-items: center; gap: 10px; }

    /* Burger: hover-only, thin, uniform size */
    .burger {
      display: inline-flex;
      flex-direction: column;
      justify-content: center;
      gap: 2px;
      width: 12px;
      height: 10px;
      opacity: 0;
      transition: opacity 0.12s ease;
    }
    .line:hover .burger { opacity: 1; }
    .burger div {
      width: 12px;
      height: 1px;
      background: #666;
      border-radius: 1px;
    }

    /* Preview rows: same indentation and spacing as normal rows */
    .preview-line {
      position: relative;
      padding: 2px var(--pad-x);
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 24px;
      user-select: none;
    }
    .preview-inner {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 0;
    }
    .preview-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: #666; font-size: 12px; }

    /* Editor: backgroundless, uniform control height */
    .editor-container { 
      margin-top: 6px;
      margin-bottom: 6px;
      padding: 0;
      border-radius: 8px;
      background: transparent;
    }
    .editor-textarea {
      width: 100%;
      min-height: 120px;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: var(--text-size);
      line-height: 1.6;
      resize: vertical;
      background: transparent;
    }
    .editor-textarea:focus { outline: 2px solid #0066ff; outline-offset: 1px; }

    .settings-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 0;
      background: transparent;
      border-radius: 6px;
      font-size: var(--text-size);
    }
    .settings-field { display: flex; flex-direction: column; gap: 6px; }
    .settings-label { font-size: var(--text-size); font-weight: 500; color: #444; }
    .settings-input, .settings-textarea {
      padding: 8px 10px;
      border: none;
      border-radius: 4px;
      font: inherit;
      background: transparent;
      height: var(--row-min-h);
      display: flex;
      align-items: center;
      color: #111;
    }
    .settings-textarea { min-height: 80px; height: auto; resize: vertical; }
    .settings-slider-container { display: flex; align-items: center; gap: 12px; }
    .settings-slider { flex: 1; }
    .settings-slider-label { font-size: 12px; color: #666; min-width: 80px; }

    .editor-buttons {
      display: flex;
      gap: 12px;
      margin-top: 8px;
      flex-wrap: wrap;
      font-size: var(--text-size);
    }
    .editor-btn {
      padding: 6px 10px;
      border: none;
      border-radius: 6px;
      background: transparent;
      cursor: pointer;
      font-size: var(--text-size);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      height: var(--row-min-h);
    }
    .editor-btn:hover { background: var(--hover-bg); }
    .kbd-hints {
      color: #999;
      font-size: 12px;
      margin-top: 6px;
    }

    /* Search row looks like a row; black text, no underline */
    .search-row { cursor: text; }
    .search-input {
      border: none;
      outline: none;
      background: transparent;
      font: inherit;
      width: 100%;
      padding: 6px 2px;
      color: #111;
      text-decoration: none;
    }
    .search-input::placeholder { color: #111; } /* black as requested */

    .omni-list {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-top: 4px;
    }
    .omni-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 6px 0px;
      background: transparent;
      border-radius: 8px;
      cursor: pointer;
      font-size: var(--text-size);
    }
    .omni-item:hover { background: transparent; }
    .badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 12px;
      background: #e0e0e0;
      color: #555;
    }

    .searching .line .indent-bg { background: transparent !important; }

    .toast {
      position: fixed;
      bottom: 24px;
      right: 24px;
      padding: 12px 20px;
      background: #333;
      color: #fff;
      border-radius: 8px;
      font-size: 14px;
      animation: slideIn 0.3s ease;
      z-index: 2000;
    }
    @keyframes slideIn {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div>Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useMemo } = React;

    // Top menu has no emojis; it is a "menu" row navigated like others.
    const INITIAL_DB = {
      'expert-maker': { 
        name: 'Expert Maker',
        type: 'agent',
        emojis: 'ðŸŽ¯ðŸ§ ',
        modules: ['smile-menu', 'meta-info', 'jargon-cot', 'identify-mistakes']
      },
      'smile-menu': {
        name: '***(: Smile*** Prompt Editor',
        type: 'menu',
        emojis: '',   // no emojis on this row
        items: []
      },
      'meta-info': {
        name: 'Meta-Information MegaBrick',
        type: 'chain',
        emojis: 'ðŸ“ŠðŸ”—',
        items: ['smile-info', 'llm-info', 'user-info']
      },
      'jargon-cot': {
        name: 'Thinking In Jargon',
        type: 'chain',
        emojis: 'ðŸ§ªðŸ’­',
        items: ['emoji-section', 'bold-words', 'top-bottom']
      },
      'identify-mistakes': {
        name: 'Identify Mistakes and Rewrite',
        type: 'chain',
        emojis: 'ðŸ”âœï¸',
        items: ['emoji-section', 'bold-words', 'negative-rewrite']
      },
      'smile-info': {
        name: 'Information About (: Smile',
        type: 'doc',
        emojis: 'ðŸ˜ŠðŸ“˜',
        text: 'Explain Smile syntax: (: flexible, [: rigid, [= literal.'
      },
      'llm-info': {
        name: 'Information About LLMs',
        type: 'doc',
        emojis: 'ðŸ¤–ðŸ“š',
        text: 'Meta-knowledge about how LLMs process instructions.'
      },
      'user-info': {
        name: 'Information About User',
        type: 'doc',
        emojis: 'ðŸ‘¤ðŸ’¡',
        text: 'Contextualize user needs and goals.'
      },
      'emoji-section': {
        name: 'Emoji section name',
        type: 'doc',
        emojis: 'ðŸ˜€ðŸ·ï¸',
        text: 'Use two emoticons for section names.'
      },
      'bold-words': {
        name: 'Bold for important words',
        type: 'doc',
        emojis: 'ðŸ’ªðŸ“',
        text: 'Use **bold** for attention retention over long contexts.'
      },
      'top-bottom': {
        name: 'Maximize adherence through top+bottom replication',
        type: 'doc',
        emojis: 'â¬†ï¸â¬‡ï¸',
        text: 'Replicate critical instructions at beginning and end.'
      },
      'negative-rewrite': {
        name: 'Identify negatives and rewrite to positive',
        type: 'doc',
        emojis: 'âŒâœ…',
        text: 'Find negatives like "not" and rewrite as positive articulations.'
      }
    };

    const getMockPrompt = (type, id, db) => {
      const item = db[id];
      if (!item) return '';
      if (type === 'menu') {
        return `(: Menu Prompt Editor - ${item.name} (

  [= Description [
    Configure the primary prompt scaffolding and top-level semantics.
  ] End description =]

) End menu :)`;
      }
      if (type === 'agent') {
        return `(: Agent - ${item.name} (

  [: Task Definition [
    Create intelligent responses using modular components
  ] End task :]

  [: Response Format [
    ***(: ${item.name}***:
    
    {Your expert response here}
  ] End format :]

) End agent :)`;
      }
      if (type === 'chain') {
        return `(: Chain - ${item.name} (

  [= Documents [
    ${(item.items || []).map(i => `- ${db[i]?.name || i}`).join('\n    ')}
  ] End documents =]

) End chain :)`;
      }
      if (type === 'doc') {
        return `[: Document - ${item.name} [
  ${item.text || ''}
] End document :]`;
      }
      return '';
    };

    function App() {
      const [db, setDb] = useState(INITIAL_DB);
      const [agentId] = useState('expert-maker');
      const [path, setPath] = useState([agentId]); // [agent] or [agent, chainId]
      const [selectedIdx, setSelectedIdx] = useState(0);
      const [editorOpen, setEditorOpen] = useState(false);
      const [editorItemId, setEditorItemId] = useState(null);
      const [editorItemType, setEditorItemType] = useState(null);
      const [editorMode, setEditorMode] = useState('text');
      const [editorText, setEditorText] = useState('');

      const [settingsName, setSettingsName] = useState('');
      const [settingsEmojis, setSettingsEmojis] = useState('');
      const [settingsText, setSettingsText] = useState('');
      const [settingsMeta, setSettingsMeta] = useState('');
      const [settingsStructure, setSettingsStructure] = useState(1);

      const [toast, setToast] = useState(null);

      const [addQuery, setAddQuery] = useState('');
      const [addActive, setAddActive] = useState(false);
      const [addSelectedIdx, setAddSelectedIdx] = useState(0);
      const addInputRef = useRef(null);

      const isAgentView = path.length === 1;
      const isChainView = path.length === 2;
      const currentChainId = isChainView ? path[1] : null;

      const showToast = (msg) => { setToast(msg); setTimeout(() => setToast(null), 1600); };

      // Unified outline with compact rails
      const currentItems = useMemo(() => {
        const items = [];
        items.push({ id: 'smile-menu', ...db['smile-menu'], _depth: 0 });
        items.push({ id: agentId, ...db[agentId], _depth: 1 });
        if (isChainView) {
          const ch = db[currentChainId];
          if (ch) {
            items.push({ id: currentChainId, ...ch, _depth: 2 });
            (ch.items || []).forEach(docId => {
              const d = db[docId];
              if (d) items.push({ id: docId, ...d, _depth: 3 });
            });
          }
        } else {
          const agent = db[agentId];
          (agent.modules || []).forEach(mid => {
            const m = db[mid];
            if (m && m.type === 'chain') {
              items.push({ id: mid, ...m, _depth: 2 });
            }
          });
        }
        return items;
      }, [db, agentId, isChainView, currentChainId]);

      // Suggestions only after typing
      const addSuggestions = useMemo(() => {
        if (!addQuery.trim()) return [];
        const q = addQuery.toLowerCase();
        return Object.entries(db)
          .map(([id, it]) => ({ id, ...it }))
          .filter(x => x.type === 'chain' || x.type === 'doc')
          .filter(x => x.name.toLowerCase().includes(q));
      }, [db, addQuery]);

      const openEditor = (itemId, itemType) => {
        const prompt = getMockPrompt(itemType, itemId, db);
        setEditorItemId(itemId);
        setEditorItemType(itemType);
        setEditorText(prompt);
        setEditorMode('text');
        setEditorOpen(true);

        const it = db[itemId];
        setSettingsName(it?.name || '');
        setSettingsEmojis(it?.emojis || '');
        setSettingsText(it?.text || '');
        setSettingsMeta('');
        setSettingsStructure(1);
      };
      const closeEditor = () => {
        setEditorOpen(false);
        setEditorItemId(null);
        setEditorItemType(null);
        setEditorText('');
        setEditorMode('text');
      };
      const saveEditor = () => { showToast('Saved'); closeEditor(); };

      // ArrowRight on chains drills into chain view; Enter still opens editor.
      useEffect(() => {
        const onKey = (e) => {
          if (editorOpen) {
            if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); saveEditor(); return; }
            if (e.key === 'Escape') { e.preventDefault(); closeEditor(); return; }
            if (e.key === 'ArrowRight') { e.preventDefault(); setEditorMode(m => m === 'text' ? 'settings' : 'text'); return; }
            if (e.key === 'Delete') { e.preventDefault(); return; }
            return;
          }
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (selectedIdx < currentItems.length - 1) {
              setSelectedIdx(prev => prev + 1);
            } else if (addInputRef.current) {
              addInputRef.current.focus();
              setAddActive(true);
              setSelectedIdx(-1);
            }
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (selectedIdx > 0) {
              setSelectedIdx(prev => prev - 1);
            } else if (addInputRef.current) {
              addInputRef.current.focus();
              setAddActive(true);
              setSelectedIdx(-1);
            }
          } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            if (isChainView) {
              setPath([agentId]);
              setSelectedIdx(2);
            }
          } else if (e.key === 'ArrowRight') {
            e.preventDefault();
            const item = currentItems[selectedIdx];
            if (!item) return;
            if (item.type === 'chain') {
              // Drill into chain view to see documents
              setPath([agentId, item.id]);
              return;
            }
            if (item.type === 'menu' || item.type === 'agent' || item.type === 'doc') {
              openEditor(item.id, item.type);
              return;
            }
          } else if (e.key === 'Enter') {
            e.preventDefault();
            const item = currentItems[selectedIdx];
            if (!item) return;
            if (item.type === 'chain') {
              // Enter opens editor for chains
              openEditor(item.id, 'chain');
            } else {
              openEditor(item.id, item.type);
            }
          } else if (e.key === '+') {
            e.preventDefault();
            if (addInputRef.current) {
              addInputRef.current.focus();
              setAddActive(true);
              setSelectedIdx(-1);
            }
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [editorOpen, selectedIdx, currentItems, isChainView, agentId, db]);

      const IndentGuides = ({ depth }) => {
        const bars = [];
        for (let i = 0; i < depth; i++) bars.push(<div key={i} className="indent-bar"></div>);
        return <div className="indent-guides">{bars}</div>;
      };

      const isSearching = addActive;
      const panelClass = `panel ${isSearching ? 'searching' : ''}`;

      return (
        <div className="container">
          <div className={panelClass}>
            <div className="list-container">
              {currentItems.map((item, idx) => {
                const isSelected = selectedIdx === idx && !editorOpen && !addActive;
                const depth = item._depth ?? 0;
                const isMenuRow = item.type === 'menu';
                const isAgentRow = item.type === 'agent';
                const showArrow = item.type === 'chain';
                const showBurger = isMenuRow || isAgentRow;

                return (
                  <React.Fragment key={item.id}>
                    <div
                      className={`line ${isSelected ? 'selected' : ''}`}
                      style={{ '--indent-count': depth }}
                      onClick={() => {
                        if (item.type === 'chain') {
                          setPath([agentId, item.id]); // click drills to chain view
                        } else {
                          setSelectedIdx(idx);
                        }
                      }}
                    >
                      <div className="indent-bg"></div>
                      <div className="line-inner">
                        <IndentGuides depth={depth} />
                        <span className="line-label">{item.emojis ? `${item.emojis} ` : ''}{item.name}</span>
                      </div>
                      <div className="line-indicator">
                        {showArrow ? 'â†’' : null}
                        {showBurger ? (
                          <span className="burger" title="Open editor">
                            <div></div><div></div><div></div>
                          </span>
                        ) : null}
                      </div>
                    </div>

                    {/* Chain preview of documents when a chain is selected in agent view, indented to document level */}
                    {isAgentView && isSelected && item.type === 'chain' && item.items && (
                      <div className="module-contents">
                        {(item.items || []).map(docId => {
                          const d = db[docId];
                          if (!d) return null;
                          const previewDepth = depth + 1; // same as doc depth in chain view
                          return (
                            <div key={docId} className="preview-line" style={{ '--indent-count': previewDepth }}>
                              <div className="indent-bg"></div>
                              <div className="preview-inner">
                                <IndentGuides depth={previewDepth} />
                                <span className="preview-label">{d.emojis} {d.name}</span>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    )}

                    {/* Inline editor below the selected item */}
                    {editorOpen && editorItemId === item.id && (
                      <div className="editor-container">
                        {editorMode === 'text' ? (
                          <textarea
                            className="editor-textarea"
                            value={editorText}
                            onChange={(e) => setEditorText(e.target.value)}
                            autoFocus
                          />
                        ) : (
                          <div className="settings-container">
                            <div className="settings-field">
                              <label className="settings-label">Name</label>
                              <input className="settings-input" value={settingsName} onChange={(e) => setSettingsName(e.target.value)} />
                            </div>
                            <div className="settings-field">
                              <label className="settings-label">Emojis (2)</label>
                              <input className="settings-input" value={settingsEmojis} onChange={(e) => setSettingsEmojis(e.target.value)} maxLength={4} />
                            </div>
                            {item.type === 'doc' && (
                              <div className="settings-field">
                                <label className="settings-label">Document Text</label>
                                <textarea className="settings-textarea" value={settingsText} onChange={(e) => setSettingsText(e.target.value)} />
                              </div>
                            )}
                            <div className="settings-field">
                              <label className="settings-label">Meta</label>
                              <textarea className="settings-textarea" value={settingsMeta} onChange={(e) => setSettingsMeta(e.target.value)} placeholder="Meta-aware context..." />
                            </div>
                            <div className="settings-field">
                              <label className="settings-label">Structure</label>
                              <div className="settings-slider-container">
                                <input type="range" min="0" max="2" step="1" value={settingsStructure} onChange={(e) => setSettingsStructure(parseInt(e.target.value))} className="settings-slider" />
                                <span className="settings-slider-label">{['Light (:', 'Medium [:', 'Heavy [='][settingsStructure]}</span>
                              </div>
                            </div>
                          </div>
                        )}
                        <div className="editor-buttons">
                          <button className="editor-btn" onClick={() => { showToast('Saved'); closeEditor(); }}>Save</button>
                          <button className="editor-btn" onClick={() => setEditorMode(m => m === 'text' ? 'settings' : 'text')}>Settings</button>
                          <button className="editor-btn" onClick={() => navigator.clipboard.writeText(editorText).then(() => showToast('Copied to clipboard'))}>Copy</button>
                          <button className="editor-btn" onClick={() => { /* soft delete in demo */ showToast('Deleted'); closeEditor(); }}>Delete</button>
                          <button className="editor-btn" onClick={closeEditor}>Cancel</button>
                        </div>
                        <div className="kbd-hints">(shift+enter) save â€¢ (esc) cancel</div>
                      </div>
                    )}
                  </React.Fragment>
                );
              })}

              {/* Inline search row; black text, no underline; identical styling; results only after typing */}
              <div className="line search-row" style={{ '--indent-count': 2 }} onClick={() => { if (addInputRef.current) addInputRef.current.focus(); }}>
                <div className="indent-bg"></div>
                <div className="line-inner">
                  <div className="indent-guides">
                    <div className="indent-bar"></div>
                    <div className="indent-bar"></div>
                  </div>
                  <input
                    ref={addInputRef}
                    className="search-input"
                    placeholder="Add or search chains and documents"
                    value={addQuery}
                    onFocus={() => { setAddActive(true); setSelectedIdx(-1); }}
                    onBlur={() => setTimeout(() => setAddActive(false), 150)}
                    onChange={(e) => { setAddQuery(e.target.value); setAddSelectedIdx(0); }}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') {
                        e.preventDefault();
                        const list = addSuggestions;
                        if (list.length > 0 && addSelectedIdx < list.length) {
                          const chosen = list[addSelectedIdx];
                          const allow = (isChainView && chosen.type === 'doc') || (!isChainView && chosen.type === 'chain');
                          if (!allow) return;
                          if (isChainView) {
                            const chain = db[currentChainId];
                            const newItems = [...(chain?.items || []), chosen.id];
                            setDb(prev => ({ ...prev, [currentChainId]: { ...prev[currentChainId], items: newItems } }));
                          } else {
                            const agent = db[agentId];
                            const newMods = [...(agent?.modules || []), chosen.id];
                            setDb(prev => ({ ...prev, [agentId]: { ...prev[agentId], modules: newMods } }));
                          }
                          setAddQuery(''); setAddActive(false);
                          if (addInputRef.current) addInputRef.current.blur();
                        }
                      } else if (e.key === 'Escape') {
                        e.preventDefault();
                        setAddQuery(''); setAddActive(false);
                        if (addInputRef.current) addInputRef.current.blur();
                      } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        setAddSelectedIdx(prev => Math.min(addSuggestions.length - 1, prev + 1));
                      } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (addSelectedIdx <= 0) {
                          setAddActive(false);
                          if (addInputRef.current) addInputRef.current.blur();
                          // Return focus to last visible row
                          setSelectedIdx(Math.max(0, currentItems.length - 1));
                        } else {
                          setAddSelectedIdx(prev => prev - 1);
                        }
                      }
                    }}
                  />
                </div>
              </div>

              {addQuery.trim() && (
                <div className="omni-list">
                  {addSuggestions.map((item, idx) => {
                    const allowed = (isChainView && item.type === 'doc') || (!isChainView && item.type === 'chain');
                    const isSel = idx === addSelectedIdx && addActive;
                    return (
                      <div
                        key={item.id}
                        className="omni-item"
                        onMouseDown={() => {
                          if (!allowed) return;
                          if (isChainView) {
                            const chain = db[currentChainId];
                            const newItems = [...(chain?.items || []), item.id];
                            setDb(prev => ({ ...prev, [currentChainId]: { ...prev[currentChainId], items: newItems } }));
                          } else {
                            const agent = db[agentId];
                            const newMods = [...(agent?.modules || []), item.id];
                            setDb(prev => ({ ...prev, [agentId]: { ...prev[agentId], modules: newMods } }));
                          }
                          setAddQuery(''); setAddActive(false);
                          if (addInputRef.current) addInputRef.current.blur();
                        }}
                        title={allowed ? 'Add' : 'Not addable in this context'}
                        style={{ fontWeight: isSel ? 600 : 400 }}
                      >
                        <span>{item.emojis} {item.name}</span>
                        <span className="badge">{item.type}</span>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>

            {toast && <div className="toast">{toast}</div>}
          </div>
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div>Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
