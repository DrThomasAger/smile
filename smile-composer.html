<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>(: Smile Composer ‚Äî Enter to edit, Right to drill, Left to return, Drag to reorder)</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { 
      --indent-gap: 4px;
      --rail-width: 4px;
      --rail-color: rgba(0,0,0,0.10);
      --hover-row: #f6f6f6;
      --select-row: #ededed;
      --indent-fill: rgba(0,0,0,0.05);
      --indent-fill-strong: rgba(0,0,0,0.08);
      --text-size: 13px;
      --pad-x: 10px;
      --row-min-h: 34px;
    }
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif;
      background: #fff;
      color: #111;
      padding: 24px;
      margin: 0;
      line-height: 1.5;
      font-size: var(--text-size);
    }
    .container { max-width: 900px; margin: 0 auto; }
    .panel { background: #fff; padding: 16px; border-radius: 10px; }

    .list-container {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .line {
      position: relative;
      user-select: none;
      padding: 8px var(--pad-x);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      cursor: pointer;
      touch-action: none;
      min-height: var(--row-min-h);
      background: transparent;
      transition: background-color 0.12s ease;
    }
    .line:hover { background: var(--hover-row); }
    .line.selected { background: var(--select-row); }

    /* Left ‚Äúfilled‚Äù indent boxes that light up per level on hover */
    .indent-fills {
      pointer-events: none;
      position: absolute;
      left: var(--pad-x);
      top: 0;
      bottom: 0;
      display: flex;
      align-items: stretch;
      gap: var(--indent-gap);
      width: calc(var(--indent-count, 0) * (var(--rail-width) + var(--indent-gap)));
    }
    .indent-fill-box {
      width: var(--rail-width);
      border-radius: 8px;
      background: transparent;
      align-self: stretch;
      transition: background-color 0.12s ease;
    }
    .line:hover .indent-fill-box { background: var(--indent-fill); }
    .line.selected .indent-fill-box { background: var(--indent-fill-strong); }

    .line-inner {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 0;
      position: relative;
      z-index: 1; /* above indent-fills */
    }
    /* Slim neutral rails showing structural depth (always on) */
    .indent-guides {
      display: flex;
      align-items: stretch;
      gap: var(--indent-gap);
      margin-right: 8px;
    }
    .indent-bar {
      width: var(--rail-width);
      border-radius: 8px;
      background: var(--rail-color);
      align-self: stretch;
    }

    .line-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .line-indicator { font-size: 14px; color: #666; flex-shrink: 0; display: inline-flex; align-items: center; gap: 10px; }

    /* Arrow only for chains, only on hover */
    .arrow { opacity: 0; transition: opacity 0.12s ease; }
    .line.chain:hover .arrow { opacity: 1; }
    .line.menu .arrow, .line.prompt .arrow, .line.doc .arrow, .line.search .arrow { display: none; }

    /* Burger: hover-only for everything except search; thin, uniform */
    .burger {
      display: inline-flex;
      flex-direction: column;
      justify-content: center;
      gap: 2px;
      width: 12px;
      height: 10px;
      opacity: 0;
      transition: opacity 0.12s ease;
    }
    .burger div { width: 12px; height: 1px; background: #666; border-radius: 1px; }
    .line.menu:hover .burger,
    .line.prompt:hover .burger,
    .line.doc:hover .burger { opacity: 1; }
    .line.chain .burger, .line.search .burger { display: none; }

    /* Preview rows (chain preview in prompt view), indented to doc level */
    .preview-line {
      position: relative;
      padding: 2px var(--pad-x);
      display: flex;
      align-items: center;
      gap: 8px;
      min-height: 24px;
      user-select: none;
    }
    .preview-inner {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 0;
      position: relative;
      z-index: 1;
    }
    .preview-label { flex: 1; min-width: 0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: #666; font-size: 12px; }
    .preview-fills {
      pointer-events: none;
      position: absolute;
      left: var(--pad-x);
      top: 0;
      bottom: 0;
      display: flex;
      align-items: stretch;
      gap: var(--indent-gap);
      width: calc(var(--indent-count, 0) * (var(--rail-width) + var(--indent-gap)));
    }
    .preview-fill-box {
      width: var(--rail-width);
      border-radius: 8px;
      background: var(--indent-fill);
      align-self: stretch;
    }

    /* Editor: backgroundless, uniform control height */
    .editor-container { 
      margin-top: 6px;
      margin-bottom: 6px;
      padding: 0;
      border-radius: 8px;
      background: transparent;
    }
    .editor-textarea {
      width: 100%;
      min-height: 120px;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: var(--text-size);
      line-height: 1.6;
      resize: vertical;
      background: transparent;
    }
    .editor-textarea:focus { outline: 2px solid #0066ff; outline-offset: 1px; }

    .settings-container { display: flex; flex-direction: column; gap: 12px; padding: 0; background: transparent; border-radius: 6px; font-size: var(--text-size); }
    .settings-field { display: flex; flex-direction: column; gap: 6px; }
    .settings-label { font-size: var(--text-size); font-weight: 500; color: #444; }
    .settings-input, .settings-textarea {
      padding: 8px 10px; border: none; border-radius: 4px; font: inherit; background: transparent; height: var(--row-min-h); display: flex; align-items: center; color: #111;
    }
    .settings-textarea { min-height: 80px; height: auto; resize: vertical; }
    .settings-slider-container { display: flex; align-items: center; gap: 12px; }
    .settings-slider { flex: 1; }
    .settings-slider-label { font-size: 12px; color: #666; min-width: 80px; }

    .editor-buttons { display: flex; gap: 12px; margin-top: 8px; flex-wrap: wrap; font-size: var(--text-size); }
    .editor-btn { padding: 6px 10px; border: none; border-radius: 6px; background: transparent; cursor: pointer; font-size: var(--text-size); display: inline-flex; align-items: center; gap: 6px; height: var(--row-min-h); }
    .editor-btn:hover { background: var(--hover-row); }
    .kbd-hints { color: #999; font-size: 12px; margin-top: 6px; }

    /* Search row duplicates row behavior; rename and keep hover */
    .search-row { cursor: text; }
    .search-input {
      border: none; outline: none; background: transparent; font: inherit; width: 100%; padding: 6px 2px; color: #111; text-decoration: none;
    }
    .search-input::placeholder { color: #111; } /* black placeholder */

    .omni-list { display: flex; flex-direction: column; gap: 2px; margin-top: 4px; }
    .omni-item {
      display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 6px 0px; background: transparent; border-radius: 8px; cursor: pointer; font-size: var(--text-size);
    }
    .omni-item:hover { background: transparent; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 12px; background: #e0e0e0; color: #555; }

    .toast { position: fixed; bottom: 24px; right: 24px; padding: 12px 20px; background: #333; color: #fff; border-radius: 8px; font-size: 14px; animation: slideIn 0.3s ease; z-index: 2000; }
    @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div>Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useMemo } = React;

    // Top menu is a "menu" row (no emojis). Replace "agent" with "prompt".
    const INITIAL_DB = {
      'expert-maker': { 
        name: 'Expert Maker',
        type: 'prompt',
        emojis: 'üéØüß†',
        modules: ['smile-menu', 'meta-info', 'jargon-cot', 'identify-mistakes']
      },
      'smile-menu': {
        name: '(: Smile Prompt Editor', // rendered with <em><strong>(: Smile</strong></em> + " Prompt Editor"
        type: 'menu',
        emojis: '',
        items: []
      },
      'meta-info': {
        name: 'Meta-Information MegaBrick',
        type: 'chain',
        emojis: 'üìäüîó',
        items: ['smile-info', 'llm-info', 'user-info']
      },
      'jargon-cot': {
        name: 'Thinking In Jargon',
        type: 'chain',
        emojis: 'üß™üí≠',
        items: ['emoji-section', 'bold-words', 'top-bottom']
      },
      'identify-mistakes': {
        name: 'Identify Mistakes and Rewrite',
        type: 'chain',
        emojis: 'üîç‚úèÔ∏è',
        items: ['emoji-section', 'bold-words', 'negative-rewrite']
      },
      'smile-info': {
        name: 'Information About (: Smile',
        type: 'doc',
        emojis: 'üòäüìò',
        text: 'Explain Smile syntax: (: flexible, [: rigid, [= literal.'
      },
      'llm-info': { name: 'Information About LLMs', type: 'doc', emojis: 'ü§ñüìö', text: 'Meta-knowledge about how LLMs process instructions.' },
      'user-info': { name: 'Information About User', type: 'doc', emojis: 'üë§üí°', text: 'Contextualize user needs and goals.' },
      'emoji-section': { name: 'Emoji section name', type: 'doc', emojis: 'üòÄüè∑Ô∏è', text: 'Use two emoticons for section names.' },
      'bold-words': { name: 'Bold for important words', type: 'doc', emojis: 'üí™üìù', text: 'Use **bold** for attention retention over long contexts.' },
      'top-bottom': { name: 'Maximize adherence through top+bottom replication', type: 'doc', emojis: '‚¨ÜÔ∏è‚¨áÔ∏è', text: 'Replicate critical instructions at beginning and end.' },
      'negative-rewrite': { name: 'Identify negatives and rewrite to positive', type: 'doc', emojis: '‚ùå‚úÖ', text: 'Find negatives like "not" and rewrite as positive articulations.' }
    };

    const getMockPrompt = (type, id, db) => {
      const item = db[id];
      if (!item) return '';
      if (type === 'menu') {
        return `(: Menu Prompt Editor - ${item.name} (

  [= Description [
    Configure the primary prompt scaffolding and top-level semantics.
  ] End description =]

) End menu :)`;
      }
      if (type === 'prompt') {
        return `(: Prompt - ${item.name} (

  [: Task Definition [
    Create intelligent responses using modular components
  ] End task :]

  [: Response Format [
    ***(: ${item.name}***:
    
    {Your expert response here}
  ] End format :]

) End prompt :)`;
      }
      if (type === 'chain') {
        return `(: Chain - ${item.name} (

  [= Documents [
    ${(item.items || []).map(i => `- ${db[i]?.name || i}`).join('\n    ')}
  ] End documents =]

) End chain :)`;
      }
      if (type === 'doc') {
        return `[: Document - ${item.name} [
  ${item.text || ''}
] End document :]`;
      }
      return '';
    };

    function App() {
      const [db, setDb] = useState(INITIAL_DB);
      const [promptId] = useState('expert-maker');
      const [path, setPath] = useState([promptId]); // [prompt] or [prompt, chainId]
      const [selectedIdx, setSelectedIdx] = useState(0);
      const [editorOpen, setEditorOpen] = useState(false);
      const [editorItemId, setEditorItemId] = useState(null);
      const [editorItemType, setEditorItemType] = useState(null);
      const [editorMode, setEditorMode] = useState('text');
      const [editorText, setEditorText] = useState('');
      const [settingsName, setSettingsName] = useState('');
      const [settingsEmojis, setSettingsEmojis] = useState('');
      const [settingsText, setSettingsText] = useState('');
      const [settingsMeta, setSettingsMeta] = useState('');
      const [settingsStructure, setSettingsStructure] = useState(1);
      const [toast, setToast] = useState(null);

      const [addQuery, setAddQuery] = useState('');
      const [addActive, setAddActive] = useState(false);
      const [addSelectedIdx, setAddSelectedIdx] = useState(0);
      const addInputRef = useRef(null);

      const [lastChainId, setLastChainId] = useState(null); // remember which chain we drilled into

      const isPromptView = path.length === 1;
      const isChainView = path.length === 2;
      const currentChainId = isChainView ? path[1] : null;

      const showToast = (msg) => { setToast(msg); setTimeout(() => setToast(null), 1600); };

      // Build outline
      const currentItems = useMemo(() => {
        const items = [];
        items.push({ id: 'smile-menu', ...db['smile-menu'], _depth: 0, _class: 'menu' });
        items.push({ id: promptId, ...db[promptId], _depth: 1, _class: 'prompt' });
        if (isChainView) {
          const ch = db[currentChainId];
          if (ch) {
            items.push({ id: currentChainId, ...ch, _depth: 2, _class: 'chain' });
            (ch.items || []).forEach(docId => {
              const d = db[docId];
              if (d) items.push({ id: docId, ...d, _depth: 3, _class: 'doc' });
            });
          }
        } else {
          const prompt = db[promptId];
          (prompt.modules || []).forEach(mid => {
            const m = db[mid];
            if (m && m.type === 'chain') {
              items.push({ id: mid, ...m, _depth: 2, _class: 'chain' });
            }
          });
        }
        return items;
      }, [db, promptId, isChainView, currentChainId]);

      // Suggestions only after typing
      const addSuggestions = useMemo(() => {
        if (!addQuery.trim()) return [];
        const q = addQuery.toLowerCase();
        return Object.entries(db)
          .map(([id, it]) => ({ id, ...it }))
          .filter(x => x.type === 'chain' || x.type === 'doc')
          .filter(x => x.name.toLowerCase().includes(q));
      }, [db, addQuery]);

      const openEditor = (itemId, itemType) => {
        const promptText = getMockPrompt(itemType, itemId, db);
        setEditorItemId(itemId);
        setEditorItemType(itemType);
        setEditorText(promptText);
        setEditorMode('text');
        setEditorOpen(true);
        const it = db[itemId];
        setSettingsName(it?.name || '');
        setSettingsEmojis(it?.emojis || '');
        setSettingsText(it?.text || '');
        setSettingsMeta('');
        setSettingsStructure(1);
      };
      const closeEditor = () => {
        setEditorOpen(false);
        setEditorItemId(null);
        setEditorItemType(null);
        setEditorText('');
        setEditorMode('text');
      };
      const saveEditor = () => { showToast('Saved'); closeEditor(); };

      // Compute the index of a chain in prompt view list
      const getPromptViewChainIndex = (chainId) => {
        const prompt = db[promptId];
        const chainIds = (prompt.modules || []).filter(id => db[id]?.type === 'chain');
        const idxInChains = chainIds.indexOf(chainId);
        if (idxInChains === -1) return 2; // default first chain position
        return 2 + idxInChains; // 0: menu, 1: prompt, then chains...
      };

      // Keyboard interactions
      useEffect(() => {
        const onKey = (e) => {
          if (editorOpen) {
            if (e.key === 'Enter' && e.shiftKey) { e.preventDefault(); saveEditor(); return; }
            if (e.key === 'Escape') { e.preventDefault(); closeEditor(); return; }
            if (e.key === 'ArrowRight') { e.preventDefault(); setEditorMode(m => m === 'text' ? 'settings' : 'text'); return; }
            return;
          }
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (selectedIdx < currentItems.length - 1) {
              setSelectedIdx(prev => prev + 1);
            } else if (addInputRef.current) {
              addInputRef.current.focus();
              setAddActive(true);
              setSelectedIdx(-1);
            }
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (selectedIdx > 0) {
              setSelectedIdx(prev => prev - 1);
            } else if (addInputRef.current) {
              addInputRef.current.focus();
              setAddActive(true);
              setSelectedIdx(-1);
            }
          } else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            if (isChainView) {
              const backIdx = getPromptViewChainIndex(currentChainId || lastChainId);
              setPath([promptId]);
              setSelectedIdx(backIdx);
            }
          } else if (e.key === 'ArrowRight') {
            e.preventDefault();
            const item = currentItems[selectedIdx];
            if (!item) return;
            if (item.type === 'chain') {
              // Drill into chain view to see documents
              setLastChainId(item.id);
              setPath([promptId, item.id]);
              return;
            }
            if (item.type === 'menu' || item.type === 'prompt' || item.type === 'doc') {
              openEditor(item.id, item.type);
              return;
            }
          } else if (e.key === 'Enter') {
            e.preventDefault();
            const item = currentItems[selectedIdx];
            if (!item) return;
            if (item.type === 'chain') {
              openEditor(item.id, 'chain'); // Enter opens editor
            } else {
              openEditor(item.id, item.type);
            }
          } else if (e.key === '+') {
            e.preventDefault();
            if (addInputRef.current) {
              addInputRef.current.focus();
              setAddActive(true);
              setSelectedIdx(-1);
            }
          }
        };
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [editorOpen, selectedIdx, currentItems, isChainView, promptId, db, lastChainId, currentChainId]);

      const IndentGuides = ({ depth }) => {
        const bars = [];
        for (let i = 0; i < depth; i++) bars.push(<div key={i} className="indent-bar"></div>);
        return <div className="indent-guides">{bars}</div>;
      };
      const IndentFills = ({ depth, className }) => {
        const boxes = [];
        for (let i = 0; i < depth; i++) boxes.push(<div key={i} className={className}></div>);
        return <div className={className === 'indent-fill-box' ? 'indent-fills' : 'preview-fills'}>
          {boxes}
        </div>;
      };

      const isSearching = addActive;
      const panelClass = `panel ${isSearching ? 'searching' : ''}`;

      // Search row indentation: prompt view => chains depth (2); chain view => docs depth (3)
      const searchDepth = isChainView ? 3 : 2;

      return (
        <div className="container">
          <div className={panelClass}>
            <div className="list-container">
              {currentItems.map((item, idx) => {
                const isSelected = selectedIdx === idx && !editorOpen && !addActive;
                const depth = item._depth ?? 0;
                const rowClass = `line ${item._class || ''}`;

                return (
                  <React.Fragment key={item.id}>
                    <div
                      className={rowClass + (isSelected ? ' selected' : '')}
                      style={{ '--indent-count': depth }}
                      onClick={() => {
                        if (item.type === 'chain') {
                          setLastChainId(item.id);
                          setPath([promptId, item.id]); // click drills to chain view
                        } else {
                          setSelectedIdx(idx);
                        }
                      }}
                    >
                      <IndentFills depth={depth} className="indent-fill-box" />
                      <div className="line-inner">
                        <IndentGuides depth={depth} />
                        <span className="line-label">
                          {item.type === 'menu'
                            ? (<><em><strong>(: Smile</strong></em> {" "}Prompt Editor</>)
                            : (<>{item.emojis ? `${item.emojis} ` : ''}{item.name}</>)
                          }
                        </span>
                      </div>
                      <div className="line-indicator">
                        <span className="arrow">‚Üí</span>
                        <span className="burger" title="Open editor"><div></div><div></div><div></div></span>
                      </div>
                    </div>

                    {/* Chain preview of documents when a chain is selected in prompt view, indented to doc level */}
                    {isPromptView && isSelected && item.type === 'chain' && item.items && (
                      <div className="module-contents">
                        {(item.items || []).map(docId => {
                          const d = db[docId];
                          if (!d) return null;
                          const previewDepth = depth + 1; // doc depth
                          return (
                            <div key={docId} className="preview-line" style={{ '--indent-count': previewDepth }}>
                              <div className="preview-fills">
                                {Array.from({length: previewDepth}).map((_,i)=><div key={i} className="preview-fill-box"></div>)}
                              </div>
                              <div className="preview-inner">
                                <IndentGuides depth={previewDepth} />
                                <span className="preview-label">{d.emojis} {d.name}</span>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    )}

                    {/* Inline editor below the selected item */}
                    {editorOpen && editorItemId === item.id && (
                      <div className="editor-container">
                        {editorMode === 'text' ? (
                          <textarea
                            className="editor-textarea"
                            value={editorText}
                            onChange={(e) => setEditorText(e.target.value)}
                            autoFocus
                          />
                        ) : (
                          <div className="settings-container">
                            <div className="settings-field">
                              <label className="settings-label">Name</label>
                              <input className="settings-input" value={settingsName} onChange={(e) => setSettingsName(e.target.value)} />
                            </div>
                            <div className="settings-field">
                              <label className="settings-label">Emojis (2)</label>
                              <input className="settings-input" value={settingsEmojis} onChange={(e) => setSettingsEmojis(e.target.value)} maxLength={4} />
                            </div>
                            {item.type === 'doc' && (
                              <div className="settings-field">
                                <label className="settings-label">Document Text</label>
                                <textarea className="settings-textarea" value={settingsText} onChange={(e) => setSettingsText(e.target.value)} />
                              </div>
                            )}
                            <div className="settings-field">
                              <label className="settings-label">Meta</label>
                              <textarea className="settings-textarea" value={settingsMeta} onChange={(e) => setSettingsMeta(e.target.value)} placeholder="Meta-aware context..." />
                            </div>
                            <div className="settings-field">
                              <label className="settings-label">Structure</label>
                              <div className="settings-slider-container">
                                <input type="range" min="0" max="2" step="1" value={settingsStructure} onChange={(e) => setSettingsStructure(parseInt(e.target.value))} className="settings-slider" />
                                <span className="settings-slider-label">{['Light (:', 'Medium [:', 'Heavy [='][settingsStructure]}</span>
                              </div>
                            </div>
                          </div>
                        )}
                        <div className="editor-buttons">
                          <button className="editor-btn" onClick={() => { showToast('Saved'); closeEditor(); }}>Save</button>
                          <button className="editor-btn" onClick={() => setEditorMode(m => m === 'text' ? 'settings' : 'text')}>Settings</button>
                          <button className="editor-btn" onClick={() => navigator.clipboard.writeText(editorText).then(() => showToast('Copied to clipboard'))}>Copy</button>
                          <button className="editor-btn" onClick={() => { showToast('Deleted'); closeEditor(); }}>Delete</button>
                          <button className="editor-btn" onClick={closeEditor}>Cancel</button>
                        </div>
                        <div className="kbd-hints">(shift+enter) save ‚Ä¢ (esc) cancel</div>
                      </div>
                    )}
                  </React.Fragment>
                );
              })}

              {/* Inline Add Instructions row; hovers like others; indents to docs in chain view */}
              <div className={`line search-row`} style={{ '--indent-count': searchDepth }}>
                <IndentFills depth={searchDepth} className="indent-fill-box" />
                <div className="line-inner" onClick={() => { if (addInputRef.current) addInputRef.current.focus(); }}>
                  <IndentGuides depth={searchDepth} />
                  <input
                    ref={addInputRef}
                    className="search-input"
                    placeholder="üß©‚ûï Add Instructions"
                    value={addQuery}
                    onFocus={() => { setAddActive(true); setSelectedIdx(-1); }}
                    onBlur={() => setTimeout(() => setAddActive(false), 150)}
                    onChange={(e) => { setAddQuery(e.target.value); setAddSelectedIdx(0); }}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') {
                        e.preventDefault();
                        const list = addSuggestions;
                        if (list.length > 0 && addSelectedIdx < list.length) {
                          const chosen = list[addSelectedIdx];
                          const allow = (isChainView && chosen.type === 'doc') || (!isChainView && chosen.type === 'chain');
                          if (!allow) return;
                          if (isChainView) {
                            const chain = db[currentChainId];
                            const newItems = [...(chain?.items || []), chosen.id];
                            setDb(prev => ({ ...prev, [currentChainId]: { ...prev[currentChainId], items: newItems } }));
                          } else {
                            const prompt = db[promptId];
                            const newMods = [...(prompt?.modules || []), chosen.id];
                            setDb(prev => ({ ...prev, [promptId]: { ...prev[promptId], modules: newMods } }));
                          }
                          setAddQuery(''); setAddActive(false);
                          if (addInputRef.current) addInputRef.current.blur();
                        }
                      } else if (e.key === 'Escape') {
                        e.preventDefault();
                        setAddQuery(''); setAddActive(false);
                        if (addInputRef.current) addInputRef.current.blur();
                      } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        setAddSelectedIdx(prev => Math.min(addSuggestions.length - 1, prev + 1));
                      } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        if (addSelectedIdx <= 0) {
                          setAddActive(false);
                          if (addInputRef.current) addInputRef.current.blur();
                          setSelectedIdx(Math.max(0, currentItems.length - 1));
                        } else {
                          setAddSelectedIdx(prev => prev - 1);
                        }
                      }
                    }}
                  />
                </div>
                <div className="line-indicator">
                  <span className="arrow"></span>
                  <span className="burger"><div></div><div></div><div></div></span>
                </div>
              </div>

              {addQuery.trim() && (
                <div className="omni-list">
                  {addSuggestions.map((item, idx) => {
                    const allowed = (isChainView && item.type === 'doc') || (!isChainView && item.type === 'chain');
                    const isSel = idx === addSelectedIdx && addActive;
                    return (
                      <div
                        key={item.id}
                        className="omni-item"
                        onMouseDown={() => {
                          if (!allowed) return;
                          if (isChainView) {
                            const chain = db[currentChainId];
                            const newItems = [...(chain?.items || []), item.id];
                            setDb(prev => ({ ...prev, [currentChainId]: { ...prev[currentChainId], items: newItems } }));
                          } else {
                            const prompt = db[promptId];
                            const newMods = [...(prompt?.modules || []), item.id];
                            setDb(prev => ({ ...prev, [promptId]: { ...prev[promptId], modules: newMods } }));
                          }
                          setAddQuery(''); setAddActive(false);
                          if (addInputRef.current) addInputRef.current.blur();
                        }}
                        title={allowed ? 'Add' : 'Not addable in this context'}
                        style={{ fontWeight: isSel ? 600 : 400 }}
                      >
                        <span>{item.emojis} {item.name}</span>
                        <span className="badge">{item.type}</span>
                      </div>
                    );
                  })}
                </div>
              )}
            </div>

            {toast && <div className="toast">{toast}</div>}
          </div>
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div>Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
