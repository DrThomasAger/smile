<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Smile Composer — Indented UI, Stacked Panels, No Vertical Lines</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { --tab: 32px; --panel-radius: 10px; --soft-bg: #fafafa; --hover-bg: #f6f6f6; --select-bg: #f2f2f2; --rule: rgba(0,0,0,0.08); }

    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif;
      background: #fff;
      color: #111;
      padding: 32px;
      margin: 0;
    }

    /* Single stacked flow with unlimited width preference */
    .container { display: block; width: 100%; }

    .panel {
      background: #fff;
      border-radius: var(--panel-radius);
      padding: 16px;
      border: none;
      box-shadow: 0 1px 0 0 var(--rule); /* single bottom line effect only */
      margin-top: 20px;
    }
    .panel-title {
      font-weight: 600;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .panel-subtle { font-size: 12px; color: #666; }

    /* Composer lines */
    .line {
      user-select: none;
      padding: 8px 10px;
      border-radius: 10px;
      display: block;
      cursor: pointer;
      transition: background-color 0.12s ease;
    }
    .line:hover { background-color: var(--hover-bg); }
    .line.sel { font-weight: 600; background-color: var(--select-bg); }
    .line.reorder-mode { font-weight: 700; background-color: #eee; }
    .line.held { opacity: 0.35; }
    .line.drop-target { outline: 3px solid #111; outline-offset: -3px; border-radius: 12px; }

    /* Indented blocks for prompts/settings/adders by depth */
    .indent-block { margin-top: 8px; }
    .indent-grid { display: grid; gap: 10px; }

    /* Inputs: no vertical lines, minimal bottom rule only */
    .underline-input,
    .underline-textarea {
      width: 100%;
      background: transparent;
      border: none;
      border-bottom: 1px solid #ccc;
      border-radius: 0;
      padding: 6px 2px 6px 0;
      font: inherit;
      outline: none;
      resize: vertical;
      min-height: 34px;
    }
    .underline-textarea { min-height: 80px; }

    /* Buttons without enclosing borders (avoid vertical lines) */
    .btn {
      font: inherit;
      border: none;
      background: #fff;
      padding: 6px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 12px;
      box-shadow: 0 1px 0 0 var(--rule); /* single bottom line feel */
    }
    .btn + .btn { margin-left: 8px; }

    /* Search visuals: remove all visible lines */
    .search-wrap { margin-top: 8px; }
    .search-list {
      max-height: 240px;
      overflow: auto;
      margin-top: 8px;
      padding: 6px;
      border: none;
      background: #fff;
      border-radius: 12px;
    }
    .search-item {
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 4px 0;                /* spacing instead of borders */
      background: var(--soft-bg);
    }
    .search-item:hover { background: var(--hover-bg); }
    .search-item.selected { background: var(--select-bg); font-weight: 600; }
    .search-badge {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      background: #eee;
    }

    /* Tree view without line dividers */
    .tree-view { max-height: 500px; overflow: auto; font-size: 13px; line-height: 1.8; }
    .tree-item {
      padding: 6px 8px;
      cursor: pointer;
      user-select: none;
      border-radius: 8px;
    }
    .tree-item:hover { background: var(--hover-bg); }
    .tree-item.active { font-weight: 700; background: var(--select-bg); }

    .error { color: red; padding: 20px; border: 1px solid red; margin: 20px; border-radius: 8px; }

    /* Segmented control with soft look */
    .seg {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 999px;
      background: var(--soft-bg);
    }
    .seg .label { font-size: 12px; margin-right: 4px; }
    .seg input[type="radio"] { position: absolute; opacity: 0; pointer-events: none; }
    .seg .opt {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
    }
    .seg .dot { width: 8px; height: 8px; border-radius: 50%; background: #bbb; display: inline-block; }
    .seg input[type="radio"]:checked + .opt .dot { background: #111; }

    /* All text area with single bottom line */
    .alltext {
      width: 100%;
      min-height: 220px;
      padding: 10px;
      border: none;
      border-bottom: 1px solid #ccc;
      border-radius: 0;
      resize: vertical;
      background: #fff;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div class="error">Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useCallback, useMemo } = React;
    const TAB = 32; // unified tab size (px) for all hierarchy indents

    const INITIAL_DB = {
      'expert-maker': { name: 'Expert Maker', type: 'agent', input: 'Question', output: 'Answer', modules: ['meta-info', 'jargon-cot', 'identify-mistakes'] },
      'input-mod': { name: 'INPUT: Question', type: 'mod', items: ['input-enter', 'input-understand', 'input-result'] },
      'output-mod': { name: 'OUTPUT: Answer', type: 'mod', items: ['output-enter', 'output-understand', 'output-result'] },
      'meta-info': { name: 'Meta-Information MegaBrick', type: 'mod', items: ['smile-info', 'llm-info', 'user-info'] },
      'jargon-cot': { name: 'Jargon CoT', type: 'mod', items: ['emoji-section', 'bold-words', 'top-bottom'] },
      'identify-mistakes': { name: 'Identify Mistakes and Rewrite', type: 'mod', items: ['emoji-section', 'bold-words', 'negative-rewrite'] },
      'smile-info': { name: 'Information About (: Smile', type: 'instr', text: 'Explain Smile syntax: (: flexible, [: rigid, [= literal.' },
      'llm-info': { name: 'Information About LLMs', type: 'instr', text: 'Meta-knowledge about how LLMs process instructions.' },
      'user-info': { name: 'Information About User', type: 'instr', text: 'Contextualize user needs and goals.' },
      'emoji-section': { name: 'Emoji section name', type: 'instr', text: 'Use two emoticons for section names.' },
      'bold-words': { name: 'Bold for important words', type: 'instr', text: 'Use **bold** for attention retention over long contexts.' },
      'top-bottom': { name: 'Maximize adherence through top+bottom replication', type: 'instr', text: 'Replicate critical instructions at beginning and end.' },
      'negative-rewrite': { name: 'Identify negatives and rewrite to positive', type: 'instr', text: 'Find negatives like "not" and rewrite as positive articulations.' },
      'input-enter': { name: 'Provide Input', type: 'instr', text: 'Enter or paste the incoming question or payload in full fidelity.' },
      'input-understand': { name: 'Reasoning / Understanding', type: 'instr', text: 'Interpret the input; list goals, constraints, and ambiguities.' },
      'input-result': { name: 'Synthesis (Input + Understanding)', type: 'instr', text: 'Combine the raw input with the understanding into a structured representation.' },
      'output-enter': { name: 'Draft Output', type: 'instr', text: 'Produce an initial answer or output shape based on the current state.' },
      'output-understand': { name: 'Quality / Checks', type: 'instr', text: 'Reason about correctness, coverage, and criteria; refine the output.' },
      'output-result': { name: 'Final Output', type: 'instr', text: 'Deliver the polished final output after reasoning and checks.' }
    };

    class DataStore {
      constructor() { this.data = this.loadFromStorage(); this.db = { ...INITIAL_DB }; this.version = 0; }
      loadFromStorage() { try { const stored = localStorage.getItem('smileData'); return stored ? JSON.parse(stored) : {}; } catch(e){ return {}; } }
      saveToStorage(data) { try { localStorage.setItem('smileData', JSON.stringify(data)); } catch(e){} }
      get(key, def) { return key in this.data ? this.data[key] : def; }
      set(key, value) { this.data = { ...this.data, [key]: value }; this.version++; this.saveToStorage(this.data); return this.data; }
      reset() { this.data = {}; localStorage.removeItem('smileData'); this.db = { ...INITIAL_DB }; this.version++; return this.data; }
      getDbItem(id) { return this.db[id] || null; }
      addCustomDbItem(id, item) { this.db[id] = item; this.version++; }
      getAllDb() { return this.db; }
      getVersion() { return this.version; }
    }

    const moveInList = (arr, fromPos, toPos) => {
      if (fromPos === toPos || fromPos < 0 || toPos < 0 || fromPos >= arr.length) return arr;
      const newArr = [...arr];
      const [item] = newArr.splice(fromPos, 1);
      const insertPos = Math.min(toPos, newArr.length);
      newArr.splice(insertPos, 0, item);
      return newArr;
    };

    const getVisualArrayOrder = (arr, reorderState) => {
      if (!reorderState || reorderState.originalPos === undefined) return arr.map((item, idx) => ({ item, originalPos: idx }));
      if (reorderState.moveToDelete || reorderState.moveToCancel) {
        return arr.map((item, idx) => ({ item, originalPos: idx })).filter((_, idx) => idx !== reorderState.originalPos);
      }
      if (reorderState.currentPos === undefined) return arr.map((item, idx) => ({ item, originalPos: idx }));
      const enriched = arr.map((item, idx) => ({ item, originalPos: idx }));
      return moveInList(enriched, reorderState.originalPos, reorderState.currentPos);
    };

    const searchDatabase = (db, query, types = null) => {
      const lower = (query || '').toLowerCase().trim();
      if (!lower) return [];
      const out = [];
      Object.keys(db).forEach(k => {
        const item = db[k];
        if (types && !types.includes(item.type)) return;
        const nameMatch = (item.name || '').toLowerCase().includes(lower);
        const textMatch = item.text ? (item.text || '').toLowerCase().includes(lower) : false;
        if (nameMatch || textMatch) out.push({ id: k, name: item.name, type: item.type });
      });
      return out;
    };

    const displayNameFor = (store, dbItem, id) =>
      store.get(`nn-${id}`, store.get(`n-${dbItem.name}`, dbItem.name));

    const ownerKeyOfRow = (row) => {
      if (!row) return null;
      if (row.type === 'module-item') return `mod:${row.moduleId}`;
      if (row.type === 'instr') return `instr:${row.dbId}`;
      if (row.type === 'settings-button' || row.type === 'settings-panel' || row.type === 'prompt') {
        return (row.ownerType === 'module') ? `mod:${row.ownerId}` : `instr:${row.ownerId}`;
      }
      return null;
    };

    class RowBuilder {
      constructor(store, path, reorderState, revealedOwnerKey, settingsOpen, deleteMode) {
        this.store = store;
        this.path = path;
        this.reorderState = reorderState;
        this.revealedOwnerKey = revealedOwnerKey || null;
        this.settingsOpen = settingsOpen || {};
        this.deleteMode = deleteMode || { active: false };
        this.rows = [];
      }
      build() {
        this.addRoot(); this.addAgent(); this.addBreadcrumbs();
        if (this.isAtModule()) this.addModuleContent(); else this.addAgentModules();
        return this.rows;
      }
      addRoot() { this.rows.push({ key: 'root', type: 'root', depth: 0, label: '(: Smile Composer' }); }
      addAgent() {
        const agent = this.getAgent(); if (!agent) return;
        this.rows.push({ key: `agent:${this.path[0]}`, type: 'agent', depth: 1, label: this.store.get(`n-${agent.name}`, agent.name) });
      }
      addBreadcrumbs() {
        if (this.path.length <= 2) return;
        for (let i = 1; i < this.path.length - 1; i++) {
          const breadcrumbMod = this.store.getDbItem(this.path[i]); if (!breadcrumbMod) continue;
          this.rows.push({ key: `breadcrumb:${i}`, type: 'breadcrumb', depth: i + 1, label: this.store.get(`n-${breadcrumbMod.name}`, breadcrumbMod.name), pathIndex: i });
        }
      }
      addModuleContent() {
        const module = this.getCurrentModule(); if (!module) return;
        const moduleDBKey = this.path[this.path.length - 1];

        this.rows.push({ key: `module:${moduleDBKey}`, type: 'module', depth: 2, label: this.store.get(`n-${module.name}`, module.name), moduleId: moduleDBKey });

        const items = this.store.get(`items-${module.name}`, module.items || []);
        const visualItems = (this.reorderState && this.reorderState.type === 'instr') ? getVisualArrayOrder(items, this.reorderState) : getVisualArrayOrder(items, null);

        if (Array.isArray(visualItems)) {
          visualItems.forEach(({ item: id, originalPos }) => {
            const ins = this.store.getDbItem(id); if (!ins) return;
            const ownerKey = `instr:${id}`;
            const allowEphemeral = !this.reorderState && !this.deleteMode.active;
            const revealed = allowEphemeral && (this.revealedOwnerKey === ownerKey);

            const baseLabel = displayNameFor(this.store, ins, id);
            const decorated = this.deleteMode.active ? `- ${baseLabel}` : baseLabel;

            this.rows.push({
              key: `ins:${id}:${originalPos}`, type: 'instr', depth: 3,
              label: decorated,
              nameKey: `n-${ins.name}`, nameOverrideKey: `nn-${id}`,
              textKey: `t-${ins.name}`, defaultText: ins.text || '',
              metaKey: `meta-${id}`, structKey: `struct-${id}`,
              promptKey: `t-${ins.name}`,
              dbId: id, pos: originalPos, canReorder: true, revealed
            });

            if (revealed) {
              this.rows.push({
                key: `prompt:instr:${id}`, type: 'prompt', depth: 4,
                ownerType: 'instr', ownerId: id, promptKey: `t-${ins.name}`, label: ''
              });
              this.rows.push({
                key: `sbtn:instr:${id}`, type: 'settings-button', depth: 4,
                ownerType: 'instr', ownerId: id,
                nameOverrideKey: `nn-${id}`, metaKey: `meta-${id}`,
                structKey: `struct-${id}`, promptKey: `t-${ins.name}`,
                label: 'Settings'
              });
              const pKey = `spanel:instr:${id}`;
              if (this.settingsOpen[pKey]) {
                this.rows.push({
                  key: pKey, type: 'settings-panel', depth: 5,
                  ownerType: 'instr', ownerId: id,
                  nameOverrideKey: `nn-${id}`, metaKey: `meta-${id}`,
                  structKey: `struct-${id}`, promptKey: `t-${ins.name}`
                });
              }
            }
          });
        }

        this.rows.push({ key: `adder-${module.name}`, type: 'adder', depth: 3, label: '+ Add Instruction' });
        this.rows.push({
          key: 'trash',
          type: 'trash',
          depth: 3,
          label: this.deleteMode.active ? 'Select which instruction to delete' : '- Delete Instruction'
        });

        if (this.reorderState) {
          this.rows.push({ key: 'cancel-reorder', type: 'cancel-reorder', depth: 3, label: '[Esc] Cancel Movement' });
        }
      }
      addAgentModules() {
        const agent = this.getAgent(); if (!agent) return;
        const modules = this.store.get(`mods-${agent.name}`, agent.modules || []);
        const visualModules = (this.reorderState && this.reorderState.type === 'module-item') ? getVisualArrayOrder(modules, this.reorderState) : getVisualArrayOrder(modules, null);

        if (Array.isArray(visualModules)) {
          visualModules.forEach(({ item: mid, originalPos }) => {
            const mod = this.store.getDbItem(mid); if (!mod) return;
            const ownerKey = `mod:${mid}`;
            const allowEphemeral = !this.reorderState && !this.deleteMode.active;
            const revealed = allowEphemeral && (this.revealedOwnerKey === ownerKey);

            this.rows.push({
              key: `mod:${mid}:${originalPos}`, type: 'module-item', depth: 2,
              label: displayNameFor(this.store, mod, mid),
              nameKey: `n-${mod.name}`, nameOverrideKey: `nn-${mid}`,
              moduleId: mid, pos: originalPos, canReorder: true, revealed
            });

            if (revealed) {
              this.rows.push({
                key: `prompt:mod:${mid}`, type: 'prompt', depth: 3,
                ownerType: 'module', ownerId: mid, promptKey: `prompt-mod-${mid}`, label: ''
              });
              this.rows.push({
                key: `sbtn:mod:${mid}`, type: 'settings-button', depth: 3,
                ownerType: 'module', ownerId: mid,
                nameOverrideKey: `nn-${mid}`, metaKey: `meta-${mid}`,
                structKey: `struct-${mid}`, promptKey: `prompt-mod-${mid}`,
                label: 'Settings'
              });
              const pKey = `spanel:mod:${mid}`;
              if (this.settingsOpen[pKey]) {
                this.rows.push({
                  key: pKey, type: 'settings-panel', depth: 4,
                  ownerType: 'module', ownerId: mid,
                  nameOverrideKey: `nn-${mid}`, metaKey: `meta-${mid}`,
                  structKey: `struct-${mid}`, promptKey: `prompt-mod-${mid}`
                });
              }
            }
          });
        }

        this.rows.push({ key: `adder-mod-${agent.name}`, type: 'adder-mod', depth: 2, label: '+ Add Module' });
        this.rows.push({ key: 'trash-mod', type: 'trash-mod', depth: 2, label: '- Delete Module' });
        if (this.reorderState) {
          this.rows.push({ key: 'cancel-reorder', type: 'cancel-reorder', depth: 2, label: '[Esc] Cancel Movement' });
        }
      }
      isAtModule() { return this.path.length >= 2; }
      getAgent() { return this.store.getDbItem(this.path[0]); }
      getCurrentModule() { return this.isAtModule() ? this.store.getDbItem(this.path[this.path.length - 1]) : null; }
    }

    function TreeView({ store, path, onNavigate, storeVersion }) {
      const renderModule = useCallback((modId, parentPath, depth) => {
        const mod = store.getDbItem(modId); if (!mod) return null;
        const modulePath = [...parentPath, modId];
        const isActive = path.join('/') === modulePath.join('/');
        const items = store.get(`items-${mod.name}`, mod.items || []);
        return (
          <div key={modId}>
            <div className={`tree-item${isActive ? ' active' : ''}`} style={{ paddingLeft: depth * 12 }} onClick={() => onNavigate(modulePath, true)}>
              {displayNameFor(store, mod, modId)}
            </div>
            {items.map(iid => {
              const ins = store.getDbItem(iid); if (!ins) return null;
              return (
                <div key={iid} className="tree-item" style={{ paddingLeft: (depth + 1) * 12 }}>
                  {displayNameFor(store, ins, iid)}
                </div>
              );
            })}
          </div>
        );
      }, [store, path, onNavigate, storeVersion]);

      const agentId = 'expert-maker';
      const agent = store.getDbItem(agentId); if (!agent) return null;
      const isAgentActive = path.length === 1 && path[0] === agentId;
      const modules = store.get(`mods-${agent.name}`, agent.modules || []);
      return (
        <div className="tree-view">
          <div className={`tree-item${isAgentActive ? ' active' : ''}`} onClick={() => onNavigate([agentId], true)}>
            {store.get(`n-${agent.name}`, agent.name)}
          </div>
          {modules.map(mid => renderModule(mid, [agentId], 1))}
        </div>
      );
    }

    function SearchAdder({ type, query, setQuery, onAdd, onCancel, store, indentPx }) {
      const inputRef = useRef(null);
      const [selectedIndex, setSelectedIndex] = useState(0);
      useEffect(() => { inputRef.current && inputRef.current.focus(); }, []);
      const isInstructionSearch = type === 'instruction';
      const results = useMemo(() => {
        const types = isInstructionSearch ? ['instr'] : null;
        return searchDatabase(store.getAllDb(), query, types);
      }, [query, isInstructionSearch, store]);
      const sortedResults = useMemo(
        () => isInstructionSearch ? results : [...results].sort((a,b)=>a.type==='mod'?-1:1),
        [results, isInstructionSearch]
      );
      useEffect(() => { setSelectedIndex(0); }, [query]);

      const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (sortedResults.length > 0 && selectedIndex >= 0 && selectedIndex < sortedResults.length) onAdd(sortedResults[selectedIndex]);
          else if (query.trim() && isInstructionSearch && sortedResults.length === 0) onAdd({ id: null, name: query.trim(), isNew: true });
        } else if (e.key === 'Escape') {
          e.preventDefault(); onCancel();
        } else if (e.key === 'ArrowDown') {
          e.preventDefault(); const maxIndex = sortedResults.length > 0 ? sortedResults.length - 1 : 0; setSelectedIndex(prev => Math.min(maxIndex, prev + 1));
        } else if (e.key === 'ArrowUp') {
          e.preventDefault(); setSelectedIndex(prev => Math.max(0, prev - 1));
        }
      };

      const handleItemClick = (item, index) => { setSelectedIndex(index); onAdd(item); };

      return (
        <div className="search-wrap indent-block" style={{ paddingLeft: indentPx }}>
          <input
            ref={inputRef}
            className="underline-input"
            placeholder={isInstructionSearch ? "Search instructions..." : "Search modules & instructions..."}
            value={query}
            onChange={e => setQuery(e.target.value)}
            onKeyDown={handleKeyDown}
          />
          <div className="search-list">
            {sortedResults.map((res, index) => (
              <div
                key={res.id}
                className={`search-item${index === selectedIndex ? ' selected' : ''}`}
                onClick={() => handleItemClick(res, index)}
              >
                <span>{res.name}</span>
                <span className="search-badge">{res.type}</span>
              </div>
            ))}
            {!results.length && query && isInstructionSearch && (
              <div
                className={`search-item${selectedIndex === 0 ? ' selected' : ''}`}
                onClick={() => onAdd({ id: null, name: query.trim(), isNew: true })}
              >
                <span>Create "{query.trim()}"</span>
                <span className="search-badge">instr</span>
              </div>
            )}
          </div>
        </div>
      );
    }

    function StructureDots5({ id, value, onChange }) {
      const opts = [
        { v: 'heavy', label: 'Heavy', aria: 'Heavy' },
        { v: 'heavy-mid', label: '●', aria: 'Between heavy and medium' },
        { v: 'medium', label: 'Medium', aria: 'Medium' },
        { v: 'medium-light', label: '●', aria: 'Between medium and light' },
        { v: 'light', label: 'Light', aria: 'Light' }
      ];
      return (
        <div className="seg" role="radiogroup" aria-label="Structure">
          <span className="label">Structure</span>
          {opts.map((o) => (
            <label key={o.v} title={o.aria}>
              <input type="radio" name={`struct-${id}`} value={o.v} checked={value === o.v} onChange={(e) => onChange(e.target.value)} />
              <span className="opt">
                {o.label === '●' ? <span className="dot" aria-hidden="true"></span> : <span style={{ fontSize: 12 }}>{o.label}</span>}
              </span>
            </label>
          ))}
        </div>
      );
    }

    function LineRenderer({
      row, isSelected, inReorderMode, isDragging, isDropTarget,
      store, onLineClick, onTextChange,
      onDragStart, onDragOver, onDrop, onDragEnd,
      addingState, onAddingComplete, onAddingCancel,
      getStruct, setStruct, setNameOverride, getNameOverride, getMeta, setMeta
    }) {
      const classes = ['line'];
      if (isSelected && !inReorderMode) classes.push('sel');
      if (inReorderMode) classes.push('reorder-mode');
      if (isDragging) classes.push('held');
      if (isDropTarget) classes.push('drop-target');

      const lineIndentPx = (row.depth || 0) * TAB;
      const style = { paddingLeft: lineIndentPx };

      const showAdder = (addingState.isAdding &&
        ((row.type === 'adder' && addingState.type === 'instruction') ||
         (row.type === 'adder-mod' && addingState.type === 'module')));

      const promptRef = useRef(null);
      useEffect(() => {
        if (row.type === 'prompt' && isSelected && promptRef.current) {
          promptRef.current.focus();
          try {
            const el = promptRef.current;
            el.selectionStart = el.value.length;
            el.selectionEnd = el.value.length;
          } catch {}
        }
      }, [row.type, isSelected]);

      const headingRef = useRef(null);
      useEffect(() => {
        if (row.type === 'settings-panel' && isSelected && headingRef.current) {
          headingRef.current.focus();
          headingRef.current.select();
        }
      }, [row.type, isSelected]);

      return (
        <div key={row.key}>
          <div
            className={classes.join(' ')}
            style={style}
            onClick={() => onLineClick(row)}
            draggable={inReorderMode && (row.type==='instr' || row.type==='module-item')}
            onDragStart={e => onDragStart(e, row)}
            onDragOver={e => onDragOver(e, row)}
            onDrop={e => onDrop(e, row)}
            onDragEnd={onDragEnd}
          >
            <span>{row.label}</span>
          </div>

          {row.type === 'prompt' && (
            <div className="indent-block indent-grid" style={{ paddingLeft: (row.depth || 0) * TAB }}>
              <textarea
                ref={promptRef}
                className="underline-textarea"
                value={store.get(row.promptKey, '')}
                onChange={e => onTextChange(row.promptKey, e.target.value)}
                placeholder={row.ownerType === 'module' ? 'Module prompt…' : 'Instruction prompt…'}
              />
            </div>
          )}

          {row.type === 'settings-panel' && (
            <div className="indent-block indent-grid" style={{ paddingLeft: (row.depth || 0) * TAB }}>
              <input
                ref={headingRef}
                type="text"
                className="underline-input"
                value={getNameOverride(row.nameOverrideKey, '')}
                onChange={(e) => setNameOverride(row.nameOverrideKey, e.target.value)}
                placeholder="Heading…"
              />
              <textarea
                className="underline-textarea"
                value={getMeta(row.metaKey) || ''}
                onChange={(e) => setMeta(row.metaKey, e.target.value)}
                placeholder="Meta information…"
              />
              <textarea
                className="underline-textarea"
                value={store.get(row.promptKey, '')}
                onChange={(e) => onTextChange(row.promptKey, e.target.value)}
                placeholder={row.ownerType === 'module' ? 'Module prompt…' : 'Instruction prompt…'}
              />
              <StructureDots5
                id={row.ownerId}
                value={getStruct(row.structKey) || 'medium'}
                onChange={(v) => setStruct(row.structKey, v)}
              />
            </div>
          )}

          {showAdder && (
            <SearchAdder
              type={addingState.type}
              query={addingState.query}
              setQuery={addingState.setQuery}
              onAdd={onAddingComplete}
              onCancel={onAddingCancel}
              store={store}
              indentPx={(row.depth + 1) * TAB}
            />
          )}
        </div>
      );
    }

    function App() {
      const storeRef = useRef(new DataStore());
      const store = storeRef.current;

      const [storeVersion, setStoreVersion] = useState(store.getVersion());
      const [path, setPath] = useState(() => {
        const hash = window.location.hash.slice(1);
        if (hash) { const parts = hash.split('/').filter(Boolean); if (parts.length > 0) return parts; }
        return ['expert-maker'];
      });

      const [idx, setIdx] = useState(0);
      const [navHistory, setNavHistory] = useState({});
      const [reorderState, setReorderState] = useState(null);
      const [dragItem, setDragItem] = useState(null);
      const [dragOver, setDragOver] = useState(null);
      const [addingState, setAddingState] = useState({ isAdding: false, type: null, query: '' });

      const [revealedOwnerKey, setRevealedOwnerKey] = useState(null);
      const [settingsOpen, setSettingsOpen] = useState({});
      const [deleteMode, setDeleteMode] = useState({ active: false });

      // Global search state (keyboard '/')
      const [globalSearchOpen, setGlobalSearchOpen] = useState(false);
      const [globalSearchQuery, setGlobalSearchQuery] = useState('');
      const [globalSearchIndex, setGlobalSearchIndex] = useState(0);
      const globalSearchInputRef = useRef(null);

      const rows = useMemo(() => {
        const builder = new RowBuilder(store, path, reorderState, revealedOwnerKey, settingsOpen, deleteMode);
        return builder.build();
      }, [store, path, reorderState, revealedOwnerKey, settingsOpen, deleteMode, storeVersion]);

      const rowsRef = useRef(rows);
      useEffect(() => { rowsRef.current = rows; }, [rows]);

      const atAgent = path.length === 1;
      const atModule = path.length >= 2;
      const agent = store.getDbItem(path[0]) || store.getDbItem('expert-maker');
      const module = atModule ? store.getDbItem(path[path.length - 1]) : null;

      const updateData = useCallback((key, value) => { store.set(key, value); setStoreVersion(store.getVersion()); }, [store]);

      const resetAll = useCallback(() => {
        if (confirm('Reset everything to defaults? This will clear all your customizations.')) {
          store.reset();
          setPath(['expert-maker']); setIdx(2); setNavHistory({}); setReorderState(null);
          setAddingState({ isAdding: false, type: null, query: '' });
          setRevealedOwnerKey(null); setSettingsOpen({}); setDeleteMode({ active: false });
          setGlobalSearchOpen(false); setGlobalSearchQuery(''); setGlobalSearchIndex(0);
          window.location.hash = ''; setStoreVersion(store.getVersion());
        }
      }, [store]);

      const navigateToPath = useCallback((newPath, autoSelect = true) => {
        setPath(newPath); setReorderState(null);
        setAddingState({ isAdding: false, type: null, query: '' });
        setRevealedOwnerKey(null); setSettingsOpen({}); setDeleteMode({ active: false });
        setIdx(autoSelect ? (newPath.length === 1 ? 2 : 3) : 0);
      }, []);

      const addModuleToAgent = useCallback((moduleResult) => {
        if (!agent) return;
        const key = `mods-${agent.name}`;
        const arr = store.get(key, agent.modules || []);
        updateData(key, [...arr, moduleResult.id]);
      }, [agent, store, updateData]);

      const addInstructionToModule = useCallback((instructionResult) => {
        if (!module) return;
        const arr = store.get(`items-${module.name}`, module.items || []);
        if (instructionResult.isNew) {
          const newId = 'custom-' + Date.now();
          store.addCustomDbItem(newId, { name: instructionResult.name, type: 'instr', text: '' });
          updateData(`items-${module.name}`, [...arr, newId]); setStoreVersion(store.getVersion());
        } else {
          updateData(`items-${module.name}`, [...arr, instructionResult.id]);
        }
      }, [module, store, updateData]);

      const removeItem = useCallback((pos) => {
        if (!atModule || !module || pos === undefined || pos === null) return;
        const arr = store.get(`items-${module.name}`, module.items || []);
        updateData(`items-${module.name}`, arr.filter((_, i) => i !== pos));
      }, [atModule, module, store, updateData]);

      const removeModule = useCallback((pos) => {
        if (!agent || pos === undefined || pos === null) return;
        const arr = store.get(`mods-${agent.name}`, agent.modules || []);
        updateData(`mods-${agent.name}`, arr.filter((_, i) => i !== pos));
      }, [agent, store, updateData]);

      const duplicateItem = useCallback((dbId, isModule, insertAtPos = null) => {
        const item = store.getDbItem(dbId); if (!item) return;
        if (isModule) {
          if (!agent) return;
          const arr = store.get(`mods-${agent.name}`, agent.modules || []);
          const newArr = [...arr];
          const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
          newArr.splice(at, 0, dbId); updateData(`mods-${agent.name}`, newArr);
        } else {
          if (!module) return;
          const arr = store.get(`items-${module.name}`, module.items || []);
          const newId = 'custom-' + Date.now();
          const baseName = displayNameFor(store, item, dbId);
          const baseText = store.get(`t-${item.name}`, item.text || '');
          store.addCustomDbItem(newId, { name: baseName + ' (copy)', type: 'instr', text: baseText });
          const newArr = [...arr];
          const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
          newArr.splice(at, 0, newId); updateData(`items-${module.name}`, newArr);
          updateData(`nn-${newId}`, baseName + ' (copy)'); updateData(`t-${newId}`, baseText); setStoreVersion(store.getVersion());
        }
      }, [agent, module, store, updateData]);

      const blockedFooter = new Set(['adder','trash','trash-mod','cancel-reorder','settings-button','settings-panel','prompt']);
      const canLandOn = (row, type) => (type === 'instr' ? row.type === 'instr' : row.type === 'module-item');

      const moveItemInReorderMode = useCallback((direction) => {
        if (!reorderState) return;
        const delta = direction === 'up' ? -1 : 1;
        const newCurrentPos = reorderState.currentPos + delta;

        let arr = [];
        if (reorderState.type === 'instr' && atModule && module) arr = store.get(`items-${module.name}`, module.items || []);
        else if (reorderState.type === 'module-item' && agent) arr = store.get(`mods-${agent.name}`, agent.modules || []);

        if (newCurrentPos >= 0 && newCurrentPos < arr.length) {
          let candidateIdx = idx + delta;
          const within = i => i >= 0 && i < rows.length;
          while (within(candidateIdx)) {
            const targetRow = rows[candidateIdx];
            if (!blockedFooter.has(targetRow.type) && canLandOn(targetRow, reorderState.type)) break;
            candidateIdx += delta;
          }
          if (!within(candidateIdx)) return;
          setReorderState(prev => ({ ...prev, currentPos: newCurrentPos })); setIdx(candidateIdx);
        }
      }, [reorderState, idx, rows, atModule, module, agent, store]);

      const findPlacedIndex = useCallback((type, pos, ownerId) => {
        return rows.findIndex(r =>
          (type === 'instr' ? r.type === 'instr' : r.type === 'module-item') &&
          (type === 'instr' ? r.dbId === ownerId : r.moduleId === ownerId) &&
          r.pos === pos
        );
      }, [rows]);

      const commitReorder = useCallback(() => {
        if (!reorderState) return;
        const originalPos = reorderState.originalPos;
        const currentPos = (reorderState.currentPos !== undefined) ? reorderState.currentPos : originalPos;

        if (currentPos !== originalPos && currentPos >= 0) {
          if (reorderState.type === 'instr' && atModule && module) {
            const arr = store.get(`items-${module.name}`, module.items || []); updateData(`items-${module.name}`, moveInList(arr, originalPos, currentPos));
          } else if (reorderState.type === 'module-item' && agent) {
            const arr = store.get(`mods-${agent.name}`, agent.modules || []); updateData(`mods-${agent.name}`, moveInList(arr, originalPos, currentPos));
          }
        }

        const ownerId = reorderState.dbId || reorderState.moduleId;
        const targetIdx = findPlacedIndex(reorderState.type, currentPos, ownerId);
        setReorderState(null);
        if (targetIdx >= 0) setIdx(targetIdx);
      }, [reorderState, atModule, module, agent, store, updateData, findPlacedIndex]);

      const deleteMovingIfAny = useCallback(() => {
        if (!reorderState) return false;
        if (reorderState.type === 'instr') { removeItem(reorderState.originalPos); setReorderState(null); setIdx(prev => Math.max(0, Math.min(prev, rows.length - 2))); return true; }
        if (reorderState.type === 'module-item') { removeModule(reorderState.originalPos); setReorderState(null); setIdx(prev => Math.max(0, Math.min(prev, rows.length - 2))); return true; }
        return false;
      }, [reorderState, removeItem, removeModule, rows.length]);

      const deleteSelectedIfAny = useCallback((sel) => {
        if (!sel) return false;
        if (sel.type === 'instr' && atModule) { removeItem(sel.pos); setIdx(prev => Math.max(0, Math.min(prev, rows.length - 2))); return true; }
        if (sel.type === 'module-item') { removeModule(sel.pos); setIdx(prev => Math.max(0, Math.min(prev, rows.length - 2))); return true; }
        return false;
      }, [atModule, removeItem, removeModule, rows.length]);

      const handleDragStart = useCallback((e, row) => { e.dataTransfer.effectAllowed = 'move'; setDragItem(row); }, []);
      const handleDragOver = useCallback((e, row) => { e.preventDefault(); if (!dragItem) return; e.dataTransfer.dropEffect = 'move'; setDragOver(row.key); }, [dragItem]);
      const handleDrop = useCallback((e, row) => {
        e.preventDefault(); if (!dragItem) return;

        if (row.type === 'trash') {
          if (dragItem.type === 'instr') removeItem(dragItem.pos);
          else if (dragItem.type === 'module-item') removeModule(dragItem.pos);
          setDragItem(null); setDragOver(null); setRevealedOwnerKey(null); setSettingsOpen({}); return;
        }
        if (row.type === 'adder' && dragItem.type === 'instr' && atModule && module) {
          duplicateItem(dragItem.dbId, false, dragItem.pos); setDragItem(null); setDragOver(null); return;
        }
        if (row.type === 'adder-mod' && dragItem.type === 'module-item' && agent) {
          duplicateItem(dragItem.moduleId, true, dragItem.pos); setDragItem(null); setDragOver(null); return;
        }

        if (dragItem.type === 'instr' && row.type === 'instr' && atModule && module) {
          const arr = store.get(`items-${module.name}`, module.items || []); updateData(`items-${module.name}`, moveInList(arr, dragItem.pos, row.pos));
          const newIdx = findPlacedIndex('instr', row.pos, row.dbId); if (newIdx >= 0) setIdx(newIdx);
        } else if (dragItem.type === 'module-item' && row.type === 'module-item' && agent) {
          const arr = store.get(`mods-${agent.name}`, agent.modules || []); updateData(`mods-${agent.name}`, moveInList(arr, dragItem.pos, row.pos));
          const newIdx = findPlacedIndex('module-item', row.pos, row.moduleId); if (newIdx >= 0) setIdx(newIdx);
        }

        setDragItem(null); setDragOver(null);
      }, [dragItem, atModule, module, agent, store, updateData, findPlacedIndex, removeItem, removeModule, duplicateItem]);

      const handleDragEnd = useCallback(() => { setDragItem(null); setDragOver(null); }, []);

      // find module for instruction
      const findModuleForInstruction = useCallback((instrId) => {
        if (!agent) return null;
        const mods = store.get(`mods-${agent.name}`, agent.modules || []);
        for (const mid of mods) {
          const mod = store.getDbItem(mid); if (!mod) continue;
          const items = store.get(`items-${mod.name}`, mod.items || []);
          if (items.includes(instrId)) return mid;
        }
        return null;
      }, [agent, store, storeVersion]);

      // global search selection
      const selectGlobalSearchItem = useCallback((item) => {
        if (!item) return;
        if (item.type === 'agent') {
          navigateToPath([item.id], true);
          setTimeout(() => { setIdx(2); }, 0);
        } else if (item.type === 'mod') {
          const aid = 'expert-maker';
          navigateToPath([aid, item.id], true);
          setTimeout(() => {
            const rIdx = rowsRef.current.findIndex(r => r.type === 'module' && r.moduleId === item.id);
            if (rIdx >= 0) setIdx(rIdx);
          }, 0);
        } else if (item.type === 'instr') {
          const mid = findModuleForInstruction(item.id);
          const aid = 'expert-maker';
          if (mid) {
            navigateToPath([aid, mid], true);
            setRevealedOwnerKey(`instr:${item.id}`);
            setTimeout(() => {
              const rIdx = rowsRef.current.findIndex(r => r.type === 'instr' && r.dbId === item.id);
              if (rIdx >= 0) setIdx(rIdx);
            }, 0);
          } else {
            navigateToPath([aid], true);
            setTimeout(() => { setIdx(2); }, 0);
          }
        }
        setGlobalSearchOpen(false);
      }, [navigateToPath, findModuleForInstruction]);

      const globalSearchResults = useMemo(() => {
        return searchDatabase(store.getAllDb(), globalSearchQuery, null);
      }, [globalSearchQuery, store]);
      useEffect(() => { setGlobalSearchIndex(0); }, [globalSearchQuery]);
      useEffect(() => {
        if (globalSearchOpen) {
          setTimeout(() => { if (globalSearchInputRef.current) globalSearchInputRef.current.focus(); }, 0);
        }
      }, [globalSearchOpen]);

      const handleKeyDown = useCallback((e) => {
        const sel = rows[idx]; if (!sel) return;

        const activeEl = document.activeElement;
        const inTextarea = activeEl && (activeEl.tagName === 'TEXTAREA' || (activeEl.tagName === 'INPUT' && activeEl.type === 'text'));

        // '/' opens global search when not typing
        if (!inTextarea && e.key === '/') {
          e.preventDefault();
          setGlobalSearchOpen(true);
          setGlobalSearchQuery('');
          setGlobalSearchIndex(0);
          return;
        }

        if (inTextarea) {
          const valueLength = activeEl.value.length;
          const start = activeEl.selectionStart ?? 0;
          const end = activeEl.selectionEnd ?? 0;

          if ((e.key === 'ArrowLeft' || e.key === 'ArrowUp') && start === 0 && end === 0) {
            e.preventDefault();
            activeEl.blur();
            setIdx(prev => Math.max(0, prev - 1));
            return;
          }
          if ((e.key === 'ArrowRight' || e.key === 'ArrowDown') && start === valueLength && end === valueLength) {
            e.preventDefault();
            activeEl.blur();
            setIdx(prev => Math.min(rows.length - 1, prev + 1));
            return;
          }
          return;
        }

        const inReorderMode = !!reorderState;
        const gotoIndex = (nextIdx) => {
          const nextRow = rows[nextIdx];
          const currentOwner = revealedOwnerKey;
          if (currentOwner) {
            const ok = ownerKeyOfRow(nextRow);
            if (ok !== currentOwner) {
              const pKey = `spanel:${currentOwner}`;
              setSettingsOpen(prev => { if (!prev[pKey]) return prev; const copy = { ...prev }; delete copy[pKey]; return copy; });
              setRevealedOwnerKey(null);
            }
          }
          setIdx(nextIdx);
        };

        if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (inReorderMode) { moveItemInReorderMode('up'); }
          else { gotoIndex(Math.max(0, idx - 1)); }
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (inReorderMode) { moveItemInReorderMode('down'); }
          else { gotoIndex(Math.min(rows.length - 1, idx + 1)); }
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          if (inReorderMode) { commitReorder(); return; }
          if (deleteMode.active) { return; }
          if (sel.type === 'settings-panel') {
            setSettingsOpen(s => ({ ...s, [sel.key]: false }));
            return;
          }
          if (sel.type === 'settings-button' || sel.type === 'prompt') {
            const ownerIdx = Math.max(0, idx - 1);
            const currentOwner = revealedOwnerKey;
            if (currentOwner) {
              const pKey = `spanel:${currentOwner}`; setSettingsOpen(prev => { if (!prev[pKey]) return prev; const copy = { ...prev }; delete copy[pKey]; return copy; });
            }
            setRevealedOwnerKey(null);
            setIdx(ownerIdx);
            return;
          }
          if (sel.canReorder && !deleteMode.active) {
            setReorderState({ rowKey: sel.key, dbId: sel.dbId || sel.moduleId, type: sel.type, originalIdx: idx, originalPos: sel.pos, currentPos: sel.pos });
            return;
          }
          if (path.length > 1) {
            const newPath = path.slice(0, -1);
            const pathKey = newPath.join('/'); const savedIdx = navHistory[pathKey];
            setRevealedOwnerKey(null); setSettingsOpen({}); setDeleteMode({ active: false });
            setPath(newPath);
            setIdx(savedIdx !== undefined ? savedIdx : (newPath.length === 1 ? 2 : 3));
          }
        } else if (e.key === 'ArrowRight' || e.key === 'Enter') {
          e.preventDefault();
          if (inReorderMode) { commitReorder(); return; }

          if (sel.type === 'trash') {
            setDeleteMode(m => ({ active: !m.active }));
            return;
          }
          if (deleteMode.active) {
            if (sel.type === 'instr' && atModule) {
              removeItem(sel.pos);
              setTimeout(() => {
                setDeleteMode({ active: false });
                const t = rowsRef.current.findIndex(r => r.type === 'trash');
                if (t >= 0) setIdx(t);
              }, 0);
            }
            return;
          }

          if (sel.type === 'module-item') {
            const key = `mod:${sel.moduleId}`;
            if (revealedOwnerKey !== key) {
              setRevealedOwnerKey(key);
            } else {
              const pathKey = path.join('/'); setNavHistory(h => ({ ...h, [pathKey]: idx }));
              setRevealedOwnerKey(null); setSettingsOpen({}); setDeleteMode({ active: false });
              setPath([...path, sel.moduleId]);
              setIdx(3);
            }
          } else if (sel.type === 'instr') {
            const key = `instr:${sel.dbId}`;
            if (revealedOwnerKey !== key) {
              setRevealedOwnerKey(key);
            }
          } else if (sel.type === 'settings-button') {
            const pKey = sel.ownerType === 'module' ? `spanel:mod:${sel.ownerId}` : `spanel:instr:${sel.ownerId}`;
            setSettingsOpen(s => ({ ...s, [pKey]: !s[pKey] }));
          } else if (sel.type === 'adder') {
            setAddingState({ isAdding: true, type: 'instruction', query: '' });
          } else if (sel.type === 'adder-mod') {
            setAddingState({ isAdding: true, type: 'module', query: '' });
          }
        } else if ((e.key === 'Delete') || (e.key === '-')) {
          e.preventDefault();
          if (inReorderMode) { if (deleteMovingIfAny()) return; }
          else {
            if (deleteMode.active) {
              if (sel.type === 'instr' && atModule) {
                removeItem(sel.pos);
                setTimeout(() => {
                  setDeleteMode({ active: false });
                  const t = rowsRef.current.findIndex(r => r.type === 'trash');
                  if (t >= 0) setIdx(t);
                }, 0);
              }
            } else {
              if (deleteSelectedIfAny(sel)) return;
            }
          }
        } else if (e.key === 'Escape') {
          e.preventDefault();
          if (inReorderMode) { setReorderState(null); return; }
          if (deleteMode.active) { setDeleteMode({ active: false }); return; }
          if (revealedOwnerKey) {
            const pKey = `spanel:${revealedOwnerKey}`;
            setSettingsOpen(prev => { if (!prev[pKey]) return prev; const copy = { ...prev }; delete copy[pKey]; return copy; });
            setRevealedOwnerKey(null);
          }
        }
      }, [
        rows, idx, reorderState, path, navHistory,
        revealedOwnerKey, moveItemInReorderMode, commitReorder,
        deleteMovingIfAny, deleteSelectedIfAny, settingsOpen,
        deleteMode, atModule, removeItem, module, rowsRef
      ]);

      useEffect(() => { window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [handleKeyDown]);

      const handleLineClick = useCallback((row) => {
        const rowIdx = rows.findIndex(r => r.key === row.key);
        if (rowIdx !== -1) setIdx(rowIdx);

        if (row.type === 'trash') {
          setDeleteMode(m => ({ active: !m.active }));
          return;
        }

        if (deleteMode.active) {
          if (row.type === 'instr' && atModule) {
            removeItem(row.pos);
            setTimeout(() => {
              setDeleteMode({ active: false });
              const t = rowsRef.current.findIndex(r => r.type === 'trash');
              if (t >= 0) setIdx(t);
            }, 0);
          }
          return;
        }

        if (row.type === 'module-item') {
          const key = `mod:${row.moduleId}`;
          if (revealedOwnerKey !== key) {
            setRevealedOwnerKey(key);
          } else {
            const pathKey = path.join('/'); setNavHistory(h => ({ ...h, [pathKey]: rowIdx }));
            setRevealedOwnerKey(null); setSettingsOpen({}); setDeleteMode({ active: false });
            setPath([...path, row.moduleId]); setIdx(3);
          }
        } else if (row.type === 'instr') {
          const key = `instr:${row.dbId}`;
          if (revealedOwnerKey !== key) {
            setRevealedOwnerKey(key);
          }
        } else if (row.type === 'settings-button') {
          const pKey = row.ownerType === 'module' ? `spanel:mod:${row.ownerId}` : `spanel:instr:${row.ownerId}`;
          setSettingsOpen(s => ({ ...s, [pKey]: !s[pKey] }));
        } else {
          if (revealedOwnerKey) {
            const ok = ownerKeyOfRow(row);
            if (ok !== revealedOwnerKey) { setRevealedOwnerKey(null); setSettingsOpen({}); }
          }
        }
      }, [rows, path, revealedOwnerKey, deleteMode, atModule, removeItem]);

      useEffect(() => {
        const hash = '#' + path.join('/'); if (window.location.hash !== hash) window.history.pushState(null, '', hash);
        if (!window.location.hash) setIdx(path.length === 1 ? 2 : 3);
      }, [path]);

      useEffect(() => {
        const handlePopState = () => {
          const hash = window.location.hash.slice(1);
          if (hash) {
            const parts = hash.split('/').filter(Boolean);
            if (parts.length > 0) navigateToPath(parts, true);
          } else navigateToPath(['expert-maker'], true);
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, [navigateToPath]);

      const handleAddingComplete = useCallback((result) => {
        if (addingState.type === 'module') addModuleToAgent(result);
        else if (addingState.type === 'instruction') addInstructionToModule(result);
        setAddingState({ isAdding: false, type: null, query: '' });
      }, [addingState.type, addModuleToAgent, addInstructionToModule]);
      const handleAddingCancel = useCallback(() => { setAddingState({ isAdding: false, type: null, query: '' }); }, []);

      const promptText = useMemo(() => {
        let text = '(: Smile Composer\n    ' + store.get(`n-${agent.name}`, agent.name);
        if (atModule) {
          text += path.slice(1).map(mid => {
            const m = store.getDbItem(mid);
            const name = m ? displayNameFor(store, m, mid) : '';
            return m ? '\n        ' + name : '';
          }).join('');
        }
        return text;
      }, [path, agent, atModule, store, storeVersion]);

      const allTextContent = useMemo(() => {
        let parts = [];
        if (atModule && module) {
          const ids = store.get(`items-${module.name}`, module.items || []);
          ids.forEach(id => {
            const it = store.getDbItem(id); if (!it) return;
            const name = store.get(`nn-${id}`, displayNameFor(store, it, id));
            const text = store.get(`t-${it.name}`, it.text || '');
            const meta = store.get(`meta-${id}`, '');
            parts.push(`${name}\n${text}${meta ? `\n(meta) ${meta}` : ''}`);
          });
        } else if (agent) {
          const mods = store.get(`mods-${agent.name}`, agent.modules || []);
          mods.forEach(mid => {
            const m = store.getDbItem(mid); if (!m) return;
            const mname = displayNameFor(store, m, mid);
            parts.push(`== ${mname} ==`);
            const ids = store.get(`items-${m.name}`, m.items || []);
            ids.forEach(id => {
              const it = store.getDbItem(id); if (!it) return;
              const name = store.get(`nn-${id}`, displayNameFor(store, it, id));
              const text = store.get(`t-${it.name}`, it.text || '');
              const meta = store.get(`meta-${id}`, '');
              parts.push(`${name}\n${text}${meta ? `\n(meta) ${meta}` : ''}`);
            });
          });
        }
        return parts.join('\n\n');
      }, [storeVersion, path, atModule, module, agent, store]);

      const outputKey = atModule && module ? `output-${module.name}` : `output-${agent.name}`;
      const outputDefault = atModule ? '' : agent.output;

      const onGlobalSearchKeyDown = (e) => {
        const has = globalSearchResults.length > 0;
        if (e.key === 'Enter') {
          e.preventDefault();
          if (has) {
            const gi = Math.max(0, Math.min(globalSearchIndex, globalSearchResults.length - 1));
            selectGlobalSearchItem(globalSearchResults[gi]);
          }
        } else if (e.key === 'Escape') {
          e.preventDefault();
          setGlobalSearchOpen(false);
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (has) setGlobalSearchIndex(prev => Math.min(globalSearchResults.length - 1, prev + 1));
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (has) setGlobalSearchIndex(prev => Math.max(0, prev - 1));
        }
      };

      return (
        <div className="container">
          <div className="panel">
            <div className="panel-title">
              <span>Smile Composer</span>
              <span className="panel-subtle">Use ↑ ↓ ← →, Enter, Esc, /</span>
            </div>
            {rows.map((row, i) => {
              const isSelected = i === idx;
              const inReorderMode = reorderState && row.key === reorderState.rowKey;
              const isDragging = dragItem && dragItem.key === row.key;
              const isDropTarget = dragOver === row.key;

              return (
                <LineRenderer
                  key={row.key}
                  row={row}
                  isSelected={isSelected}
                  inReorderMode={!!inReorderMode}
                  isDragging={!!isDragging}
                  isDropTarget={!!isDropTarget}
                  store={store}
                  onLineClick={handleLineClick}
                  onTextChange={updateData}
                  onDragStart={handleDragStart}
                  onDragOver={handleDragOver}
                  onDrop={handleDrop}
                  onDragEnd={handleDragEnd}
                  addingState={{ ...addingState, setQuery: (q) => setAddingState(s => ({ ...s, query: q })) }}
                  onAddingComplete={handleAddingComplete}
                  onAddingCancel={handleAddingCancel}
                  getStruct={(k) => store.get(k, 'medium')}
                  setStruct={(k,v) => updateData(k, v)}
                  getNameOverride={(k, f) => store.get(k, f || '')}
                  setNameOverride={(k, v) => updateData(k, v)}
                  getMeta={(k) => store.get(k, '')}
                  setMeta={(k, v) => updateData(k, v)}
                />
              );
            })}
          </div>

          <div className="panel">
            <div className="panel-title">
              <span>Search</span>
              <span className="panel-subtle">Hotkey: /</span>
            </div>
            {!globalSearchOpen && (
              <button className="btn" onClick={() => { setGlobalSearchOpen(true); setTimeout(() => globalSearchInputRef.current && globalSearchInputRef.current.focus(), 0); }}>
                Open Search [/]
              </button>
            )}
            {globalSearchOpen && (
              <div className="search-wrap">
                <input
                  ref={globalSearchInputRef}
                  className="underline-input"
                  placeholder="Search agents, modules, instructions…"
                  value={globalSearchQuery}
                  onChange={(e) => setGlobalSearchQuery(e.target.value)}
                  onKeyDown={onGlobalSearchKeyDown}
                />
                <div className="search-list">
                  {globalSearchResults.length === 0 && (
                    <div className="search-item"><span>No matches</span></div>
                  )}
                  {globalSearchResults.map((res, i) => (
                    <div
                      key={res.id + ':' + res.type}
                      className={`search-item${i === globalSearchIndex ? ' selected' : ''}`}
                      onMouseEnter={() => setGlobalSearchIndex(i)}
                      onClick={() => selectGlobalSearchItem(res)}
                    >
                      <span>{res.name}</span>
                      <span className="search-badge">{res.type}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>

          <div className="panel">
            <div className="panel-title"><span>Structure</span></div>
            <TreeView store={store} path={path} onNavigate={navigateToPath} storeVersion={storeVersion} />
          </div>

          <div className="panel">
            <div className="panel-title"><span>Prompt</span></div>
            <textarea
              readOnly
              value={promptText}
              className="underline-textarea"
              style={{ minHeight: '120px' }}
            />
            <div style={{ height: 8 }}></div>
            <button className="btn" data-hotkey-scope="ui" onClick={() => {
              const wrap = document.getElementById('alltext-wrapper');
              if (wrap) wrap.style.display = (wrap.style.display === 'none' ? '' : 'none');
            }}>Show / Hide All Text</button>
            <div id="alltext-wrapper" style={{ marginTop: 8 }}>
              <textarea className="alltext" readOnly value={allTextContent}></textarea>
            </div>
          </div>

          <div className="panel">
            <div className="panel-title">
              <span>Output</span>
              <button className="btn" data-hotkey-scope="ui" onClick={resetAll}>Reset All</button>
            </div>
            <textarea
              className="underline-textarea"
              value={store.get(outputKey, outputDefault)}
              onChange={e => updateData(outputKey, e.target.value)}
              style={{ minHeight: '150px' }}
            ></textarea>
          </div>
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div class="error">Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
