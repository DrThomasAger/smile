<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Smile Composer — Text-First Actions, Direct Edit, Live Move</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { --tab: 32px; --soft-bg: #fafafa; --hover-bg: #f6f6f6; --select-bg: #f2f2f2; --rule: rgba(0,0,0,0.08); }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif; background: #fff; color: #111; padding: 24px; margin: 0; }
    .container { display: block; width: 100%; }

    .panel { background: #fff; padding: 16px; box-shadow: 0 1px 0 0 var(--rule); margin-top: 20px; border-radius: 10px; }
    .panel-title { font-weight: 600; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; gap: 8px; flex-wrap: wrap; }
    .panel-title .clickable { cursor: pointer; }
    .panel-title-right { display: inline-flex; align-items: center; gap: 8px; }

    /* Omnisearch */
    .omni { position: sticky; top: 0; z-index: 10; background: #fff; padding: 8px 0 0 0; margin-bottom: 8px; }
    .omni-bar { display: grid; grid-template-columns: 1fr auto auto; gap: 8px; align-items: center; padding: 10px 12px; border-radius: 999px; background: var(--soft-bg); box-shadow: 0 1px 0 0 var(--rule); }
    .omni-input { border: none; outline: none; background: transparent; font: inherit; padding: 6px 2px; }
    .omni-mode { display: inline-flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 999px; background: #fff; visibility: hidden; }
    .omni-mode.show { visibility: visible; }
    .omni-mode button { font: inherit; background: transparent; border: none; padding: 6px 10px; border-radius: 999px; cursor: pointer; }
    .omni-mode .active { background: var(--select-bg); font-weight: 600; }
    .omni-drawer { margin-top: 8px; border-radius: 12px; padding: 8px; background: #fff; }
    .omni-list { max-height: 320px; overflow: auto; display: grid; gap: 6px; }
    .omni-item { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; background: var(--soft-bg); border-radius: 12px; cursor: pointer; }
    .omni-item:hover { background: var(--hover-bg); }
    .omni-item.sel { background: var(--select-bg); font-weight: 600; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; background: #eee; }
    .subtle { font-size: 12px; color: #666; }

    .line { user-select: none; padding: 8px 10px; border-radius: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; cursor: pointer; transition: background-color 0.12s ease, opacity 0.12s ease; touch-action: none; position: relative; }
    .line:hover { background-color: var(--hover-bg); }
    .line.sel { font-weight: 600; background-color: var(--select-bg); }
    .line.reorder-mode { font-weight: 700; background-color: #eee; }
    .line.held { opacity: 0.35; }
    .line.drop-target { outline: 3px solid #111; outline-offset: -3px; border-radius: 12px; }
    .left-span { flex: 1 1 auto; min-width: 0; }

    .actions-text { font-size: 12px; color: #222; }
    .actions-text .sep { color: #888; }
    .actions-text .focus { font-weight: 700; }

    .indent-block { margin-top: 8px; }
    .underline-input, .underline-textarea { width: 100%; background: transparent; border: none; border-bottom: 1px solid #ccc; border-radius: 0; padding: 6px 2px 6px 0; font: inherit; outline: none; resize: vertical; min-height: 34px; }
    .underline-textarea { min-height: 80px; }

    .tree-view { max-height: 500px; overflow: auto; font-size: 13px; line-height: 1.8; }
    .tree-item { padding: 6px 8px; cursor: pointer; user-select: none; border-radius: 8px; }
    .tree-item:hover { background: var(--hover-bg); }
    .tree-item.active { font-weight: 700; background: var(--select-bg); }

    .error { color: red; padding: 20px; border: 1px solid red; margin: 20px; border-radius: 8px; }

    .seg { display: inline-flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 999px; background: var(--soft-bg); }
    .seg .label { font-size: 12px; margin-right: 4px; }
    .seg input[type="radio"] { position: absolute; opacity: 0; pointer-events: none; }
    .seg .opt { display: inline-flex; align-items: center; gap: 6px; padding: 4px 8px; border-radius: 999px; }
    .seg .dot { width: 8px; height: 8px; border-radius: 50%; background: #bbb; display: inline-block; }
    .seg input[type="radio"]:checked + .opt .dot { background: #111; }

    .alltext { width: 100%; min-height: 220px; padding: 10px; border: none; border-bottom: 1px solid #ccc; border-radius: 0; resize: vertical; background: #fff; }

    .prompt-preview { white-space: pre-wrap; font-size: 13px; color: #222; }
    .instructional { font-size: 13px; color: #333; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div class="error">Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useCallback, useMemo } = React;
    const TAB = 32;

    const INITIAL_DB = {
      'expert-maker': { name: 'Expert Maker', type: 'agent', input: 'Question', output: 'Answer', modules: ['meta-info', 'jargon-cot', 'identify-mistakes'] },
      'input-mod': { name: 'INPUT: Question', type: 'mod', items: ['input-enter', 'input-understand', 'input-result'] },
      'output-mod': { name: 'OUTPUT: Answer', type: 'mod', items: ['output-enter', 'output-understand', 'output-result'] },
      'meta-info': { name: 'Meta-Information MegaBrick', type: 'mod', items: ['smile-info', 'llm-info', 'user-info'] },
      'jargon-cot': { name: 'Jargon CoT', type: 'mod', items: ['emoji-section', 'bold-words', 'top-bottom'] },
      'identify-mistakes': { name: 'Identify Mistakes and Rewrite', type: 'mod', items: ['emoji-section', 'bold-words', 'negative-rewrite'] },
      'smile-info': { name: 'Information About (: Smile', type: 'instr', text: 'Explain Smile syntax: (: flexible, [: rigid, [= literal.' },
      'llm-info': { name: 'Information About LLMs', type: 'instr', text: 'Meta-knowledge about how LLMs process instructions.' },
      'user-info': { name: 'Information About User', type: 'instr', text: 'Contextualize user needs and goals.' },
      'emoji-section': { name: 'Emoji section name', type: 'instr', text: 'Use two emoticons for section names.' },
      'bold-words': { name: 'Bold for important words', type: 'instr', text: 'Use **bold** for attention retention over long contexts.' },
      'top-bottom': { name: 'Maximize adherence through top+bottom replication', type: 'instr', text: 'Replicate critical instructions at beginning and end.' },
      'negative-rewrite': { name: 'Identify negatives and rewrite to positive', type: 'instr', text: 'Find negatives like “not” and rewrite as positive articulations.' },
      'input-enter': { name: 'Provide Input', type: 'instr', text: 'Enter or paste the incoming question or payload in full fidelity.' },
      'input-understand': { name: 'Reasoning / Understanding', type: 'instr', text: 'Interpret the input; list goals, constraints, and ambiguities.' },
      'input-result': { name: 'Synthesis (Input + Understanding)', type: 'instr', text: 'Combine the raw input with the understanding into a structured representation.' },
      'output-enter': { name: 'Draft Output', type: 'instr', text: 'Produce an initial answer or output shape based on the current state.' },
      'output-understand': { name: 'Quality / Checks', type: 'instr', text: 'Reason about correctness, coverage, and criteria; refine the output.' },
      'output-result': { name: 'Final Output', type: 'instr', text: 'Deliver the polished final output after reasoning and checks.' }
    };

    class DataStore {
      constructor() { this.data = this.loadFromStorage(); this.db = { ...INITIAL_DB }; this.version = 0; }
      loadFromStorage() { try { const stored = localStorage.getItem('smileData'); return stored ? JSON.parse(stored) : {}; } catch(e){ return {}; } }
      saveToStorage(data) { try { localStorage.setItem('smileData', JSON.stringify(data)); } catch(e){} }
      get(key, def) { return key in this.data ? this.data[key] : def; }
      set(key, value) { this.data = { ...this.data, [key]: value }; this.version++; this.saveToStorage(this.data); return this.data; }
      reset() { this.data = {}; localStorage.removeItem('smileData'); this.db = { ...INITIAL_DB }; this.version++; return this.data; }
      getDbItem(id) { return this.db[id] || null; }
      addCustomDbItem(id, item) { this.db[id] = item; this.version++; }
      getAllDb() { return this.db; }
      getVersion() { return this.version; }
    }

    const moveInList = (arr, fromPos, toPos) => {
      if (fromPos === toPos || fromPos < 0 || toPos < 0 || fromPos >= arr.length) return arr;
      const newArr = [...arr];
      const [item] = newArr.splice(fromPos, 1);
      const insertPos = Math.min(toPos, newArr.length);
      newArr.splice(insertPos, 0, item);
      return newArr;
    };

    const displayNameFor = (store, dbItem, id) =>
      store.get(`nn-${id}`, store.get(`n-${dbItem.name}`, dbItem.name));

    class RowBuilder {
      constructor(store, path) { this.store = store; this.path = path; this.rows = []; }
      build() { this.addRoot(); this.addAgent(); this.addBreadcrumbs(); if (this.isAtModule()) this.addModuleContent(); else this.addAgentModules(); return this.rows; }
      addRoot() { this.rows.push({ key: 'root', type: 'root', depth: 0, label: '(: Smile Composer' }); }
      addAgent() { const agent = this.getAgent(); if (!agent) return;
        this.rows.push({ key: `agent:${this.path[0]}`, type: 'agent', depth: 1, label: this.store.get(`n-${agent.name}`, agent.name) });
      }
      addBreadcrumbs() { if (this.path.length <= 2) return;
        for (let i = 1; i < this.path.length - 1; i++) {
          const breadcrumbMod = this.store.getDbItem(this.path[i]); if (!breadcrumbMod) continue;
          this.rows.push({ key: `breadcrumb:${i}`, type: 'breadcrumb', depth: i + 1, label: this.store.get(`n-${breadcrumbMod.name}`, breadcrumbMod.name), pathIndex: i });
        }
      }
      addModuleContent() {
        const module = this.getCurrentModule(); if (!module) return;
        const moduleDBKey = this.path[this.path.length - 1];
        this.rows.push({ key: `module:${moduleDBKey}`, type: 'module', depth: 2, label: this.store.get(`n-${module.name}`, module.name), moduleId: moduleDBKey });

        const items = this.store.get(`items-${module.name}`, module.items || []);
        const visualItems = items.map((item, idx) => ({ item, originalPos: idx }));

        visualItems.forEach(({ item: id, originalPos }, i) => {
          const ins = this.store.getDbItem(id); if (!ins) return;
          const isLast = i === visualItems.length - 1;
          this.rows.push({
            key: `ins:${id}:${originalPos}`, type: 'instr', depth: 3,
            label: displayNameFor(this.store, ins, id), isOutput: isLast,
            nameKey: `n-${ins.name}`, nameOverrideKey: `nn-${id}`,
            textKey: `t-${ins.name}`, defaultText: ins.text || '',
            metaKey: `meta-${id}`, structKey: `struct-${id}`,
            promptKey: `t-${ins.name}`, dbId: id, pos: originalPos, canReorder: true
          });
        });
      }
      addAgentModules() {
        const agent = this.getAgent(); if (!agent) return;
        const modules = this.store.get(`mods-${agent.name}`, agent.modules || []);
        const visualModules = modules.map((item, idx) => ({ item, originalPos: idx }));

        visualModules.forEach(({ item: mid, originalPos }, i) => {
          const mod = this.store.getDbItem(mid); if (!mod) return;
          const isLast = i === visualModules.length - 1;
          this.rows.push({
            key: `mod:${mid}:${originalPos}`, type: 'module-item', depth: 2,
            label: displayNameFor(this.store, mod, mid), isOutput: isLast,
            nameKey: `n-${mod.name}`, nameOverrideKey: `nn-${mid}`,
            moduleId: mid, pos: originalPos, canReorder: true
          });
        });

        this.rows.push({ key: `adder-mod-${agent.name}`, type: 'adder-mod', depth: 2, label: '+ Add Module' });
      }
      isAtModule() { return this.path.length >= 2; }
      getAgent() { return this.store.getDbItem(this.path[0]); }
      getCurrentModule() { return this.isAtModule() ? this.store.getDbItem(this.path[this.path.length - 1]) : null; }
    }

    function TreeView({ store, path, onNavigate, storeVersion }) {
      const renderModule = React.useCallback((modId, parentPath, depth) => {
        const mod = store.getDbItem(modId); if (!mod) return null;
        const modulePath = [...parentPath, modId];
        const isActive = path.join('/') === modulePath.join('/');
        const items = store.get(`items-${mod.name}`, mod.items || []);
        return (
          <div key={modId}>
            <div className={`tree-item${isActive ? ' active' : ''}`} style={{ paddingLeft: depth * 12 }} onClick={() => onNavigate(modulePath, true)}>
              {displayNameFor(store, mod, modId)}
            </div>
            {items.map(iid => {
              const ins = store.getDbItem(iid); if (!ins) return null;
              return (
                <div key={iid} className="tree-item" style={{ paddingLeft: (depth + 1) * 12 }}>
                  {displayNameFor(store, ins, iid)}
                </div>
              );
            })}
          </div>
        );
      }, [store, path, onNavigate, storeVersion]);

      const agentId = 'expert-maker';
      const agent = store.getDbItem(agentId);
      if (!agent) return null;
      const isAgentActive = path.length === 1 && path[0] === agentId;
      const modules = store.get(`mods-${agent.name}`, agent.modules || []);
      return (
        <div className="tree-view">
          <div className={`tree-item${isAgentActive ? ' active' : ''}`} onClick={() => onNavigate([agentId], true)}>
            {store.get(`n-${agent.name}`, agent.name)}
          </div>
          {modules.map(mid => renderModule(mid, [agentId], 1))}
        </div>
      );
    }

    function StructureDots5({ id, value, onChange }) {
      const opts = [
        { v: 'heavy', label: 'Heavy', aria: 'Heavy' },
        { v: 'heavy-mid', label: '●', aria: 'Between heavy and medium' },
        { v: 'medium', label: 'Medium', aria: 'Medium' },
        { v: 'medium-light', label: '●', aria: 'Between medium and light' },
        { v: 'light', label: 'Light', aria: 'Light' }
      ];
      return (
        <div className="seg" role="radiogroup" aria-label="Structure">
          <span className="label">Structure</span>
          {opts.map((o) => (
            <label key={o.v} title={o.aria}>
              <input type="radio" name={`struct-${id}`} value={o.v} checked={value === o.v} onChange={(e) => onChange(e.target.value)} />
              <span className="opt">
                {o.label === '●' ? <span className="dot" aria-hidden="true"></span> : <span style={{ fontSize: 12 }}>{o.label}</span>}
              </span>
            </label>
          ))}
        </div>
      );
    }

    function InlineActions({ actions, focus, onFocus, onExecute }) {
      return (
        <span className="actions-text" onClick={(e)=>e.stopPropagation()}>
          {actions.map((a, i) => (
            <React.Fragment key={a}>
              <span className={focus === a ? 'focus' : ''}
                    onMouseEnter={() => onFocus && onFocus(a)}
                    onClick={() => onExecute && onExecute(a)}>
                {a[0].toUpperCase() + a.slice(1)}
              </span>
              {i < actions.length - 1 ? <span className="sep">, </span> : null}
            </React.Fragment>
          ))}
        </span>
      );
    }

    function ModulePreview({ store, moduleId, depth }) {
      const mod = store.getDbItem(moduleId);
      if (!mod) return null;
      const items = store.get(`items-${mod.name}`, mod.items || []);
      const pad = ((depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          {items.length === 0 ? <div className="subtle">Empty module</div> :
            items.map((iid) => {
              const ins = store.getDbItem(iid); if (!ins) return null;
              return <div key={iid} className="prompt-preview">{displayNameFor(store, ins, iid)}</div>;
            })}
        </div>
      );
    }

    function InstructionPreview({ store, row }) {
      const dbItem = store.getDbItem(row.dbId);
      if (!dbItem) return null;
      const body = store.get(row.promptKey, dbItem.text || '');
      const pad = ((row.depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          <div className="prompt-preview">{body}</div>
        </div>
      );
    }

    function InstructionEdit({ store, row, onTextChange, getNameOverride, setNameOverride, getMeta, setMeta, getStruct, setStruct }) {
      const dbItem = store.getDbItem(row.dbId);
      if (!dbItem) return null;
      const pad = ((row.depth || 0) + 1) * TAB;
      const body = store.get(row.promptKey, dbItem.text || '');
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          <input
            autoFocus
            type="text"
            className="underline-input"
            value={getNameOverride(row.nameOverrideKey, '')}
            onChange={(e) => setNameOverride(row.nameOverrideKey, e.target.value)}
            placeholder="Name…"
          />
          <textarea
            className="underline-textarea"
            value={getMeta(row.metaKey) || ''}
            onChange={(e) => setMeta(row.metaKey, e.target.value)}
            placeholder="Meta information…"
          />
          <textarea
            className="underline-textarea"
            value={store.get(row.promptKey, '')}
            onChange={(e) => onTextChange(row.promptKey, e.target.value)}
            placeholder="Instruction…"
          />
          <StructureDots5
            id={row.dbId}
            value={getStruct(row.structKey) || 'heavy'}
            onChange={(v) => setStruct(row.structKey, v)}
          />
          <div className="prompt-preview" style={{ marginTop: 8 }}>{body}</div>
        </div>
      );
    }

    function LineRenderer({
      row, isSelected, inReorderMode, isDragging, isDropTarget,
      store, onLineClick,
      onDragStart, onDragOver, onDrop, onDragEnd,
      onTouchStartRow, onTouchMoveRow, onTouchEndRow,
      actionFocus, setActionFocus, executeRowAction, autoOpenSettings,
      getStruct, setStruct, setNameOverride, getNameOverride, getMeta, setMeta,
      onTextChange,
      editRowKey
    }) {
      const classes = ['line'];
      if (isSelected && !inReorderMode) classes.push('sel');
      if (inReorderMode) classes.push('reorder-mode');
      if (isDragging) classes.push('held');
      if (isDropTarget) classes.push('drop-target');

      const style = { paddingLeft: (row.depth || 0) * TAB };
      const canDragAnytime = (row.type === 'instr' || row.type === 'module-item');

      const actionsForRow = useMemo(() => {
        if (row.type === 'module-item' || row.type === 'instr') return ['move','settings','duplicate','delete'];
        return [];
      }, [row.type]);

      const focusedAction = (actionFocus && actionFocus.rowKey === row.key) ? actionFocus.action : null;
      const inActionMode = !!focusedAction;

      const actionInstruction = () => {
        if (!inActionMode) return null;
        const kind = row.type === 'module-item' ? 'module' : 'instruction';
        if (focusedAction === 'move') return `Move the arrow keys up and down to place the ${kind}.`;
        if (focusedAction === 'duplicate') return `Press Enter to duplicate this ${kind} at this position.`;
        if (focusedAction === 'delete') return `Press Enter to delete only this ${kind}.`;
        if (focusedAction === 'settings') return null;
        return null;
      };

      const showSettings = focusedAction === 'settings';

      return (
        <div key={row.key}>
          <div
            className={classes.join(' ')}
            style={style}
            data-key={row.key}
            onClick={() => onLineClick(row)}
            draggable={canDragAnytime}
            onDragStart={e => canDragAnytime ? onDragStart(e, row) : null}
            onDragOver={e => canDragAnytime ? onDragOver(e, row) : null}
            onDrop={e => canDragAnytime ? onDrop(e, row) : null}
            onDragEnd={onDragEnd}
            onTouchStart={(e) => canDragAnytime ? onTouchStartRow(e, row) : null}
            onTouchMove={(e) => canDragAnytime ? onTouchMoveRow(e, row) : null}
            onTouchEnd={(e) => canDragAnytime ? onTouchEndRow(e, row) : null}
          >
            <span className="left-span">
              {row.isOutput ? <strong>OUTPUT:&nbsp;</strong> : null}{row.label}
            </span>

            {(row.type === 'module-item' || row.type === 'instr') && isSelected && (
              <InlineActions
                actions={actionsForRow}
                focus={focusedAction || 'move'}
                onFocus={(a) => {
                  setActionFocus({ rowKey: row.key, action: a });
                  if (a === 'settings') autoOpenSettings(row);
                }}
                onExecute={(a) => executeRowAction(row, a)}
              />
            )}
          </div>

          {isSelected && (
            <>
              {showSettings && (
                <div className="indent-block" style={{ paddingLeft: ((row.depth || 0) + 1) * TAB }}>
                  {row.type === 'module-item' ? (
                    <>
                      <input
                        autoFocus
                        type="text"
                        className="underline-input"
                        value={getNameOverride(row.nameOverrideKey, '')}
                        onChange={(e) => setNameOverride(row.nameOverrideKey, e.target.value)}
                        placeholder="Name…"
                      />
                      <textarea
                        className="underline-textarea"
                        value={getMeta(row.metaKey) || ''}
                        onChange={(e) => setMeta(row.metaKey, e.target.value)}
                        placeholder="Meta information…"
                      />
                      <textarea
                        className="underline-textarea"
                        value={store.get(`prompt-mod-${row.moduleId}`, '')}
                        onChange={(e) => onTextChange(`prompt-mod-${row.moduleId}`, e.target.value)}
                        placeholder="Module instruction…"
                      />
                      <StructureDots5
                        id={row.moduleId}
                        value={getStruct(row.structKey) || 'heavy'}
                        onChange={(v) => setStruct(row.structKey, v)}
                      />
                    </>
                  ) : (
                    <InstructionEdit
                      store={store}
                      row={row}
                      onTextChange={onTextChange}
                      getNameOverride={getNameOverride}
                      setNameOverride={setNameOverride}
                      getMeta={getMeta}
                      setMeta={setMeta}
                      getStruct={getStruct}
                      setStruct={setStruct}
                    />
                  )}
                </div>
              )}

              {!showSettings && actionInstruction() && (
                <div className="indent-block" style={{ paddingLeft: ((row.depth || 0) + 1) * TAB }}>
                  <div className="instructional">{actionInstruction()}</div>
                </div>
              )}

              {!inActionMode && !showSettings && row.type === 'module-item' && (
                <ModulePreview store={store} moduleId={row.moduleId} depth={row.depth} />
              )}
              {!inActionMode && !showSettings && row.type === 'instr' && (!editRowKey || editRowKey !== row.key) && (
                <InstructionPreview store={store} row={row} />
              )}
              {!inActionMode && row.type === 'instr' && editRowKey === row.key && (
                <InstructionEdit
                  store={store}
                  row={row}
                  onTextChange={onTextChange}
                  getNameOverride={getNameOverride}
                  setNameOverride={setNameOverride}
                  getMeta={getMeta}
                  setMeta={setMeta}
                  getStruct={getStruct}
                  setStruct={setStruct}
                />
              )}
            </>
          )}
        </div>
      );
    }

    function App() {
      const storeRef = useRef(new DataStore());
      const store = storeRef.current;

      const [storeVersion, setStoreVersion] = useState(store.getVersion());
      const [path, setPath] = useState(() => {
        const hash = window.location.hash.slice(1);
        if (hash) { const parts = hash.split('/').filter(Boolean); if (parts.length > 0) return parts; }
        return ['expert-maker'];
      });

      const [idx, setIdx] = useState(0);
      const [navHistory, setNavHistory] = useState({});
      const [reorderState, setReorderState] = useState(null);
      const [dragItem, setDragItem] = useState(null);
      const [dragOver, setDragOver] = useState(null);

      const rowsDomRef = useRef(new Map());
      const [touchDrag, setTouchDrag] = useState(null);

      const [settingsOpen, setSettingsOpen] = useState({});
      const [actionFocus, setActionFocus] = useState(null);
      const [editRowKey, setEditRowKey] = useState(null);

      // Omnisearch
      const [omniActive, setOmniActive] = useState(false);
      const [omniMode, setOmniMode] = useState('search');
      const [omniQuery, setOmniQuery] = useState('');
      const [omniIndex, setOmniIndex] = useState(0);
      const [omniFilterType, setOmniFilterType] = useState(null);
      const [omniIntent, setOmniIntent] = useState(null);
      const [omniInsertPos, setOmniInsertPos] = useState(null);
      const omniInputRef = useRef(null); // single declaration

      const rows = useMemo(() => {
        const builder = new RowBuilder(store, path);
        return builder.build();
      }, [store, path, storeVersion]);

      const rowsRef = useRef(rows);
      useEffect(() => { rowsRef.current = rows; }, [rows]);

      const atAgent = path.length === 1;
      const atModule = path.length >= 2;
      const agent = store.getDbItem(path[0]) || store.getDbItem('expert-maker');
      const module = atModule ? store.getDbItem(path[path.length - 1]) : null;

      const updateData = useCallback((key, value) => { store.set(key, value); setStoreVersion(store.getVersion()); }, [store]);

      const computeInsertPos = useCallback(() => {
        const a = store.getDbItem(path[0]); if (!a) return 0;
        const mods = store.get(`mods-${a.name}`, a.modules || []);
        const sel = rows[idx];
        if (sel && sel.type === 'module-item') return sel.pos;
        if (path.length >= 2) {
          const pos = mods.findIndex(m => m === path[1]);
          if (pos >= 0) return pos;
        }
        return mods.length;
      }, [rows, idx, path, store]);

      const openOmniAddModule = useCallback(() => {
        setOmniInsertPos(computeInsertPos());
        setOmniActive(true); setOmniMode('search'); setOmniQuery(''); setOmniIndex(0);
        setOmniFilterType('mod'); setOmniIntent('add-module');
      }, [computeInsertPos]);

      const resetAll = useCallback(() => {
        if (confirm('Reset everything to defaults? This will clear all your customizations.')) {
          store.reset();
          setPath(['expert-maker']); setIdx(2); setNavHistory({}); setReorderState(null);
          setSettingsOpen({}); setActionFocus(null); setEditRowKey(null);
          setOmniActive(false); setOmniQuery(''); setOmniIndex(0); setOmniMode('search'); setOmniFilterType(null); setOmniIntent(null); setOmniInsertPos(null);
          window.location.hash = ''; setStoreVersion(store.getVersion());
        }
      }, [store]);

      const navigateToPath = useCallback((newPath, autoSelect = true) => {
        setPath(newPath); setReorderState(null);
        setSettingsOpen({}); setActionFocus(null); setEditRowKey(null);
        setIdx(autoSelect ? (newPath.length === 1 ? 2 : 3) : 0);
      }, []);

      const attachModuleToAgent = useCallback((mid, insertPos = null) => {
        const a = store.getDbItem(path[0]); if (!a) return;
        const key = `mods-${a.name}`;
        const arr = store.get(key, a.modules || []);
        const pos = (insertPos !== null && insertPos >= 0 && insertPos <= arr.length) ? insertPos : arr.length;
        const newArr = [...arr]; newArr.splice(pos, 0, mid);
        updateData(key, newArr);
      }, [store, updateData, path]);

      const openAndFocusSettings = useCallback((ownerType, ownerId) => {
        const panelKey = ownerType === 'module' ? `spanel:mod:${ownerId}` : `spanel:instr:${ownerId}`;
        setSettingsOpen(prev => ({ ...prev, [panelKey]: true }));
        setTimeout(() => {
          const i = rowsRef.current.findIndex(r =>
            (r.type === (ownerType === 'module' ? 'module-item' : 'instr')) &&
            ((ownerType === 'module' ? r.moduleId : r.dbId) === ownerId)
          );
          if (i >= 0) setIdx(i);
        }, 0);
      }, []);

      const createNewAgent = useCallback((name) => {
        const id = 'agent-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'agent', input: '', output: '', modules: [] });
        navigateToPath([id], true);
      }, [store, navigateToPath]);

      const createNewModule = useCallback((name, insertPos = null) => {
        const id = 'mod-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'mod', items: [] });
        attachModuleToAgent(id, insertPos);
        navigateToPath([path[0], id], true);
        openAndFocusSettings('module', id);
      }, [store, attachModuleToAgent, navigateToPath, path, openAndFocusSettings]);

      const createNewInstruction = useCallback((name) => {
        const id = 'custom-' + Date.now();
        store.addCustomDbItem(id, { name, type: 'instr', text: '' });
        if (atModule && module) {
          const arr = store.get(`items-${module.name}`, module.items || []);
          updateData(`items-${module.name}`, [...arr, id]);
          openAndFocusSettings('instr', id);
        } else {
          const a = store.getDbItem(path[0]); if (!a) return;
          const mods = store.get(`mods-${a.name}`, a.modules || []);
          if (mods.length) {
            navigateToPath([path[0], mods[0]], true);
            setTimeout(() => {
              const m = store.getDbItem(mods[0]);
              const arr = store.get(`items-${m.name}`, m.items || []);
              updateData(`items-${m.name}`, [...arr, id]);
              openAndFocusSettings('instr', id);
            }, 0);
          }
        }
      }, [store, atModule, module, updateData, path, openAndFocusSettings]);

      const removeInstructionAtPos = useCallback((pos) => {
        if (!atModule || !module) return;
        const arr = store.get(`items-${module.name}`, module.items || []);
        updateData(`items-${module.name}`, arr.filter((_, i) => i !== pos));
      }, [atModule, module, store, updateData]);

      const removeModuleAtPos = useCallback((pos) => {
        const a = store.getDbItem(path[0]); if (!a) return;
        const arr = store.get(`mods-${a.name}`, a.modules || []);
        updateData(`mods-${a.name}`, arr.filter((_, i) => i !== pos));
      }, [store, updateData, path]);

      const duplicateItem = useCallback((dbId, isModule, insertAtPos = null) => {
        const item = store.getDbItem(dbId); if (!item) return;
        if (isModule) {
          const a = store.getDbItem(path[0]); if (!a) return;
          const arr = store.get(`mods-${a.name}`, a.modules || []);
          const newArr = [...arr];
          const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
          newArr.splice(at, 0, dbId); updateData(`mods-${a.name}`, newArr);
        } else {
          if (!module) return;
          const arr = store.get(`items-${module.name}`, module.items || []);
          const newId = 'custom-' + Date.now();
          const baseName = displayNameFor(store, item, dbId);
          const baseText = store.get(`t-${item.name}`, item.text || '');
          store.addCustomDbItem(newId, { name: baseName + ' (copy)', type: 'instr', text: baseText });
          const newArr = [...arr];
          const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
          newArr.splice(at, 0, newId); updateData(`items-${module.name}`, newArr);
          updateData(`nn-${newId}`, baseName + ' (copy)'); updateData(`t-${newId}`, baseText); setStoreVersion(store.getVersion());
        }
      }, [store, updateData, path, module]);

      const setRowRef = useCallback((key, el) => {
        if (!rowsDomRef.current) rowsDomRef.current = new Map();
        if (el) rowsDomRef.current.set(key, el); else rowsDomRef.current.delete(key);
      }, []);

      const autoOpenSettings = useCallback((row) => {
        if (row.type === 'module-item') {
          setSettingsOpen(s => ({ ...s, [`spanel:mod:${row.moduleId}`]: true }));
        } else if (row.type === 'instr') {
          setSettingsOpen(s => ({ ...s, [`spanel:instr:${row.dbId}`]: true }));
        }
      }, []);

      const firstActionForRow = (row) => 'move';
      const nextActionForRow = (row, current, dir) => {
        const list = (row.type === 'module-item' || row.type === 'instr') ? ['move','settings','duplicate','delete'] : [];
        const i = Math.max(0, list.indexOf(current));
        let ni = i + dir;
        if (ni < 0) ni = 0;
        if (ni >= list.length) ni = list.length - 1;
        return list[ni];
      };

      const moveItemInReorderMode = useCallback((direction) => {
        if (!reorderState) return;
        const delta = direction === 'up' ? -1 : 1;
        const newCurrentPos = reorderState.currentPos + delta;

        let arr = [];
        if (reorderState.type === 'instr' && atModule && module) arr = store.get(`items-${module.name}`, module.items || []);
        else if (reorderState.type === 'module-item') {
          const a = store.getDbItem(path[0]); if (a) arr = store.get(`mods-${a.name}`, a.modules || []);
        }

        if (newCurrentPos >= 0 && newCurrentPos < arr.length) {
          setReorderState(prev => ({ ...prev, currentPos: newCurrentPos }));
          if (reorderState.type === 'instr' && atModule && module) {
            updateData(`items-${module.name}`, moveInList(arr, reorderState.originalPos, newCurrentPos));
          } else if (reorderState.type === 'module-item') {
            const a = store.getDbItem(path[0]); if (a) {
              updateData(`mods-${a.name}`, moveInList(arr, reorderState.originalPos, newCurrentPos));
            }
          }
        }
      }, [reorderState, atModule, module, store, updateData, path]);

      const commitReorder = useCallback(() => {
        if (!reorderState) return;
        const theCurrentPos = (reorderState.currentPos !== undefined) ? reorderState.currentPos : reorderState.originalPos;
        const ownerId = reorderState.dbId || reorderState.moduleId;
        const targetIdx = rowsRef.current.findIndex(r =>
          (reorderState.type === 'instr' ? r.type === 'instr' : r.type === 'module-item') &&
          (reorderState.type === 'instr' ? r.dbId === ownerId : r.moduleId === ownerId) &&
          r.pos === theCurrentPos
        );
        setReorderState(null);
        if (targetIdx >= 0) setIdx(targetIdx);
      }, [reorderState]);

      const startMove = useCallback((row) => {
        const i = rowsRef.current.findIndex(r => r.key === row.key);
        setIdx(i >= 0 ? i : 0);
        setReorderState({
          rowKey: row.key,
          dbId: row.dbId || row.moduleId,
          type: row.type,
          originalIdx: i,
          originalPos: row.pos,
          currentPos: row.pos
        });
      }, []);

      const commitIfMoving = useCallback(() => { if (reorderState) commitReorder(); }, [reorderState, commitReorder]);

      // DnD desktop
      const handleDragStart = useCallback((e, row) => { e.dataTransfer.effectAllowed = 'move'; setDragItem(row); }, []);
      const handleDragOver = useCallback((e, row) => { e.preventDefault(); if (!dragItem) return; e.dataTransfer.dropEffect = 'move'; setDragOver(row.key); }, [dragItem]);
      const handleDrop = useCallback((e, row) => {
        e.preventDefault(); if (!dragItem) return;

        if (dragItem.type === 'instr' && row.type === 'instr' && atModule && module) {
          const arr = store.get(`items-${module.name}`, module.items || []); updateData(`items-${module.name}`, moveInList(arr, dragItem.pos, row.pos));
        } else if (dragItem.type === 'module-item' && row.type === 'module-item') {
          const a = store.getDbItem(path[0]); if (a) {
            const arr = store.get(`mods-${a.name}`, a.modules || []); updateData(`mods-${a.name}`, moveInList(arr, dragItem.pos, row.pos));
          }
        }

        setDragItem(null); setDragOver(null);
      }, [dragItem, atModule, module, store, updateData, path]);
      const handleDragEnd = useCallback(() => { setDragItem(null); setDragOver(null); }, []);

      // Touch DnD
      const onTouchStartRow = useCallback((e, row) => {
        if (!(row.type === 'instr' || row.type === 'module-item')) return;
        const t = e.touches[0];
        setTouchDrag({ row, startY: t.clientY });
        setDragItem(row);
      }, []);
      const onTouchMoveRow = useCallback((e) => {
        if (!touchDrag) return;
        const t = e.touches[0];
        const el = document.elementFromPoint(t.clientX, t.clientY);
        if (!el) return;
        const targetLine = el.closest && el.closest('.line');
        if (!targetLine) return;
        const key = targetLine.getAttribute('data-key');
        setDragOver(key);
      }, [touchDrag]);
      const onTouchEndRow = useCallback(() => {
        if (!touchDrag) return;
        const row = touchDrag.row;
        const overKey = dragOver;
        if (overKey) {
          const targetRow = rowsRef.current.find(r => r.key === overKey);
          if (targetRow) {
            if (row.type === 'instr' && targetRow.type === 'instr' && atModule && module) {
              const arr = store.get(`items-${module.name}`, module.items || []);
              updateData(`items-${module.name}`, moveInList(arr, row.pos, targetRow.pos));
            } else if (row.type === 'module-item' && targetRow.type === 'module-item') {
              const a = store.getDbItem(path[0]); if (a) {
                const arr = store.get(`mods-${a.name}`, a.modules || []);
                updateData(`mods-${a.name}`, moveInList(arr, row.pos, targetRow.pos));
              }
            }
          }
        }
        setTouchDrag(null); setDragItem(null); setDragOver(null);
      }, [touchDrag, dragOver, atModule, module, store, updateData, path]);

      const executeRowAction = useCallback((row, action) => {
        if (!row) return;
        if (row.type === 'module-item') {
          if (action === 'move') { startMove(row); setActionFocus({ rowKey: row.key, action: 'move' }); return; }
          if (action === 'settings') { autoOpenSettings(row); setActionFocus({ rowKey: row.key, action: 'settings' }); return; }
          if (action === 'duplicate') { duplicateItem(row.moduleId, true); return; }
          if (action === 'delete') { removeModuleAtPos(row.pos); return; }
        }
        if (row.type === 'instr') {
          if (action === 'move') { startMove(row); setActionFocus({ rowKey: row.key, action: 'move' }); return; }
          if (action === 'settings') { autoOpenSettings(row); setActionFocus({ rowKey: row.key, action: 'settings' }); return; }
          if (action === 'duplicate') { duplicateItem(row.dbId, false); return; }
          if (action === 'delete') { removeInstructionAtPos(row.pos); return; }
        }
      }, [duplicateItem, removeInstructionAtPos, removeModuleAtPos, startMove, autoOpenSettings]);

      // Key handling
      const handleKeyDown = useCallback((e) => {
        // Omnisearch open with '/'
        if (e.key === '/' && !omniActive) {
          const activeEl = document.activeElement;
          const inField = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA');
          if (!inField) { e.preventDefault(); openOmniAddModule(); return; }
        }
        if (omniActive) return;

        const sel = rows[idx]; if (!sel) return;

        const activeEl = document.activeElement;
        const inField = activeEl && (activeEl.tagName === 'TEXTAREA' || (activeEl.tagName === 'INPUT' && activeEl.type === 'text'));
        if (inField) {
          const valueLength = activeEl.value.length;
          const start = activeEl.selectionStart ?? 0;
          const end = activeEl.selectionEnd ?? 0;
          if ((e.key === 'ArrowLeft' || e.key === 'ArrowUp') && start === 0 && end === 0) { e.preventDefault(); activeEl.blur(); setIdx(prev => Math.max(0, prev - 1)); return; }
          if ((e.key === 'ArrowRight' || e.key === 'ArrowDown') && start === valueLength && end === valueLength) { e.preventDefault(); activeEl.blur(); setIdx(prev => Math.min(rows.length - 1, prev + 1)); return; }
          return;
        }

        // In action mode
        if (actionFocus && actionFocus.rowKey === sel.key) {
          if (e.key === 'ArrowUp')   { e.preventDefault(); if (actionFocus.action === 'move') moveItemInReorderMode('up'); return; }
          if (e.key === 'ArrowDown') { e.preventDefault(); if (actionFocus.action === 'move') moveItemInReorderMode('down'); return; }
          if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
            e.preventDefault();
            const dir = e.key === 'ArrowRight' ? +1 : -1;
            const next = nextActionForRow(sel, actionFocus.action, dir);
            setActionFocus({ rowKey: sel.key, action: next });
            if (next === 'settings') autoOpenSettings(sel);
            return;
          }
          if (e.key === 'Enter') {
            e.preventDefault();
            executeRowAction(sel, actionFocus.action);
            if (actionFocus.action === 'move') { commitIfMoving(); setActionFocus(null); }
            return;
          }
          if (e.key === 'Escape') { e.preventDefault(); if (actionFocus.action === 'move') commitIfMoving(); setActionFocus(null); return; }
        }

        const gotoIndex = (nextIdx) => { setActionFocus(null); setEditRowKey(null); setIdx(nextIdx); };

        if (e.key === 'ArrowUp') {
          e.preventDefault(); gotoIndex(Math.max(0, idx - 1));
        } else if (e.key === 'ArrowDown') {
          e.preventDefault(); gotoIndex(Math.min(rows.length - 1, idx + 1));
        } else if (e.key === 'ArrowLeft') {
          e.preventDefault();
          setActionFocus({ rowKey: sel.key, action: 'move' });
          setEditRowKey(null);
          return;
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          if (sel.type === 'module-item') {
            const newPath = [...path, sel.moduleId];
            setPath(newPath);
            setIdx(3);
            return;
          }
          if (sel.type === 'instr') {
            setEditRowKey(sel.key);
            return;
          }
          if (sel.type === 'adder-mod') { openOmniAddModule(); return; }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (sel.type === 'adder-mod') { openOmniAddModule(); return; }
        } else if (e.key === 'Escape') {
          e.preventDefault();
          if (actionFocus) { if (reorderState) commitIfMoving(); setActionFocus(null); return; }
          if (editRowKey) { setEditRowKey(null); return; }
          if (path.length > 1) {
            const newPath = path.slice(0, - 1);
            const pathKey = newPath.join('/'); const savedIdx = navHistory[pathKey];
            setPath(newPath);
            setIdx(savedIdx !== undefined ? savedIdx : (newPath.length === 1 ? 2 : 3));
            return;
          }
        }
      }, [
        rows, idx, path, navHistory,
        omniActive, openOmniAddModule,
        actionFocus, setActionFocus, nextActionForRow,
        startMove, moveItemInReorderMode, commitIfMoving, executeRowAction,
        reorderState, autoOpenSettings,
        editRowKey
      ]);

      useEffect(() => { window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [handleKeyDown]);

      const handleLineClick = useCallback((row) => {
        const rowIdx = rows.findIndex(r => r.key === row.key);
        if (rowIdx !== -1) setIdx(rowIdx);
        if (row.type === 'root') { navigateToPath([path[0]], true); return; }
        if (row.type === 'adder-mod') { openOmniAddModule(); return; }
      }, [rows, path, navigateToPath, openOmniAddModule]);

      useEffect(() => {
        const hash = '#' + path.join('/'); if (window.location.hash !== hash) window.history.pushState(null, '', hash);
        if (!window.location.hash) setIdx(path.length === 1 ? 2 : 3);
      }, [path]);

      useEffect(() => {
        const handlePopState = () => {
          const hash = window.location.hash.slice(1);
          if (hash) {
            const parts = hash.split('/').filter(Boolean);
            if (parts.length > 0) navigateToPath(parts, true);
          } else navigateToPath(['expert-maker'], true);
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, [navigateToPath]);

      // Omnisearch data
      const db = store.getAllDb();
      const agentModules = useMemo(() => agent ? (store.get(`mods-${agent.name}`, agent.modules || [])) : [], [store, agent]);

      const moduleFrequency = useMemo(() => {
        const freq = {};
        Object.keys(db).forEach(id => {
          const it = db[id];
          if (it.type === 'agent') {
            const mods = store.get(`mods-${it.name}`, it.modules || []);
            mods.forEach(mid => { freq[mid] = (freq[mid] || 0) + 1; });
          }
        });
        return freq;
      }, [db, store]);

      const topModules = useMemo(() => {
        const mods = Object.keys(db).filter(id => db[id].type === 'mod');
        return mods.sort((a, b) => {
          const fa = moduleFrequency[a] || 0;
          const fb = moduleFrequency[b] || 0;
          if (fb !== fa) return fb - fa;
          const na = (db[a].name || '').toLowerCase();
          const nb = (db[b].name || '').toLowerCase();
          return na.localeCompare(nb);
        });
      }, [db, moduleFrequency]);

      const scopeResults = useMemo(() => {
        if (!agent) return [];
        const q = (omniQuery || '').toLowerCase().trim();
        const out = [];
        const pushIf = (cond, row) => { if (cond) out.push(row); };

        pushIf(!omniFilterType || omniFilterType === 'agent',
          (!q || agent.name.toLowerCase().includes(q)) && { type: 'agent', id: path[0], name: store.get(`n-${agent.name}`, agent.name), scope: 'current' });

        for (const mid of agentModules) {
          const m = db[mid]; if (!m) continue;
          const mname = store.get(`n-${m.name}`, m.name);
          pushIf(!omniFilterType || omniFilterType === 'mod',
            (!q || mname.toLowerCase().includes(q)) && { type: 'mod', id: mid, name: mname, scope: 'current' });

          const items = store.get(`items-${m.name}`, m.items || []);
          for (const iid of items) {
            const ins = db[iid]; if (!ins) continue;
            const iname = store.get(`nn-${iid}`, displayNameFor(store, ins, iid));
            if (!omniFilterType || omniFilterType === 'instr') {
              if (!q) { out.push({ type: 'instr', id: iid, name: iname, scope: 'current' }); }
              else {
                const text = store.get(`t-${ins.name}`, ins.text || '');
                const meta = store.get(`meta-${iid}`, '');
                const hay = (iname + ' ' + text + ' ' + meta).toLowerCase();
                if (hay.includes(q)) out.push({ type: 'instr', id: iid, name: iname, scope: 'current' });
              }
            }
          }
        }
        return out.filter(Boolean);
      }, [agent, agentModules, store, db, omniQuery, path, omniFilterType]);

      const libraryResults = useMemo(() => {
        const q = (omniQuery || '').toLowerCase().trim();
        const out = [];
        Object.keys(db).forEach(id => {
          const it = db[id];
          if (omniFilterType && it.type !== omniFilterType) return;
          const name = it.name || '';
          const text = it.text || '';
          const hay = (name + ' ' + text).toLowerCase();
          if (q && !hay.includes(q)) return;
          const dup = scopeResults.find(s => s.type === it.type && s.id === id);
          if (!dup) out.push({ type: it.type, id, name, scope: 'library' });
        });
        out.sort((a,b)=>a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
        return out;
      }, [db, omniQuery, scopeResults, omniFilterType]);

      const suggestedModuleRows = useMemo(() => {
        if (!(omniIntent === 'add-module' && omniFilterType === 'mod' && (omniQuery || '').trim() === '')) return [];
        const rows = [];
        topModules.forEach(mid => { const m = db[mid]; if (!m) return; rows.push({ type: 'mod', id: mid, name: m.name, scope: 'library', suggested: true }); });
        return rows;
      }, [omniIntent, omniFilterType, omniQuery, topModules, db]);

      const createRows = useMemo(() => {
        const q = (omniQuery || '').trim();
        if (!q) return [];
        const rows = [];
        if (!omniFilterType || omniFilterType === 'agent') rows.push({ type: 'create-agent', id: 'new-agent', name: `Create Agent "${q}"` });
        if (!omniFilterType || omniFilterType === 'mod') rows.push({ type: 'create-mod', id: 'new-mod', name: `Create Module "${q}"` });
        if (!omniFilterType || omniFilterType === 'instr') rows.push({ type: 'create-instr', id: 'new-instr', name: `Create Instruction "${q}"` });
        return rows;
      }, [omniQuery, omniFilterType]);

      const browseRows = useMemo(() => {
        const rows = [];
        rows.push({ type: 'label', id: 'label-in', name: 'In this project' });
        for (const mid of agentModules) {
          const m = db[mid]; if (!m) continue;
          const mname = store.get(`n-${m.name}`, m.name);
          rows.push({ type: 'mod', id: mid, name: mname, scope: 'current' });
          const items = store.get(`items-${m.name}`, m.items || []);
          for (const iid of items) {
            const ins = db[iid]; if (!ins) continue;
            const iname = store.get(`nn-${iid}`, displayNameFor(store, ins, iid));
            rows.push({ type: 'instr', id: iid, name: '• ' + iname, scope: 'current' });
          }
        }
        rows.push({ type: 'label', id: 'label-lib', name: 'From library' });
        Object.keys(db).forEach(id => {
          const it = db[id];
          if (it.type === 'mod' && !agentModules.includes(id)) rows.push({ type: 'mod', id, name: it.name, scope: 'library' });
          if (it.type === 'instr') rows.push({ type: 'instr', id, name: it.name, scope: 'library' });
        });
        rows.push({ type: 'label', id: 'label-create', name: 'Quick create' });
        rows.push({ type: 'create-mod', id: 'quick-mod', name: 'Create Module…' });
        rows.push({ type: 'create-instr', id: 'quick-instr', name: 'Create Instruction…' });
        rows.push({ type: 'create-agent', id: 'quick-agent', name: 'Create Agent…' });
        return rows;
      }, [agentModules, db, store]);

      const visibleRows = useMemo(() => {
        if (!omniActive) return [];
        if (omniMode === 'search') {
          if (omniIntent === 'add-module' && omniFilterType === 'mod' && (omniQuery || '').trim() === '') {
            const seen = new Set();
            const list = [];
            suggestedModuleRows.forEach(r => { const k = r.type+':'+r.id; if (!seen.has(k)) { seen.add(k); list.push(r); } });
            scopeResults.forEach(r => { if (r.type !== 'mod') return; const k = r.type+':'+r.id; if (!seen.has(k)) { seen.add(k); list.push(r); } });
            libraryResults.forEach(r => { if (r.type !== 'mod') return; const k = r.type+':'+r.id; if (!seen.has(k)) { seen.add(k); list.push(r); } });
            createRows.forEach(r => list.push(r));
            return list;
          }
          return [...scopeResults, ...libraryResults, ...createRows];
        } else {
          return browseRows;
        }
      }, [omniActive, omniMode, scopeResults, libraryResults, createRows, browseRows, omniIntent, omniFilterType, omniQuery, suggestedModuleRows]);

      useEffect(() => {
        if (!omniActive) return;
        const t = setTimeout(() => { if (omniInputRef.current) omniInputRef.current.focus(); }, 0);
        return () => clearTimeout(t);
      }, [omniActive]);

      useEffect(() => { setOmniIndex(0); }, [omniMode, omniQuery, omniFilterType, omniIntent]);

      const actOnRow = (row) => {
        if (!row) return;
        if (row.type === 'agent') { navigateToPath([row.id], true); setOmniActive(false); setOmniInsertPos(null); return; }
        if (row.type === 'mod')   {
          attachModuleToAgent(row.id, omniInsertPos);
          navigateToPath([path[0], row.id], true);
          setOmniActive(false); setOmniInsertPos(null);
          return;
        }
        if (row.type === 'instr') {
          if (atModule && module) {
            const arr = store.get(`items-${module.name}`, module.items || []); updateData(`items-${module.name}`, [...arr, row.id]);
          } else {
            const a = store.getDbItem(path[0]); if (!a) return;
            const mods = store.get(`mods-${a.name}`, a.modules || []);
            if (mods.length) {
              navigateToPath([path[0], mods[0]], true);
              setTimeout(() => {
                const m = store.getDbItem(mods[0]);
                const arr = store.get(`items-${m.name}`, m.items || []);
                updateData(`items-${m.name}`, [...arr, row.id]);
              }, 0);
            }
          }
          setOmniActive(false); setOmniInsertPos(null);
          return;
        }
        if (row.type === 'create-agent') { createNewAgent(omniQuery.trim()); setOmniActive(false); setOmniInsertPos(null); return; }
        if (row.type === 'create-mod')   { createNewModule(omniQuery.trim(), omniInsertPos); setOmniActive(false); setOmniInsertPos(null); return; }
        if (row.type === 'create-instr') { createNewInstruction(omniQuery.trim()); setOmniActive(false); setOmniInsertPos(null); return; }
      };

      const onOmniKeyDown = (e) => {
        if (!omniActive) return;
        const has = visibleRows.length > 0;
        if (e.key === 'Tab') {
          e.preventDefault();
          setOmniMode(prev => prev === 'search' ? 'browse' : 'search');
        } else if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (has) setOmniIndex(prev => Math.min(visibleRows.length - 1, prev + 1));
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (has) setOmniIndex(prev => Math.max(0, prev - 1));
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (!has) return;
          actOnRow(visibleRows[Math.max(0, Math.min(omniIndex, visibleRows.length - 1))]);
        } else if (e.key === 'Escape') {
          e.preventDefault();
          setOmniActive(false); setOmniInsertPos(null);
        }
      };

      const promptText = useMemo(() => {
        let text = '(: Smile Composer\n    ' + store.get(`n-${agent.name}`, agent.name);
        if (atModule) {
          text += path.slice(1).map(mid => {
            const m = store.getDbItem(mid);
            const name = m ? displayNameFor(store, m, mid) : '';
            return m ? '\n        ' + name : '';
          }).join('');
        }
        return text;
      }, [path, agent, atModule, store, storeVersion]);

      const allTextContent = useMemo(() => {
        let parts = [];
        if (atModule && module) {
          const ids = store.get(`items-${module.name}`, module.items || []);
          ids.forEach(id => {
            const it = store.getDbItem(id); if (!it) return;
            const name = store.get(`nn-${id}`, displayNameFor(store, it, id));
            const text = store.get(`t-${it.name}`, it.text || '');
            const meta = store.get(`meta-${id}`, '');
            parts.push(`${name}\n${text}${meta ? `\n(meta) ${meta}` : ''}`);
          });
        } else if (agent) {
          const mods = store.get(`mods-${agent.name}`, agent.modules || []);
          mods.forEach(mid => {
            const m = store.getDbItem(mid); if (!m) return;
            const mname = displayNameFor(store, m, mid);
            parts.push(`== ${mname} ==`);
            const ids = store.get(`items-${m.name}`, m.items || []);
            ids.forEach(id => {
              const it = store.getDbItem(id); if (!it) return;
              const name = store.get(`nn-${id}`, displayNameFor(store, it, id));
              const text = store.get(`t-${it.name}`, it.text || '');
              const meta = store.get(`meta-${id}`, '');
              parts.push(`${name}\n${text}${meta ? `\n(meta) ${meta}` : ''}`);
            });
          });
        }
        return parts.join('\n\n');
      }, [storeVersion, path, atModule, module, agent, store]);

      const outputKey = atModule && module ? `output-${module.name}` : `output-${agent.name}`;
      const outputDefault = atModule ? '' : agent.output;

      const omniInsertHint = useMemo(() => {
        const pos = computeInsertPos();
        return Number.isFinite(pos) ? pos : null;
      }, [computeInsertPos, rows, idx]);

      return (
        <div className="container">
          {/* Omnisearch header */}
          <div className="omni">
            <div className="omni-bar">
              <input
                className="omni-input"
                placeholder="Omnisearch — press / to open, Tab switches modes"
                value={omniActive ? omniQuery : ''}
                readOnly={!omniActive}
                onFocus={() => omniActive ? null : openOmniAddModule()}
                onChange={e => setOmniQuery(e.target.value)}
              />
              <div className={`omni-mode ${omniActive ? 'show' : ''}`}>
                <button className={omniMode === 'search' ? 'active' : ''} onClick={() => setOmniMode('search')}>Search</button>
                <button className={omniMode === 'browse' ? 'active' : ''} onClick={() => setOmniMode('browse')}>Browse</button>
              </div>
              <button
                className="omni-input"
                title="Add Module"
                onClick={openOmniAddModule}
                style={{ cursor: 'pointer', border: 'none', background: 'transparent', textAlign: 'right' }}
              >
                Add Module{omniInsertHint !== null ? ` @ ${omniInsertHint}` : ''}
              </button>
            </div>
            {omniActive && (
              <div className="omni-drawer">
                <div className="subtle" style={{ margin: '4px 6px 8px 6px' }}>
                  {omniMode === 'search'
                    ? (omniIntent === 'add-module' && omniFilterType === 'mod' && (omniQuery || '').trim()===''
                        ? 'Suggested modules (most used) • Enter to add • Tab to switch modes'
                        : 'Search names, text, meta in this project and library • Enter to open/add • Tab to switch modes')
                    : 'Browse current project and library • Enter to open or attach'}
                </div>
                <div className="omni-list">
                  {visibleRows.length === 0 && (<div className="omni-item"><span>No matches</span></div>)}
                  {visibleRows.map((r, i) => (
                    r.type === 'label' ? (
                      <div key={r.id} className="subtle" style={{ padding: '6px 2px 2px 2px' }}>{r.name}</div>
                    ) : (
                      <div
                        key={r.type + ':' + r.id + ':' + i}
                        className={`omni-item${i === omniIndex ? ' sel' : ''}`}
                        onMouseEnter={() => setOmniIndex(i)}
                        onClick={() => actOnRow(r)}
                      >
                        <span>{r.name}</span>
                        <span className="badge">{r.type}{r.scope ? ` • ${r.scope}` : ''}{r.suggested ? ' • suggested' : ''}</span>
                      </div>
                    )
                  ))}
                </div>
                <input
                  ref={omniInputRef}
                  className="omni-input"
                  style={{ width: '1px', height: '1px', opacity: 0, pointerEvents: 'none', position: 'absolute' }}
                  value={omniQuery}
                  onChange={()=>{}}
                  onKeyDown={onOmniKeyDown}
                />
              </div>
            )}
          </div>

          {/* Main Composer */}
          <div className="panel">
            <div className="panel-title">
              <span className="clickable" onClick={() => navigateToPath([path[0]], true)}>Smile Composer</span>
              <div className="panel-title-right">
                <span className="subtle">Left=Actions • Right=Enter (module/edit) • Up/Down=select • In Move: Up/Down=reorder • Esc=exit/back • Drag=Reorder • /=Omnisearch</span>
              </div>
            </div>
            {rows.map((row, i) => {
              const isSelected = i === idx;
              const inReorderMode = reorderState && row.key === reorderState.rowKey;
              const isDragging = dragItem && dragItem.key === row.key;
              const isDropTarget = dragOver === row.key;

              return (
                <LineRenderer
                  key={row.key}
                  row={row}
                  isSelected={isSelected}
                  inReorderMode={!!inReorderMode}
                  isDragging={!!isDragging}
                  isDropTarget={!!isDropTarget}
                  store={store}
                  onLineClick={handleLineClick}
                  onDragStart={handleDragStart}
                  onDragOver={handleDragOver}
                  onDrop={handleDrop}
                  onDragEnd={handleDragEnd}
                  onTouchStartRow={onTouchStartRow}
                  onTouchMoveRow={onTouchMoveRow}
                  onTouchEndRow={onTouchEndRow}

                  actionFocus={actionFocus}
                  setActionFocus={setActionFocus}
                  executeRowAction={executeRowAction}
                  autoOpenSettings={autoOpenSettings}

                  getStruct={(k) => store.get(k, 'heavy')}
                  setStruct={(k,v) => updateData(k, v)}
                  getNameOverride={(k, f) => store.get(k, f || '')}
                  setNameOverride={(k, v) => updateData(k, v)}
                  getMeta={(k) => store.get(k, '')}
                  setMeta={(k, v) => updateData(k, v)}
                  onTextChange={updateData}

                  editRowKey={editRowKey}
                />
              );
            })}
          </div>

          {/* Lower panels moved down */}
          <div className="panel">
            <div className="panel-title"><span>Structure</span></div>
            <TreeView store={store} path={path} onNavigate={navigateToPath} storeVersion={storeVersion} />
          </div>

          <div className="panel">
            <div className="panel-title"><span>Prompt</span></div>
            <textarea readOnly value={promptText} className="underline-textarea" style={{ minHeight: '120px' }} />
            <div style={{ height: 8 }}></div>
            <button
              className="omni-input"
              data-hotkey-scope="ui"
              style={{ cursor: 'pointer', border: 'none', background: 'transparent', textAlign: 'left' }}
              onClick={() => {
                const wrap = document.getElementById('alltext-wrapper');
                if (wrap) wrap.style.display = (wrap.style.display === 'none' ? '' : 'none');
              }}
            >
              Show / Hide All Text
            </button>
            <div id="alltext-wrapper" style={{ marginTop: 8 }}>
              <textarea className="alltext" readOnly value={allTextContent}></textarea>
            </div>
          </div>

          <div className="panel">
            <div className="panel-title">
              <span>Output</span>
              <button
                className="omni-input"
                data-hotkey-scope="ui"
                onClick={resetAll}
                style={{ cursor: 'pointer', border: 'none', background: 'transparent' }}
              >
                Reset All
              </button>
            </div>
            <textarea className="underline-textarea" value={store.get(outputKey, outputDefault)} onChange={e => updateData(outputKey, e.target.value)} style={{ minHeight: '150px' }}></textarea>
          </div>
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div class="error">Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
