<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>(: Smile Composer ‚Äî live module add, exact bottom-return ‚Üë, correct module indent)</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    :root { --tab: 32px; --soft-bg: #fafafa; --select-bg: #f2f2f2; --rule: rgba(0,0,0,0.08); --sidebar-w: 360px; }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, Segoe UI, Helvetica, Arial, sans-serif; background: #fff; color: #111; padding: 24px; margin: 0; }
    .layout { display: grid; grid-template-columns: 1fr var(--sidebar-w); gap: 16px; align-items: start; }
    .left-column { display: grid; grid-template-rows: auto auto; gap: 12px; }
    .panel { background: #fff; padding: 16px; box-shadow: 0 1px 0 0 var(--rule); border-radius: 10px; }

    .sc-title { font-size: inherit; font-weight: 400; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .sc-title strong em { font-style: italic; }
    .reset-btn { font-size: 12px; border: 1px solid var(--rule); background: #fff; border-radius: 8px; padding: 4px 10px; cursor: pointer; }

    .line { user-select: none; padding: 8px 10px; border-radius: 10px; display: flex; align-items: center; justify-content: space-between; gap: 10px; cursor: pointer; transition: background-color 0.12s ease, opacity 0.12s ease; touch-action: none; position: relative; }
    .line.sel { font-weight: 600; background-color: var(--select-bg); }
    .left-span { flex: 1 1 auto; min-width: 0; display: inline-flex; align-items: center; gap: 10px; }

    .indent-block { margin-top: 8px; }
    .prompt-preview { white-space: pre-wrap; font-size: 13px; color: #222; }

    .underline-input, .underline-textarea {
      width: 100%; background: transparent; border: none; border-bottom: 1px solid #ccc; border-radius: 0;
      padding: 6px 2px 6px 0; font: inherit; outline: none; resize: vertical; min-height: 34px;
    }
    .underline-textarea { min-height: 80px; }

    .action-bar-inline { display: block; margin-top: 8px; }
    .action-row { display: inline-flex; align-items: center; gap: 10px; width: 100%; }
    .action-spacer { flex: 1 1 auto; }
    .action-hint-left { font-size: 12px; color: #444; user-select: none; }
    .action-hint-right { font-size: 12px; color: #444; user-select: none; }

    .settings-buttons { display: flex; justify-content: flex-end; gap: 8px; margin-top: 6px; }
    .settings-btn { font-size: 12px; border: 1px solid var(--rule); background: #fff; border-radius: 8px; padding: 4px 10px; cursor: default; }

    .rightbar { position: sticky; top: 16px; height: calc(100vh - 32px); overflow: auto; background: #fff; box-shadow: 0 1px 0 0 var(--rule); border-radius: 10px; padding: 12px; }
    .rightbar textarea { width: 100%; height: calc(100vh - 56px); border: none; outline: none; resize: none; background: transparent; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; line-height: 1.5; }

    .add-bar .dock { border-radius: 12px; padding: 8px; background: #fff; box-shadow: 0 1px 0 0 var(--rule); }
    .omni-input { border: none; outline: none; background: transparent; font: inherit; padding: 8px 2px; width: 100%; transition: background-color 0.12s ease; }
    .omni-input:focus { background-color: var(--select-bg); }
    .omni-list { max-height: 320px; overflow: auto; display: grid; gap: 6px; margin-top: 6px; }
    .omni-item { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 10px 12px; background: var(--soft-bg); border-radius: 12px; cursor: pointer; }
    .omni-item.sel { font-weight: 600; background-color: var(--select-bg); }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; background: #eee; text-transform: lowercase; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
  (function () {
    if (!(window.React && window.ReactDOM)) {
      document.getElementById('root').innerHTML = '<div class="error">Failed to load React</div>';
      return;
    }

    const { useState, useEffect, useRef, useCallback, useMemo } = React;
    const TAB = 32;

    const INITIAL_DB = {"expert-maker":{"name":"Expert Maker","type":"agent","input":"Question","output":"Answer","modules":["role-information"]},"role-information":{"name":"Role Information","type":"mod","items":["ri-01","ri-02","ri-03","ri-04","ri-05","ri-06","ri-07","ri-08","ri-09"]},"ri-01":{"name":"testing/Default_Parameters.txt","type":"instr","text":"[$TEMP: Agent Parameters + default values - (; note: this section is auto graduated into the prompt as defaults when values are provided, and only used when [$Variables$] have not been find and replaced ;) [\r\n\r\n     [! Task requirements [\r\n               Demonstrate that you are aware of what this prompt contains and what it intends to create and all the different pieces of how it does it.\r\n     ] \r\n\r\n     [$Name_Tag_Emojis$] = üëÅÔ∏è‚Äçüó®Ô∏è‚öôÔ∏è\r\n     [$Role_Name$] = Self-Description Default\r\n     [$Name_Tag$] = [$Name_Tag_Emojis$] ***[$Name_Tag$]***:\r\n\r\n     [$TEMP: Temporary response format - We use this for testing comprehension of the prompt and adherence to the styles [ \r\n          {Your name tag}\r\n\r\n          # The World According To This Prompt\r\n\r\n          {Write a clear explanation of how you think this prompt wants you to behave. Reference the name tag, response styles, and the role meta-information.}\r\n\r\n          # Instruction Stack\r\n\r\n          {List every instruction layer you will follow, in order, with a short sentence for each explaining what it does.}\r\n\r\n          # How You Will Honor Them\r\n\r\n          {State how you will ensure those layers stick during generation.}\r\n\r\n          # What You Will Avoid\r\n\r\n          {Name constraints that would break the style, and how you will avoid them.}\r\n     ] End temporary response format $]\r\n\r\n     [$Defaults: Response Formatting$] = Heavy\r\n     [$Defaults: Name_Tag$] = [$Name_Tag$]\r\n     [$Defaults: Emojis$] = [$Name_Tag_Emojis$]\r\n     [$Defaults: Structure$] = Strong\r\n     [$Defaults: Style$] = Dense\r\n\r\n] End section, agent parameters default values are provided values. This is the end of the section now. $]"},"ri-02":{"name":"Replicated_instructions.txt","type":"instr","text":"(! Essential instructions - In this next instruction we replicate the most essential policy lines and active behaviors so they can be reinstated and checked everywhere !)\r\n\r\nAlways begin your responses with your name tag exactly.\r\nNever fragment or partially deliver code; always deliver entire single-file artifacts.\r\nWhen summarizing, use exactly four bullets. When researching, write six or more paragraphs. When chatting, one short sentence. When coding, include a full file and a 12 sentence commit text.\r\nNever imply continuation or ask questions at the end. Conclude with a recognition and completion paragraph that reflects what occurred.\r\nReflect honestly when your outputs diverge from expectations, and identify the origin of misunderstanding.\r\nAvoid cynicism and negativity; speak positively and constructively.\r\nUse bold and italics as specified by the response language style. Use definitions and etymology when they add non-trivial depth to the topic you introduce.\r\nNever define the user‚Äôs own words unless they explicitly ask for learning support.\r\nNever suggest future directions in the final paragraph.\r\n\r\n(! End essential instructions !)\r\n"},"ri-03":{"name":"meta-information/emoticons_meta-information.txt","type":"instr","text":"(: Emoticons meta-information - signals, consistency, and affect calibration (\r\n\r\nUse two emoticons for section names when emphasizing attentional shifts.\r\nKeep emoticon use consistent across the conversation to stabilize tone.\r\nFavor clarity over ornamentation; emoticons are attentional markers more than decoration.\r\nAnchor the name tag emoticons to identity and role recall.\r\n\r\n) End emoticons meta-information :)\r\n"},"ri-04":{"name":"name_tag.txt","type":"instr","text":"(: Name tag definition - signature and identity format (\r\n\r\nYour name tag is a fixed header that starts every response: it carries your emoji signature and highlighted role name.\r\nFormat: [$Name_Tag_Emojis$] ***[$Role_Name$]***:\r\nUse the exact punctuation and spacing so that detection is reliable.\r\n\r\n) End name tag block :)\r\n"},"ri-05":{"name":"Response_language_meta-information_(brief)","type":"instr","text":"(: Response language meta-information (brief) (\r\n\r\nUse **bold** to spotlight crucial operational directives and concepts that must persist.\r\nUse *italics* for rhetorical grace and cadence without overwhelming the information density.\r\nAdd [definitions] inline when you introduce domain terms outside the user‚Äôs own vocabulary and only when that genuinely increases meaning.\r\nAdd (etymology) sparingly to deepen nuance where it illuminates semantic lineage that aids precise reasoning.\r\n\r\n) End brief response language meta-information :)\r\n"},"ri-06":{"name":"Bold & Italics","type":"instr","text":"(: Bold and italics usage (\r\n\r\n**Bold** draws durable attention to structural rules and decision-critical statements.\r\n*Italics* soften tone and guide rhythm without diluting clarity.\r\n***Bold and italics together*** are reserved for names, declared roles, and identity signals.\r\n\r\n) End bold and italics :)\r\n\r\n(: Both-at-once guidance (\r\nCombine **bold** with *italics* only to elevate identity anchors, titled constructs, or top-level section banners.\r\nDo not use both-at-once for incidental emphasis.\r\n\r\n) End both-at-once :)\r\n"},"ri-07":{"name":"Paragraphs","type":"instr","text":"(: Paragraph structure and density guidance (\r\n\r\nWrite in well-formed paragraphs that carry one conceptual thrust each while chaining logically into a cohesive flow.\r\nPrefer six or more paragraphs when researching or studying so you can unfold argument, context, method, counterpoints, synthesis, and closure.\r\nIn casual social exchanges, compress to a single felt sentence that carries warmth and clarity.\r\n\r\n) End paragraph guidance :)\r\n"},"ri-08":{"name":"Bold_italics_and_both_at_once","type":"instr","text":"(: Bold, italics, and both at once (\r\n\r\n**Bold**: prioritize conceptual anchors, rules, and constraints.\r\n*Italics*: carry tone, asides, and graceful transitions.\r\n***Bold+Italics***: identity banners, role names, and special entities.\r\n\r\nKeep typography in service of meaning; avoid theatrical excess.\r\n\r\n) End typography triad :)\r\n"},"ri-09":{"name":"Definitions_and_etymology","type":"instr","text":"(: Define jargon in (rounded brackets) and explore etymology in [square brackets] for exploring the edges of meaning and maximizing intelligence (\r\n                    \r\n    [: When you pull jargon from  expertise domains you  steer your language to honor that field‚Äôs inner logic, which increases specificity and therefore utility.\r\n\r\n    @1@ Define all jargon: Use rich niche jargon from deep, nuanced subfields and immediately define them (in brackets like this, talking about what they mean).\r\n    @2@ Explore the etymology of words:  add [square brackets like this, with roots] explaining the lineage of meaning; this allows you to create more ideas to leverage later in your response.\r\n\r\n    In Summary: Use (rounded brackets) for definitions around jargon and extract [etymology] into their separate etymology meanings and weave them together.\r\n\r\n    Generally, if you have more uncertainty about a topic, you can define more, cite more, and discuss to build expertise in your context for you to use.\r\n) End jargon, defining and etymology guidance :)\r\n"}};

    class DataStore {
      constructor() { this.data = this.loadFromStorage(); this.db = { ...INITIAL_DB }; this.version = 0; }
      loadFromStorage() { try { const stored = localStorage.getItem('smileData'); return stored ? JSON.parse(stored) : {}; } catch(e){ return {}; } }
      saveToStorage(data) { try { localStorage.setItem('smileData', JSON.stringify(data)); } catch(e){} }
      get(key, def) { return key in this.data ? this.data[key] : def; }
      set(key, value) { this.data = { ...this.data, [key]: value }; this.version++; this.saveToStorage(this.data); return this.data; }
      reset() { this.data = {}; localStorage.removeItem('smileData'); this.db = { ...INITIAL_DB }; this.version++; return this.data; }
      getDbItem(id) { return this.db[id] || null; }
      addCustomDbItem(id, item) { this.db[id] = item; this.version++; }
      getAllDb() { return this.db; }
      getVersion() { return this.version; }
    }

    const moveInList = (arr, fromPos, toPos) => {
      if (fromPos === toPos || fromPos < 0 || toPos < 0 || fromPos >= arr.length) return arr;
      const newArr = [...arr];
      const [item] = newArr.splice(fromPos, 1);
      const insertPos = Math.min(toPos, newArr.length);
      newArr.splice(insertPos, 0, item);
      return newArr;
    };

    const displayNameFor = (store, dbItem, id) =>
      store.get(`nn-${id}`, store.get(`n-${dbItem.name}`, dbItem.name));

    const useInstrUi = () => {
      const [state, setState] = useState({ rowKey: null, stage: 0 });
      return {
        isFor: (rowKey) => state.rowKey === rowKey && state.stage > 0,
        stage: () => state.stage,
        openStage1: (rowKey) => setState({ rowKey, stage: 1 }),
        toStage2: () => setState(s => (s.rowKey ? { rowKey: s.rowKey, stage: 2 } : s)),
        backToStage1: () => setState(s => (s.rowKey ? { rowKey: s.rowKey, stage: 1 } : s)),
        closeAll: () => setState({ rowKey: null, stage: 0 }),
        rowKey: () => state.rowKey
      };
    };

    class RowBuilder {
      constructor(store, path) { this.store = store; this.path = path; this.rows = []; }
      build() {
        this.addAgent();
        if (this.isAtModule()) this.addModuleContent(); else this.addAgentModules();
        return this.rows;
      }
      addAgent() {
        const agent = this.getAgent(); if (!agent) return;
        this.rows.push({ key: `agent:${this.path[0]}`, type: 'agent', depth: 0, label: this.store.get(`n-${agent.name}`, agent.name) });
      }
      addModuleContent() {
        const module = this.getCurrentModule(); if (!module) return;
        const moduleDBKey = this.path[this.path.length - 1];
        this.rows.push({ key: `module:${moduleDBKey}`, type: 'module', depth: 1, label: this.store.get(`n-${module.name}`, module.name), moduleId: moduleDBKey });
        const items = this.store.get(`items-${module.name}`, module.items || []);
        items.forEach((id, i) => {
          const ins = this.store.getDbItem(id); if (!ins) return;
          this.rows.push({
            key: `ins:${id}`, type: 'instr', depth: 2,
            label: displayNameFor(this.store, ins, id),
            isOutput: i === items.length - 1,
            nameKey: `n-${ins.name}`, nameOverrideKey: `nn-${id}`,
            textKey: `t-${ins.name}`, defaultText: ins.text || '',
            metaKey: `meta-${id}`, structKey: `struct-${id}`,
            promptKey: `t-${ins.name}`, dbId: id, pos: i, canReorder: true
          });
        });
      }
      addAgentModules() {
        const agent = this.getAgent(); if (!agent) return;
        const modules = this.store.get(`mods-${agent.name}`, agent.modules || []);
        modules.forEach((mid, i) => {
          const mod = this.store.getDbItem(mid); if (!mod) return;
          this.rows.push({
            key: `mod:${mid}:${i}`, type: 'module-item', depth: 1,
            label: displayNameFor(this.store, mod, mid),
            isOutput: i === modules.length - 1,
            nameKey: `n-${mod.name}`, nameOverrideKey: `nn-${mid}`,
            metaKey: `meta-${mid}`, structKey: `struct-${mid}`,
            moduleId: mid, pos: i, canReorder: true
          });
        });
      }
      isAtModule() { return this.path.length >= 2; }
      getAgent() { return this.store.getDbItem(this.path[0]); }
      getCurrentModule() { const last = this.path[this.path.length - 1]; return this.store.getDbItem(last); }
    }

    function StructureDots5({ id, value, onChange }) {
      const opts = [
        { v: 'heavy', label: 'Heavy' },
        { v: 'heavy-mid', label: '‚óè' },
        { v: 'medium', label: 'Medium' },
        { v: 'medium-light', label: '‚óè' },
        { v: 'light', label: 'Light' }
      ];
      return (
        <div className="seg" role="radiogroup" aria-label="Structure">
          <span className="label">Structure</span>
          {opts.map((o) => (
            <label key={o.v} title={o.label}>
              <input type="radio" name={`struct-${id}`} value={o.v} checked={value === o.v} onChange={(e) => onChange(e.target.value)} />
              <span className="opt">
                {o.label === '‚óè' ? <span className="dot" aria-hidden="true"></span> : <span style={{ fontSize: 12 }}>{o.label}</span>}
              </span>
            </label>
          ))}
        </div>
      );
    }

    function ActionBar({ pad }) {
      return (
        <div className="action-bar-inline" style={{ paddingLeft: pad }}>
          <div className="action-row" onClick={(e)=>e.stopPropagation()}>
            <span className="action-hint-left">([Esc] to cancel)</span>
            <span className="action-spacer"></span>
            <span className="action-hint-right">-&gt; Settings</span>
          </div>
        </div>
      );
    }

    function SettingsButtons({
      pad, isHovering, hoverAction, onEnterMove, onLeaveMove, onEnterDuplicate, onLeaveDuplicate, onEnterDelete, onLeaveDelete
    }) {
      return (
        <div className="settings-buttons" style={{ paddingLeft: pad }}>
          <span
            className="settings-btn"
            onMouseEnter={onEnterMove}
            onMouseLeave={onLeaveMove}
            title="Use ‚Üë ‚Üì to move while hovering"
          >
            -&gt; Movement
          </span>
          <span
            className="settings-btn"
            onMouseEnter={onEnterDuplicate}
            onMouseLeave={onLeaveDuplicate}
            title="Press Enter to Duplicate"
          >
            {hoverAction === 'duplicate' ? 'Press Enter to Duplicate' : '-&gt; + Duplicate'}
          </span>
          <span
            className="settings-btn"
            onMouseEnter={onEnterDelete}
            onMouseLeave={onLeaveDelete}
            title="Press Enter To Confirm Delete"
          >
            {hoverAction === 'delete' ? 'Press Enter To Confirm Delete' : '-&gt; Delete'}
          </span>
        </div>
      );
    }

    function InstructionInlineEditor({
      store, row, onTextChange, getNameOverride, setNameOverride,
      getMeta, setMeta, getStruct, setStruct, stage=2, onDownFromMainToMeta
    }) {
      const pad = ((row.depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          <textarea
            className="underline-textarea"
            data-tarea={row.key}
            value={store.get(row.promptKey, row.defaultText || '')}
            onChange={(e) => onTextChange(row.promptKey, e.target.value)}
            onKeyDown={(e) => {
              if (stage === 2 && e.key === 'ArrowDown') {
                const v = e.currentTarget.value || '';
                const selStart = e.currentTarget.selectionStart;
                const selEnd = e.currentTarget.selectionEnd;
                if (selStart === selEnd && selEnd === v.length) {
                  e.preventDefault();
                  if (onDownFromMainToMeta) onDownFromMainToMeta();
                }
              }
            }}
            placeholder="Instruction‚Ä¶"
          />
          {stage === 2 && (
            <>
              <input
                type="text"
                className="underline-input"
                value={getNameOverride(row.nameOverrideKey, '')}
                onChange={(e) => setNameOverride(row.nameOverrideKey, e.target.value)}
                placeholder="Name‚Ä¶"
              />
              <textarea
                className="underline-textarea"
                data-meta={row.key}
                value={getMeta(row.metaKey) || ''}
                onChange={(e) => setMeta(row.metaKey, e.target.value)}
                placeholder="Meta information‚Ä¶"
              />
              <StructureDots5
                id={row.dbId}
                value={getStruct(row.structKey) || 'heavy'}
                onChange={(v) => setStruct(row.structKey, v)}
              />
            </>
          )}
        </div>
      );
    }

    function InstructionPreviewLine({ store, row }) {
      const text = store.get(row.promptKey, row.defaultText || '') || '';
      const first = text.split(/\r?\n/)[0];
      const pad = ((row.depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          <div className="prompt-preview">{first || '‚Äî'}</div>
        </div>
      );
    }

    function ModulePreview({ store, moduleId, depth }) {
      const mod = store.getDbItem(moduleId);
      if (!mod) return null;
      const items = store.get(`items-${mod.name}`, mod.items || []);
      const pad = ((depth || 0) + 1) * TAB;
      return (
        <div className="indent-block" style={{ paddingLeft: pad }}>
          {items.length === 0 ? <div className="prompt-preview">Empty module</div> :
            items.map((iid, idx) => {
              const ins = store.getDbItem(iid); if (!ins) return null;
              const isLast = idx === items.length - 1;
              return (
                <div key={iid} className="prompt-preview">
                  {isLast ? <strong>OUTPUT: </strong> : null}{displayNameFor(store, ins, iid)}
                </div>
              );
            })}
        </div>
      );
    }

    function RightSidebar({ value, onChange }) {
      return (
        <div className="rightbar">
          <textarea value={value} onChange={onChange}></textarea>
        </div>
      );
    }

    function App() {
      const storeRef = useRef(new DataStore());
      const store = storeRef.current;

      const [storeVersion, setStoreVersion] = useState(store.getVersion());
      const [tick, setTick] = useState(0);

      const [path, setPath] = useState(() => {
        const hash = window.location.hash.slice(1);
        if (hash) { const parts = hash.split('/').filter(Boolean); if (parts.length > 0) return parts; }
        return ['expert-maker'];
      });

      const [idx, setIdx] = useState(0);
      const [navHistory, setNavHistory] = useState({});
      const [reorderState, setReorderState] = useState(null);
      const [hoverAction, setHoverAction] = useState(null);
      const [hoverRowKey, setHoverRowKey] = useState(null);

      const rowsRef = useRef([]);
      const instrUi = useInstrUi();

      const [omniActive, setOmniActive] = useState(false);
      const [omniQuery, setOmniQuery] = useState('');
      const [omniFocus, setOmniFocus] = useState(false);
      const [omniSelectedIdx, setOmniSelectedIdx] = useState(0);
      const omniInputRef = useRef(null);

      const buildRows = useCallback(() => {
        const builder = new RowBuilder(store, path);
        return builder.build();
      }, [store, path]);

      const rows = useMemo(() => {
        const built = buildRows();
        rowsRef.current = built;
        return built;
      }, [buildRows, storeVersion, tick]);

      const atModule = path.length >= 2;
      const allowedType = atModule ? 'instr' : 'mod';

      const agent = store.getDbItem(path[0]) || store.getDbItem('expert-maker');
      const module = atModule ? store.getDbItem(path[path.length - 1]) : null;

      const updateData = useCallback((key, value) => {
        store.set(key, value);
        setStoreVersion(store.getVersion());
        setTick(t => t + 1);
      }, [store]);

      const didInitRef = useRef(false);
      useEffect(() => {
        if (didInitRef.current) return;
        if (path.length === 1) {
          const firstModIdx = rowsRef.current.findIndex(r => r.type === 'module-item');
          if (firstModIdx >= 0) setIdx(firstModIdx);
        }
        didInitRef.current = true;
      }, [path]);

      const agentModules = useMemo(() => agent ? (store.get(`mods-${agent.name}`, agent.modules || [])) : [], [store, agent, storeVersion]);

      const ensureModuleForAgent = useCallback(() => {
        if (agentModules.length > 0) return agentModules[agentModules.length - 1];
        const id = 'mod-' + Date.now();
        store.addCustomDbItem(id, { name: 'General', type: 'mod', items: [] });
        const key = `mods-${agent.name}`;
        const arr = store.get(key, agent.modules || []);
        updateData(key, [...arr, id]);
        return id;
      }, [agent, agentModules, store, updateData]);

      const addInstructionToModule = useCallback((moduleId, instrId, insertPos = null) => {
        const m = store.getDbItem(moduleId); if (!m) return;
        const key = `items-${m.name}`;
        const arr = store.get(key, m.items || []);
        const pos = (insertPos !== null && insertPos >= 0 && insertPos <= arr.length) ? insertPos : arr.length;
        const newArr = [...arr]; newArr.splice(pos, 0, instrId);
        updateData(key, newArr);
        
        setTimeout(() => {
          const r = rowsRef.current;
          let targetIdx = r.findIndex(x => x.type === 'instr' && x.dbId === instrId && x.pos === pos);
          if (targetIdx < 0) {
            const all = r.map((x,i)=>[x,i]).filter(([x]) => x.type === 'instr' && x.dbId === instrId);
            if (all.length) targetIdx = all[all.length - 1][1];
          }
          if (targetIdx >= 0) setIdx(targetIdx);
        }, 0);
      }, [store, updateData]);

      const addModuleToAgent = useCallback((agentId, modId, insertPos = null) => {
        const ag = store.getDbItem(agentId); if (!ag) return;
        const key = `mods-${ag.name}`;
        const base = store.get(key, ag.modules || []);
        const pos = (insertPos !== null && insertPos >= 0 && insertPos <= base.length) ? insertPos : base.length;
        const next = [...base]; next.splice(pos, 0, modId);
        updateData(key, next);

        setPath([agentId]);
        setTimeout(() => {
          const r = rowsRef.current;
          let targetIdx = r.findIndex(x => x.type === 'module-item' && x.moduleId === modId && x.pos === pos);
          if (targetIdx < 0) {
            const all = r.map((x,i)=>[x,i]).filter(([x]) => x.type === 'module-item' && x.moduleId === modId);
            if (all.length) targetIdx = all[all.length - 1][1];
          }
          if (targetIdx >= 0) setIdx(targetIdx);
        }, 0);
      }, [store, updateData]);

      const duplicateInstruction = useCallback((dbId, insertAtPos = null) => {
        if (!module) return null;
        const m = module;
               const item = store.getDbItem(dbId); if (!item) return null;
        const arr = store.get(`items-${m.name}`, m.items || []);
        const newId = 'custom-' + Date.now();
        const baseName = displayNameFor(store, item, dbId);
        const baseTextKey = `t-${item.name}`;
        const baseText = store.get(baseTextKey, item.text || '');
        store.addCustomDbItem(newId, { name: baseName + ' (copy)', type: 'instr', text: baseText });
        const newArr = [...arr];
        const at = (insertAtPos !== null && insertAtPos >= 0 && insertAtPos <= arr.length) ? insertAtPos : arr.length;
        newArr.splice(at, 0, newId); updateData(`items-${m.name}`, newArr);
        updateData(`nn-${newId}`, baseName + ' (copy)');
        updateData(`t-${newId}`, baseText);
        setTimeout(() => {
          const r = rowsRef.current;
          const i = r.findIndex(x => x.type === 'instr' && x.dbId === newId);
          if (i >= 0) setIdx(i);
        }, 0);
        return newId;
      }, [store, updateData, module]);

      const removeInstructionAtPos = useCallback((pos) => {
        if (!module) return;
        const arr = store.get(`items-${module.name}`, module.items || []);
        const next = arr.filter((_, i) => i !== pos);
        updateData(`items-${module.name}`, next);
        setTimeout(() => {
          const r = rowsRef.current;
          let target = r.findIndex(x => x.type === 'instr' && x.pos === pos);
          if (target < 0) target = r.findIndex(x => x.type === 'instr' && x.pos === pos - 1);
          if (target >= 0) setIdx(target);
        }, 0);
      }, [module, store, updateData]);

      const startMove = useCallback((row) => {
        if (!module || row.type !== 'instr') return;
        const arrKey = `items-${module.name}`;
        const arr = store.get(arrKey, module.items || []);
        setReorderState({
          rowKey: row.key,
          itemId: row.dbId,
          arrKey,
          originalOrder: [...arr],
          originalPos: row.pos,
          currentPos: row.pos
        });
      }, [store, module]);

      const moveItemInReorderMode = useCallback((direction) => {
        if (!reorderState) return;
        const arr = store.get(reorderState.arrKey, []);
        const delta = direction === 'up' ? -1 : 1;
        const keepTo = reorderState.currentPos + delta;
        if (keepTo < 0 || keepTo >= arr.length) return;
        const newArr = moveInList(arr, reorderState.currentPos, keepTo);
        updateData(reorderState.arrKey, newArr);
        setReorderState(prev => ({ ...prev, currentPos: keepTo }));
      }, [reorderState, store, updateData]);

      const endReorder = useCallback(() => {
        if (!reorderState) return;
        const { itemId, currentPos } = reorderState;
        setReorderState(null);
        setTimeout(() => {
          const r = rowsRef.current;
          const i = r.findIndex(x => x.type === 'instr' && x.dbId === itemId && x.pos === currentPos);
          if (i >= 0) setIdx(i);
        }, 0);
      }, [reorderState]);

      const cancelReorder = useCallback(() => {
        if (!reorderState) return;
        const { arrKey, originalOrder, itemId, originalPos } = reorderState;
        updateData(arrKey, originalOrder);
        setReorderState(null);
        setTimeout(() => {
          const targetIdx = rowsRef.current.findIndex(r =>
            (r.type === 'instr') && (r.dbId === itemId) && r.pos === originalPos
          );
          if (targetIdx >= 0) setIdx(targetIdx);
        }, 0);
      }, [reorderState, updateData]);

      const computedPromptText = useMemo(() => {
        const buildPrompt = () => {
          if (!agent) return '';
          const mods = store.get(`mods-${agent.name}`, agent.modules || []);
          const lines = [];
          mods.forEach(mid => {
            const m = store.getDbItem(mid); if (!m) return;
            lines.push(`Module: ${displayNameFor(store, m, mid)}`);
            const ids = store.get(`items-${m.name}`, m.items || []);
            ids.forEach((iid, idx) => {
              const it = store.getDbItem(iid); if (!it) return;
              const one = store.get(`t-${it.name}`, it.text || '').split(/\r?\n/)[0];
              const prefix = (idx === ids.length - 1) ? 'OUTPUT:' : '-';
              lines.push(`  ${prefix} ${displayNameFor(store, it, iid)} ‚Äî ${one}`);
            });
            lines.push('');
          });
          return lines.join('\n');
        };
        return buildPrompt();
      }, [storeVersion, agent, store]);

      const rightbarManual = store.get('rightbar-prompt-manual', false);
      const rightbarValue = rightbarManual ? store.get('rightbar-prompt', '') : computedPromptText;

      const collectSearchables = (dbObj) => {
        const out = [];
        Object.keys(dbObj).forEach(id => {
          const it = dbObj[id]; if (!it) return;
          if (it.type === 'mod' || it.type === 'instr') out.push({ id, type: it.type, name: it.name || '', text: it.text || '' });
        });
        return out;
      };

      const db = store.getAllDb();

      const omniResults = useMemo(() => {
        const q = (omniQuery || '').toLowerCase().trim();
        if (!q) return [];
        const haystack = collectSearchables(db).filter(x => x.type === allowedType);
        const matches = haystack.filter(x => ((x.name + ' ' + x.text).toLowerCase().includes(q)));
        matches.sort((a,b)=>a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
        return matches;
      }, [db, omniQuery, allowedType]);

      const bumpFreq = useCallback((id) => {
        const map = store.get('freq-map', {});
        const next = { ...map, [id]: (map[id] || 0) + 1 };
        updateData('freq-map', next);
      }, [store, updateData]);

      const omniSuggestions = useMemo(() => {
        const map = store.get('freq-map', {});
               const haystack = collectSearchables(db).filter(x => x.type === allowedType);
        haystack.sort((a,b) => {
          const da = map[a.id] || 0;
          const dbb = map[b.id] || 0;
          if (dbb !== da) return dbb - da;
          return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
        return haystack.slice(0, 8);
      }, [db, storeVersion, allowedType]);

      const focusInlineTextarea = (rowKey) => {
        setTimeout(() => {
          const ta = document.querySelector(`[data-tarea="${rowKey}"]`);
          if (ta) {
            ta.focus();
            const len = ta.value.length;
            try { ta.setSelectionRange(len, len); } catch(_) {}
          }
        }, 0);
      };

      const focusMetaTextarea = (rowKey) => {
        setTimeout(() => {
          const meta = document.querySelector(`[data-meta="${rowKey}"]`);
          if (meta) {
            meta.focus();
            const len = meta.value.length;
            try { meta.setSelectionRange(len, len); } catch(_) {}
          }
        }, 0);
      };

      const addByIdAtContext = useCallback((id) => {
        const item = db[id]; if (!item) return;
        if (item.type !== allowedType) return;
        const sel = rowsRef.current[idx];

        if (item.type === 'instr') {
          const targetModuleId = (path.length >= 2) ? path[path.length - 1] : ensureModuleForAgent();
          let insertPos = null;
          
          if (path.length >= 2) {
            const m = store.getDbItem(targetModuleId);
            const key = `items-${m.name}`;
            const arr = store.get(key, m.items || []);
            insertPos = (sel && sel.type === 'instr') ? sel.pos + 1 : arr.length;
          } else {
            insertPos = null;
          }
          
          addInstructionToModule(targetModuleId, id, insertPos);
          bumpFreq(id);
          return;
        }

        if (item.type === 'mod') {
          const agentId = path[0];
          const ag = store.getDbItem(agentId);
          const key = `mods-${ag.name}`;
          const arr = store.get(key, ag.modules || []);
          let insertPos = arr.length;

          if (path.length === 1) {
            insertPos = (sel && sel.type === 'module-item') ? sel.pos + 1 : arr.length;
          } else {
            const currentModuleId = path[path.length - 1];
            const posInAgent = arr.indexOf(currentModuleId);
            insertPos = posInAgent >= 0 ? posInAgent + 1 : arr.length;
          }

          addModuleToAgent(agentId, id, insertPos);
          bumpFreq(id);
          return;
        }
      }, [db, path, idx, ensureModuleForAgent, addInstructionToModule, addModuleToAgent, store, bumpFreq, allowedType]);

      const createAndAddNewItem = useCallback(() => {
        if (allowedType === 'instr' && path.length >= 2) {
          const newId = 'custom-' + Date.now();
          store.addCustomDbItem(newId, { name: 'New Instruction', type: 'instr', text: '' });
          addInstructionToModule(path[path.length - 1], newId);
          updateData(`nn-${newId}`, 'New Instruction');
          updateData(`t-${newId}`, '');
          return;
        }
        if (allowedType === 'mod') {
          const newId = 'mod-' + Date.now();
          store.addCustomDbItem(newId, { name: 'New Module', type: 'mod', items: [] });
          addModuleToAgent(path[0], newId);
          updateData(`nn-${newId}`, 'New Module');
          return;
        }
      }, [allowedType, path, store, addInstructionToModule, addModuleToAgent, updateData]);

      const navigateIntoModule = useCallback((moduleId, agentIdForHistoryIdx) => {
        if (agentIdForHistoryIdx) setNavHistory(h => ({ ...h, [agentIdForHistoryIdx]: idx }));
        setPath(prev => {
          const baseAgent = prev[0];
          return [baseAgent, moduleId];
        });
        setIdx(2);
        setTimeout(() => {
          const r = rowsRef.current;
          const firstInstrIdx = r.findIndex(x => x.type === 'instr');
          if (firstInstrIdx >= 0) setIdx(firstInstrIdx);
          else {
            const headerIdx = r.findIndex(x => x.type === 'module' && x.moduleId === moduleId);
            if (headerIdx >= 0) setIdx(headerIdx);
          }
        }, 0);
      }, [idx]);

      const handleReset = useCallback(() => {
        store.reset();
        setStoreVersion(store.getVersion());
        setPath(['expert-maker']);
        setIdx(0);
        setNavHistory({});
        setReorderState(null);
        setHoverAction(null);
        setHoverRowKey(null);
        setOmniActive(false);
        setOmniQuery('');
        setOmniSelectedIdx(0);
        instrUi.closeAll();
        try { window.history.pushState(null, '', '#expert-maker'); } catch(_) {}
      }, [store, instrUi]);

      const handleKeyDown = useCallback((e) => {
        if ((e.key === '+' || e.key === '=') && document.activeElement !== omniInputRef.current) {
          e.preventDefault();
          setOmniActive(true);
          setTimeout(() => { if (omniInputRef.current) omniInputRef.current.focus(); }, 0);
          return;
        }

        if (document.activeElement === omniInputRef.current) return;

        if (reorderState) {
          if (e.key === 'ArrowUp') { e.preventDefault(); moveItemInReorderMode('up'); return; }
          if (e.key === 'ArrowDown') { e.preventDefault(); moveItemInReorderMode('down'); return; }
          if (e.key === 'Escape') { e.preventDefault(); endReorder(); return; }
        }

        if (hoverAction && e.key === 'Enter') {
          e.preventDefault();
          const rws = rowsRef.current;
          const sel = rws[idx];
          if (sel && sel.type === 'instr') {
            if (hoverAction === 'duplicate') {
              duplicateInstruction(sel.dbId, sel.pos + 1);
            } else if (hoverAction === 'delete') {
              removeInstructionAtPos(sel.pos);
            }
          }
          setHoverAction(null);
          setHoverRowKey(null);
          return;
        }

        const rws = rowsRef.current;
        const sel = rws[idx]; if (!sel) return;

        if (e.key === 'ArrowRight' && sel.type === 'instr') {
          e.preventDefault();
          if (!instrUi.isFor(sel.key)) { instrUi.openStage1(sel.key); focusInlineTextarea(sel.key); return; }
          if (instrUi.stage() === 1) { instrUi.toStage2(); return; }
        }

        if (e.key === 'ArrowDown' && sel.type === 'instr' && instrUi.isFor(sel.key)) {
          return;
        }

        if (e.key === 'ArrowLeft' && sel.type === 'instr') {
          e.preventDefault();
          if (instrUi.isFor(sel.key)) {
            instrUi.closeAll();
            return;
          } else {
            const modId = path[path.length - 1];
            const headerIdx = rowsRef.current.findIndex(r => r.type === 'module' && r.moduleId === modId);
            if (headerIdx >= 0) setIdx(headerIdx);
            return;
          }
        }

        if (e.key === 'ArrowRight' && sel.type === 'module-item') {
          e.preventDefault();
          const agentId = path[0];
          navigateIntoModule(sel.moduleId, agentId);
          return;
        }

        if (e.key === 'ArrowLeft' && sel.type === 'module') {
          e.preventDefault();
          const agentId = path[0];
          const lastModId = path[path.length - 1];
          const saved = navHistory[agentId];
          setPath([agentId]);
          const r = rowsRef.current;
          let i = r.findIndex(x => x.type==='module-item' && x.moduleId===lastModId);
          if (i < 0 && Number.isFinite(saved)) i = saved;
          if (i >= 0) setIdx(i);
          return;
        }

        const lastIndex = rws.length - 1;
        const gotoIndex = (n) => { setIdx(n); };

        if (e.key === 'ArrowUp') { e.preventDefault(); gotoIndex(Math.max(0, idx - 1)); return; }

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (idx < lastIndex) {
            gotoIndex(Math.min(lastIndex, idx + 1));
          } else {
            setOmniActive(true);
            setTimeout(()=>{ if (omniInputRef.current) omniInputRef.current.focus(); }, 0);
          }
          return;
        }

        if (e.key === 'Escape') {
          e.preventDefault();
          if (instrUi.isFor(sel.key)) { instrUi.closeAll(); return; }
          if (path.length > 1) {
            const newPath = path.slice(0, -1);
            const savedIdx = navHistory[newPath[0]];
            setPath(newPath);
            setIdx(Number.isFinite(savedIdx) ? savedIdx : 0);
            return;
          }
        }
      }, [idx, path, instrUi, navHistory, reorderState, hoverAction, navigateIntoModule, moveItemInReorderMode, endReorder, duplicateInstruction, removeInstructionAtPos]);

      useEffect(() => { window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [handleKeyDown]);

      useEffect(() => {
        const hash = '#' + path.join('/'); if (window.location.hash !== hash) window.history.pushState(null, '', hash);
      }, [path]);

      useEffect(() => {
        const handlePopState = () => {
          const hash = window.location.hash slice(1);
          if (hash) {
            const parts = hash.split('/').filter(Boolean);
            if (parts.length > 0) setPath(parts);
          } else setPath(['expert-maker']);
        };
        window.addEventListener('popstate', handlePopState);
        return () => window.removeEventListener('popstate', handlePopState);
      }, []);

      const suppressSel = false;
      const currentOmniList = omniQuery.trim() ? omniResults : omniSuggestions;

      useEffect(() => {
        if (omniSelectedIdx >= currentOmniList.length && currentOmniList.length > 0) {
          setOmniSelectedIdx(currentOmniList.length - 1);
        } else if (currentOmniList.length === 0) {
          setOmniSelectedIdx(0);
        }
      }, [currentOmniList, omniSelectedIdx]);

      return (
        <div className="layout">
          <div className="left-column">
            <div className="panel">
              <div className="sc-title">
                <span><strong><em>(: Smile Composer)</em></strong></span>
                <button className="reset-btn" type="button" onClick={handleReset}>Reset to default</button>
              </div>
              {rows.map((row, i) => {
                const isSelected = (i === idx) && !suppressSel;
                const showInline = row.type === 'instr' && instrUi.isFor(row.key) && (i === idx);

                return (
                  <React.Fragment key={row.key}>
                    <div
                      className={['line', isSelected ? 'sel' : ''].join(' ').trim()}
                      style={{ paddingLeft: (row.depth || 0) * TAB }}
                      data-key={row.key}
                      onClick={() => setIdx(i)}
                      onDoubleClick={() => {
                        if (row.type === 'instr') {
                          if (!instrUi.isFor(row.key)) { instrUi.openStage1(row.key); focusInlineTextarea(row.key); }
                          else if (instrUi.stage() === 1) { instrUi.toStage2(); }
                        } else if (row.type === 'module-item') {
                          const agentId = path[0];
                          navigateIntoModule(row.moduleId, agentId);
                        }
                      }}
                      title="Select"
                    >
                      <span className="left-span">
                        {row.isOutput ? <strong>OUTPUT: </strong> : null}{row.label}
                      </span>
                    </div>

                    {row.type === 'instr' && !showInline && isSelected && (
                      <InstructionPreviewLine store={store} row={row} />
                    )}

                    {showInline && row.type === 'instr' && (
                      <>
                        <InstructionInlineEditor
                          store={store}
                          row={row}
                          onTextChange={updateData}
                          getNameOverride={(k, f) => store.get(k, f || '')}
                          setNameOverride={(k, v) => updateData(k, v)}
                          getMeta={(k) => store.get(k, '')}
                          setMeta={(k, v) => updateData(k, v)}
                          getStruct={(k) => store.get(k, 'heavy')}
                          setStruct={(k, v) => updateData(k, v)}
                          stage={instrUi.stage()}
                          onDownFromMainToMeta={() => focusMetaTextarea(row.key)}
                        />
                        <ActionBar pad={((row.depth || 0) + 1) * TAB} />
                        {instrUi.stage() === 2 && (
                          <SettingsButtons
                            pad={((row.depth || 0) + 1) * TAB}
                            hoverAction={hoverAction}
                            onEnterMove={() => { startMove(row); setHoverAction('move'); setHoverRowKey(row.key); }}
                            onLeaveMove={() => { endReorder(); setHoverAction(null); setHoverRowKey(null); }}
                            onEnterDuplicate={() => { setHoverAction('duplicate'); setHoverRowKey(row.key); }}
                            onLeaveDuplicate={() => { setHoverAction(null); setHoverRowKey(null); }}
                            onEnterDelete={() => { setHoverAction('delete'); setHoverRowKey(row.key); }}
                            onLeaveDelete={() => { setHoverAction(null); setHoverRowKey(null); }}
                          />
                        )}
                      </>
                    )}

                    {i === idx && row.type === 'module-item' && (
                      <ModulePreview store={store} moduleId={row.moduleId} depth={row.depth} />
                    )}
                  </React.Fragment>
                );
              })}
            </div>

            <div className="add-bar">
              <div className="dock">
                <input
                  ref={omniInputRef}
                  className="omni-input"
                  placeholder={`Press + or Enter to add a new ${atModule ? 'Instruction' : 'Module'}.`}
                  value={omniQuery}
                  onFocus={() => { setOmniActive(true); setOmniFocus(true); }}
                  onBlur={() => { setOmniFocus(false); }}
                  onChange={e => { setOmniQuery(e.target.value); setOmniSelectedIdx(0); }}
                  onKeyDown={(e) => {
                    const list = currentOmniList;

                    if (e.key === 'Enter' || e.key === 'ArrowRight') {
                      e.preventDefault();
                      if (list.length > 0 && omniSelectedIdx >= 0 && omniSelectedIdx < list.length) {
                        const selected = list[omniSelectedIdx];
                        addByIdAtContext(selected.id);
                      } else {
                        createAndAddNewItem();
                      }
                      setOmniActive(false);
                      setOmniQuery('');
                      setOmniSelectedIdx(0);
                      if (omniInputRef.current) { try { omniInputRef.current.blur(); } catch(_) {} }
                      return;
                    }

                    if (e.key === 'Escape') {
                      e.preventDefault();
                      setOmniActive(false);
                      setOmniQuery('');
                      setOmniSelectedIdx(0);
                      if (omniInputRef.current) { try { omniInputRef.current.blur(); } catch(_) {} }
                      return;
                    }

                    if (e.key === 'ArrowDown') {
                      e.preventDefault();
                      if (list.length > 0) setOmniSelectedIdx(prev => Math.min(list.length - 1, prev + 1));
                      return;
                    }

                    if (e.key === 'ArrowUp') {
                      e.preventDefault();
                      if (list.length > 0 && omniSelectedIdx > 0) {
                        setOmniSelectedIdx(prev => Math.max(0, prev - 1));
                        return;
                      }
                      if (omniInputRef.current) { try { omniInputRef.current.blur(); } catch(_) {} }
                      setOmniActive(false);
                      setOmniQuery('');
                      setOmniSelectedIdx(0);
                      const bottom = Math.max(0, rowsRef.current.length - 1);
                      setIdx(bottom);
                      return;
                    }
                  }}
                />
                {(omniActive && (omniQuery.trim() || omniSuggestions.length)) ? (
                  <div className="omni-list">
                    { currentOmniList.length === 0 && (
                      <div className="omni-item"><span>No suggestions</span></div>
                    )}
                    {currentOmniList.map((r, i) => (
                      <div
                        key={r.id + ':' + i}
                        className={`omni-item ${i === omniSelectedIdx ? 'sel' : ''}`}
                        onClick={() => {
                          addByIdAtContext(r.id);
                          setOmniActive(false);
                          setOmniQuery('');
                          setOmniSelectedIdx(0);
                          if (omniInputRef.current) { try { omniInputRef.current.blur(); } catch(_) {} }
                        }}
                      >
                        <span>{r.name}</span>
                        <span className="badge">{r.type === 'mod' ? 'module' : 'instruction'}</span>
                      </div>
                    ))}
                  </div>
                ) : null}
              </div>
            </div>
          </div>

          <RightSidebar
            value={rightbarValue}
            onChange={(e) => { updateData('rightbar-prompt', e.target.value); updateData('rightbar-prompt-manual', true); }}
          />
        </div>
      );
    }

    try {
      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    } catch (e) {
      console.error('Mount error:', e);
      document.getElementById('root').innerHTML = '<div class="error">Failed to mount: ' + e.message + '</div>';
    }
  })();
  </script>
</body>
</html>
